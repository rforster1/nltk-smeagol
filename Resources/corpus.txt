Python Tutorial
Release 3.7.0
Guido van Rossum
and the Python development team
September 02, 2018
Python Software Foundation
Email: docs@python.org

CONTENTS
1 Whetting Your Appetite 3
2 Using the Python Interpreter 5
2.1 Invoking the Interpreter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2.2 The Interpreter and Its Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
3 An Informal Introduction to Python 9
3.1 Using Python as a Calculator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.2 First Steps Towards Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4 More Control Flow Tools 19
4.1 if Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.2 for Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.3 The range() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.4 break and continue Statements, and else Clauses on Loops . . . . . . . . . . . . . . . . . . 21
4.5 pass Statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
4.6 Defining Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
4.7 More on Defining Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.8 Intermezzo: Coding Style . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
5 Data Structures 31
5.1 More on Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
5.2 The del statement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
5.3 Tuples and Sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36
5.4 Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
5.5 Dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
5.6 Looping Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
5.7 More on Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
5.8 Comparing Sequences and Other Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
6 Modules 43
6.1 More on Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
6.2 Standard Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46
6.3 The dir() Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
6.4 Packages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48
7 Input and Output 53
7.1 Fancier Output Formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53
7.2 Reading and Writing Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
8 Errors and Exceptions 61
i
8.1 Syntax Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
8.2 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61
8.3 Handling Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
8.4 Raising Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
8.5 User-defined Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
8.6 Defining Clean-up Actions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
8.7 Predefined Clean-up Actions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
9 Classes 69
9.1 A Word About Names and Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
9.2 Python Scopes and Namespaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
9.3 A First Look at Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
9.4 Random Remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
9.5 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
9.6 Private Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
9.7 Odds and Ends . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
9.8 Iterators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
9.9 Generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
9.10 Generator Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
10 Brief Tour of the Standard Library 83
10.1 Operating System Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
10.2 File Wildcards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
10.3 Command Line Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
10.4 Error Output Redirection and Program Termination . . . . . . . . . . . . . . . . . . . . . . . 84
10.5 String Pattern Matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
10.6 Mathematics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
10.7 Internet Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
10.8 Dates and Times . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
10.9 Data Compression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
10.10 Performance Measurement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
10.11 Quality Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
10.12 Batteries Included . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
11 Brief Tour of the Standard Library — Part II 89
11.1 Output Formatting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
11.2 Templating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
11.3 Working with Binary Data Record Layouts . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
11.4 Multi-threading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
11.5 Logging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
11.6 Weak References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
11.7 Tools for Working with Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
11.8 Decimal Floating Point Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
12 Virtual Environments and Packages 97
12.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
12.2 Creating Virtual Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97
12.3 Managing Packages with pip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
13 What Now? 101
14 Interactive Input Editing and History Substitution 103
14.1 Tab Completion and History Editing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
14.2 Alternatives to the Interactive Interpreter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
ii
15 Floating Point Arithmetic: Issues and Limitations 105
15.1 Representation Error . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108
16 Appendix 111
16.1 Interactive Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
A Glossary 113
B About these documents 127
B.1 Contributors to the Python Documentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
C History and License 129
C.1 History of the software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
C.2 Terms and conditions for accessing or otherwise using Python . . . . . . . . . . . . . . . . . 130
C.3 Licenses and Acknowledgements for Incorporated Software . . . . . . . . . . . . . . . . . . . 133
D Copyright 145
Index 147
iii
iv
Python Tutorial, Release 3.7.0
Python is an easy to learn, powerful programming language. It has efficient high-level data structures and
a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic
typing, together with its interpreted nature, make it an ideal language for scripting and rapid application
development in many areas on most platforms.
The Python interpreter and the extensive standard library are freely available in source or binary form for all
major platforms from the Python Web site, https://www.python.org/, and may be freely distributed. The
same site also contains distributions of and pointers to many free third party Python modules, programs
and tools, and additional documentation.
The Python interpreter is easily extended with new functions and data types implemented in C or C++
(or other languages callable from C). Python is also suitable as an extension language for customizable
applications.
This tutorial introduces the reader informally to the basic concepts and features of the Python language
and system. It helps to have a Python interpreter handy for hands-on experience, but all examples are
self-contained, so the tutorial can be read off-line as well.
For a description of standard objects and modules, see library-index. reference-index gives a more formal
definition of the language. To write extensions in C or C++, read extending-index and c-api-index. There
are also several books covering Python in depth.
This tutorial does not attempt to be comprehensive and cover every single feature, or even every commonly
used feature. Instead, it introduces many of Python’s most noteworthy features, and will give you a good
idea of the language’s flavor and style. After reading it, you will be able to read and write Python modules
and programs, and you will be ready to learn more about the various Python library modules described in
library-index.
The Glossary is also worth going through.
CONTENTS 1
Python Tutorial, Release 3.7.0
2 CONTENTS
CHAPTER
ONE
WHETTING YOUR APPETITE
If you do much work on computers, eventually you find that there’s some task you’d like to automate. For
example, you may wish to perform a search-and-replace over a large number of text files, or rename and
rearrange a bunch of photo files in a complicated way. Perhaps you’d like to write a small custom database,
or a specialized GUI application, or a simple game.
If you’re a professional software developer, you may have to work with several C/C++/Java libraries but
find the usual write/compile/test/re-compile cycle is too slow. Perhaps you’re writing a test suite for such
a library and find writing the testing code a tedious task. Or maybe you’ve written a program that could
use an extension language, and you don’t want to design and implement a whole new language for your
application.
Python is just the language for you.
You could write a Unix shell script or Windows batch files for some of these tasks, but shell scripts are best
at moving around files and changing text data, not well-suited for GUI applications or games. You could
write a C/C++/Java program, but it can take a lot of development time to get even a first-draft program.
Python is simpler to use, available on Windows, Mac OS X, and Unix operating systems, and will help you
get the job done more quickly.
Python is simple to use, but it is a real programming language, offering much more structure and support
for large programs than shell scripts or batch files can offer. On the other hand, Python also offers much
more error checking than C, and, being a very-high-level language, it has high-level data types built in, such
as flexible arrays and dictionaries. Because of its more general data types Python is applicable to a much
larger problem domain than Awk or even Perl, yet many things are at least as easy in Python as in those
languages.
Python allows you to split your program into modules that can be reused in other Python programs. It
comes with a large collection of standard modules that you can use as the basis of your programs — or as
examples to start learning to program in Python. Some of these modules provide things like file I/O, system
calls, sockets, and even interfaces to graphical user interface toolkits like Tk.
Python is an interpreted language, which can save you considerable time during program development
because no compilation and linking is necessary. The interpreter can be used interactively, which makes it
easy to experiment with features of the language, to write throw-away programs, or to test functions during
bottom-up program development. It is also a handy desk calculator.
Python enables programs to be written compactly and readably. Programs written in Python are typically
much shorter than equivalent C, C++, or Java programs, for several reasons:
• the high-level data types allow you to express complex operations in a single statement;
• statement grouping is done by indentation instead of beginning and ending brackets;
• no variable or argument declarations are necessary.
Python is extensible: if you know how to program in C it is easy to add a new built-in function or module
to the interpreter, either to perform critical operations at maximum speed, or to link Python programs to
libraries that may only be available in binary form (such as a vendor-specific graphics library). Once you
3
Python Tutorial, Release 3.7.0
are really hooked, you can link the Python interpreter into an application written in C and use it as an
extension or command language for that application.
By the way, the language is named after the BBC show “Monty Python’s Flying Circus” and has nothing
to do with reptiles. Making references to Monty Python skits in documentation is not only allowed, it is
encouraged!
Now that you are all excited about Python, you’ll want to examine it in some more detail. Since the best
way to learn a language is to use it, the tutorial invites you to play with the Python interpreter as you read.
In the next chapter, the mechanics of using the interpreter are explained. This is rather mundane information,
but essential for trying out the examples shown later.
The rest of the tutorial introduces various features of the Python language and system through examples,
beginning with simple expressions, statements and data types, through functions and modules, and finally
touching upon advanced concepts like exceptions and user-defined classes.
4 Chapter 1. Whetting Your Appetite
CHAPTER
TWO
USING THE PYTHON INTERPRETER
2.1 Invoking the Interpreter
The Python interpreter is usually installed as /usr/local/bin/python3.7 on those machines where it is
available; putting /usr/local/bin in your Unix shell’s search path makes it possible to start it by typing
the command:
python3.7
to the shell.1 Since the choice of the directory where the interpreter lives is an installation option, other
places are possible; check with your local Python guru or system administrator. (E.g., /usr/local/python
is a popular alternative location.)
On Windows machines, the Python installation is usually placed in C:\Program Files\Python37\, though
you can change this when you’re running the installer. To add this directory to your path, you can
type the following command into the command prompt in a DOS box:
set path=%path%;C:\Program Files\Python37\
Typing an end-of-file character (Control-D on Unix, Control-Z on Windows) at the primary prompt causes
the interpreter to exit with a zero exit status. If that doesn’t work, you can exit the interpreter by typing
the following command: quit().
The interpreter’s line-editing features include interactive editing, history substitution and code completion
on systems that support readline. Perhaps the quickest check to see whether command line editing is
supported is typing Control-P to the first Python prompt you get. If it beeps, you have command line
editing; see Appendix Interactive Input Editing and History Substitution for an introduction to the keys. If
nothing appears to happen, or if ^P is echoed, command line editing isn’t available; you’ll only be able to
use backspace to remove characters from the current line.
The interpreter operates somewhat like the Unix shell: when called with standard input connected to a tty
device, it reads and executes commands interactively; when called with a file name argument or with a file
as standard input, it reads and executes a script from that file.
A second way of starting the interpreter is python -c command [arg] ..., which executes the statement(s)
in command, analogous to the shell’s -c option. Since Python statements often contain spaces or other
characters that are special to the shell, it is usually advised to quote command in its entirety with single
quotes.
Some Python modules are also useful as scripts. These can be invoked using python -m module [arg] ...,
which executes the source file for module as if you had spelled out its full name on the command line.
When a script file is used, it is sometimes useful to be able to run the script and enter interactive mode
afterwards. This can be done by passing -i before the script.
1 On Unix, the Python 3.x interpreter is by default not installed with the executable named python, so that it does not
conflict with a simultaneously installed Python 2.x executable.
5
Python Tutorial, Release 3.7.0
All command line options are described in using-on-general.
2.1.1 Argument Passing
When known to the interpreter, the script name and additional arguments thereafter are turned into a list
of strings and assigned to the argv variable in the sys module. You can access this list by executing import
sys. The length of the list is at least one; when no script and no arguments are given, sys.argv[0] is an
empty string. When the script name is given as '-' (meaning standard input), sys.argv[0] is set to '-'.
When -c command is used, sys.argv[0] is set to '-c'. When -m module is used, sys.argv[0] is set to
the full name of the located module. Options found after -c command or -m module are not consumed by
the Python interpreter’s option processing but left in sys.argv for the command or module to handle.
2.1.2 Interactive Mode
When commands are read from a tty, the interpreter is said to be in interactive mode. In this mode it prompts
for the next command with the primary prompt, usually three greater-than signs (>>>); for continuation lines
it prompts with the secondary prompt, by default three dots (...). The interpreter prints a welcome message
stating its version number and a copyright notice before printing the first prompt:
$ python3.7
Python 3.7 (default, Sep 16 2015, 09:25:04)
[GCC 4.8.2] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>>
Continuation lines are needed when entering a multi-line construct. As an example, take a look at this if
statement:
>>> the_world_is_flat = True
>>> if the_world_is_flat:
... print("Be careful not to fall off!")
...
Be careful not to fall off!
For more on interactive mode, see Interactive Mode.
2.2 The Interpreter and Its Environment
2.2.1 Source Code Encoding
By default, Python source files are treated as encoded in UTF-8. In that encoding, characters of most
languages in the world can be used simultaneously in string literals, identifiers and comments — although
the standard library only uses ASCII characters for identifiers, a convention that any portable code should
follow. To display all these characters properly, your editor must recognize that the file is UTF-8, and it
must use a font that supports all the characters in the file.
To declare an encoding other than the default one, a special comment line should be added as the first line
of the file. The syntax is as follows:
# -*- coding: encoding -*-
where encoding is one of the valid codecs supported by Python.
6 Chapter 2. Using the Python Interpreter
Python Tutorial, Release 3.7.0
For example, to declare that Windows-1252 encoding is to be used, the first line of your source code file
should be:
# -*- coding: cp1252 -*-
One exception to the first line rule is when the source code starts with a UNIX “shebang” line. In this case,
the encoding declaration should be added as the second line of the file. For example:
#!/usr/bin/env python3
# -*- coding: cp1252 -*-
2.2. The Interpreter and Its Environment 7
Python Tutorial, Release 3.7.0
8 Chapter 2. Using the Python Interpreter
CHAPTER
THREE
AN INFORMAL INTRODUCTION TO PYTHON
In the following examples, input and output are distinguished by the presence or absence of prompts (>>>
and …): to repeat the example, you must type everything after the prompt, when the prompt appears; lines
that do not begin with a prompt are output from the interpreter. Note that a secondary prompt on a line
by itself in an example means you must type a blank line; this is used to end a multi-line command.
Many of the examples in this manual, even those entered at the interactive prompt, include comments.
Comments in Python start with the hash character, #, and extend to the end of the physical line. A
comment may appear at the start of a line or following whitespace or code, but not within a string literal.
A hash character within a string literal is just a hash character. Since comments are to clarify code and are
not interpreted by Python, they may be omitted when typing in examples.
Some examples:
# this is the first comment
spam = 1 # and this is the second comment
# ... and now a third!
text = "# This is not a comment because it's inside quotes."
3.1 Using Python as a Calculator
Let’s try some simple Python commands. Start the interpreter and wait for the primary prompt, >>>. (It
shouldn’t take long.)
3.1.1 Numbers
The interpreter acts as a simple calculator: you can type an expression at it and it will write the value.
Expression syntax is straightforward: the operators +, -, * and / work just like in most other languages (for
example, Pascal or C); parentheses (()) can be used for grouping. For example:
>>> 2 + 2
4
>>> 50 - 5*6
20
>>> (50 - 5*6) / 4
5.0
>>> 8 / 5 # division always returns a floating point number
1.6
The integer numbers (e.g. 2, 4, 20) have type int, the ones with a fractional part (e.g. 5.0, 1.6) have type
float. We will see more about numeric types later in the tutorial.
9
Python Tutorial, Release 3.7.0
Division (/) always returns a float. To do floor division and get an integer result (discarding any fractional
result) you can use the // operator; to calculate the remainder you can use %:
>>> 17 / 3 # classic division returns a float
5.666666666666667
>>>
>>> 17 // 3 # floor division discards the fractional part
5
>>> 17 % 3 # the % operator returns the remainder of the division
2
>>> 5 * 3 + 2 # result * divisor + remainder
17
With Python, it is possible to use the ** operator to calculate powers1
:
>>> 5 ** 2 # 5 squared
25
>>> 2 ** 7 # 2 to the power of 7
128
The equal sign (=) is used to assign a value to a variable. Afterwards, no result is displayed before the next
interactive prompt:
>>> width = 20
>>> height = 5 * 9
>>> width * height
900
If a variable is not “defined” (assigned a value), trying to use it will give you an error:
>>> n # try to access an undefined variable
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
There is full support for floating point; operators with mixed type operands convert the integer operand to
floating point:
>>> 4 * 3.75 - 1
14.0
In interactive mode, the last printed expression is assigned to the variable _. This means that when you are
using Python as a desk calculator, it is somewhat easier to continue calculations, for example:
>>> tax = 12.5 / 100
>>> price = 100.50
>>> price * tax
12.5625
>>> price + _
113.0625
>>> round(_, 2)
113.06
This variable should be treated as read-only by the user. Don’t explicitly assign a value to it — you
would create an independent local variable with the same name masking the built-in variable with its magic
behavior.
1 Since ** has higher precedence than -, -3**2 will be interpreted as -(3**2) and thus result in -9. To avoid this and get
9, you can use (-3)**2.
10 Chapter 3. An Informal Introduction to Python
Python Tutorial, Release 3.7.0
In addition to int and float, Python supports other types of numbers, such as Decimal and Fraction.
Python also has built-in support for complex numbers, and uses the j or J suffix to indicate the imaginary
part (e.g. 3+5j).
3.1.2 Strings
Besides numbers, Python can also manipulate strings, which can be expressed in several ways. They can be
enclosed in single quotes ('...') or double quotes ("...") with the same result2
. \ can be used to escape
quotes:
>>> 'spam eggs' # single quotes
'spam eggs'
>>> 'doesn\'t' # use \' to escape the single quote...
"doesn't"
>>> "doesn't" # ...or use double quotes instead
"doesn't"
>>> '"Yes," they said.'
'"Yes," they said.'
>>> "\"Yes,\" they said."
'"Yes," they said.'
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
In the interactive interpreter, the output string is enclosed in quotes and special characters are escaped with
backslashes. While this might sometimes look different from the input (the enclosing quotes could change),
the two strings are equivalent. The string is enclosed in double quotes if the string contains a single quote
and no double quotes, otherwise it is enclosed in single quotes. The print() function produces a more
readable output, by omitting the enclosing quotes and by printing escaped and special characters:
>>> '"Isn\'t," they said.'
'"Isn\'t," they said.'
>>> print('"Isn\'t," they said.')
"Isn't," they said.
>>> s = 'First line.\nSecond line.' # \n means newline
>>> s # without print(), \n is included in the output
'First line.\nSecond line.'
>>> print(s) # with print(), \n produces a new line
First line.
Second line.
If you don’t want characters prefaced by \ to be interpreted as special characters, you can use raw strings
by adding an r before the first quote:
>>> print('C:\some\name') # here \n means newline!
C:\some
ame
>>> print(r'C:\some\name') # note the r before the quote
C:\some\name
String literals can span multiple lines. One way is using triple-quotes: """...""" or '''...'''. End of
lines are automatically included in the string, but it’s possible to prevent this by adding a \ at the end of
the line. The following example:
2 Unlike other languages, special characters such as \n have the same meaning with both single ('...') and double ("...")
quotes. The only difference between the two is that within single quotes you don’t need to escape " (but you have to escape
\') and vice versa.
3.1. Using Python as a Calculator 11
Python Tutorial, Release 3.7.0
print("""\
Usage: thingy [OPTIONS]
-h Display this usage message
-H hostname Hostname to connect to
""")
produces the following output (note that the initial newline is not included):
Usage: thingy [OPTIONS]
-h Display this usage message
-H hostname Hostname to connect to
Strings can be concatenated (glued together) with the + operator, and repeated with *:
>>> # 3 times 'un', followed by 'ium'
>>> 3 * 'un' + 'ium'
'unununium'
Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically
concatenated.
>>> 'Py' 'thon'
'Python'
This feature is particularly useful when you want to break long strings:
>>> text = ('Put several strings within parentheses '
... 'to have them joined together.')
>>> text
'Put several strings within parentheses to have them joined together.'
This only works with two literals though, not with variables or expressions:
>>> prefix = 'Py'
>>> prefix 'thon' # can't concatenate a variable and a string literal
...
SyntaxError: invalid syntax
>>> ('un' * 3) 'ium'
...
SyntaxError: invalid syntax
If you want to concatenate variables or a variable and a literal, use +:
>>> prefix + 'thon'
'Python'
Strings can be indexed (subscripted), with the first character having index 0. There is no separate character
type; a character is simply a string of size one:
>>> word = 'Python'
>>> word[0] # character in position 0
'P'
>>> word[5] # character in position 5
'n'
Indices may also be negative numbers, to start counting from the right:
12 Chapter 3. An Informal Introduction to Python
Python Tutorial, Release 3.7.0
>>> word[-1] # last character
'n'
>>> word[-2] # second-last character
'o'
>>> word[-6]
'P'
Note that since -0 is the same as 0, negative indices start from -1.
In addition to indexing, slicing is also supported. While indexing is used to obtain individual characters,
slicing allows you to obtain substring:
>>> word[0:2] # characters from position 0 (included) to 2 (excluded)
'Py'
>>> word[2:5] # characters from position 2 (included) to 5 (excluded)
'tho'
Note how the start is always included, and the end always excluded. This makes sure that s[:i] + s[i:]
is always equal to s:
>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults
to the size of the string being sliced.
>>> word[:2] # character from the beginning to position 2 (excluded)
'Py'
>>> word[4:] # characters from position 4 (included) to the end
'on'
>>> word[-2:] # characters from the second-last (included) to the end
'on'
One way to remember how slices work is to think of the indices as pointing between characters, with the left
edge of the first character numbered 0. Then the right edge of the last character of a string of n characters
has index n, for example:
+---+---+---+---+---+---+
| P | y | t | h | o | n |
+---+---+---+---+---+---+
0 1 2 3 4 5 6
-6 -5 -4 -3 -2 -1
The first row of numbers gives the position of the indices 0…6 in the string; the second row gives the
corresponding negative indices. The slice from i to j consists of all characters between the edges labeled i
and j, respectively.
For non-negative indices, the length of a slice is the difference of the indices, if both are within bounds. For
example, the length of word[1:3] is 2.
Attempting to use an index that is too large will result in an error:
>>> word[42] # the word only has 6 characters
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
IndexError: string index out of range
3.1. Using Python as a Calculator 13
Python Tutorial, Release 3.7.0
However, out of range slice indexes are handled gracefully when used for slicing:
>>> word[4:42]
'on'
>>> word[42:]
''
Python strings cannot be changed — they are immutable. Therefore, assigning to an indexed position in the
string results in an error:
>>> word[0] = 'J'
...
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
...
TypeError: 'str' object does not support item assignment
If you need a different string, you should create a new one:
>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
The built-in function len() returns the length of a string:
>>> s = 'supercalifragilisticexpialidocious'
>>> len(s)
34
See also:
textseq Strings are examples of sequence types, and support the common operations supported by such
types.
string-methods Strings support a large number of methods for basic transformations and searching.
f-strings String literals that have embedded expressions.
formatstrings Information about string formatting with str.format().
old-string-formatting The old formatting operations invoked when strings are the left operand of the %
operator are described in more detail here.
3.1.3 Lists
Python knows a number of compound data types, used to group together other values. The most versatile
is the list, which can be written as a list of comma-separated values (items) between square brackets. Lists
might contain items of different types, but usually the items all have the same type.
>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
Like strings (and all other built-in sequence type), lists can be indexed and sliced:
>>> squares[0] # indexing returns the item
1
>>> squares[-1]
(continues on next page)
14 Chapter 3. An Informal Introduction to Python
Python Tutorial, Release 3.7.0
(continued from previous page)
25
>>> squares[-3:] # slicing returns a new list
[9, 16, 25]
All slice operations return a new list containing the requested elements. This means that the following slice
returns a new (shallow) copy of the list:
>>> squares[:]
[1, 4, 9, 16, 25]
Lists also support operations like concatenation:
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content:
>>> cubes = [1, 8, 27, 65, 125] # something's wrong here
>>> 4 ** 3 # the cube of 4 is 64, not 65!
64
>>> cubes[3] = 64 # replace the wrong value
>>> cubes
[1, 8, 27, 64, 125]
You can also add new items at the end of the list, by using the append() method (we will see more about
methods later):
>>> cubes.append(216) # add the cube of 6
>>> cubes.append(7 ** 3) # and the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
Assignment to slices is also possible, and this can even change the size of the list or clear it entirely:
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
>>> # replace some values
>>> letters[2:5] = ['C', 'D', 'E']
>>> letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
>>> # now remove them
>>> letters[2:5] = []
>>> letters
['a', 'b', 'f', 'g']
>>> # clear the list by replacing all the elements with an empty list
>>> letters[:] = []
>>> letters
[]
The built-in function len() also applies to lists:
>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
It is possible to nest lists (create lists containing other lists), for example:
3.1. Using Python as a Calculator 15
Python Tutorial, Release 3.7.0
>>> a = ['a', 'b', 'c']
>>> n = [1, 2, 3]
>>> x = [a, n]
>>> x
[['a', 'b', 'c'], [1, 2, 3]]
>>> x[0]
['a', 'b', 'c']
>>> x[0][1]
'b'
3.2 First Steps Towards Programming
Of course, we can use Python for more complicated tasks than adding two and two together. For instance,
we can write an initial sub-sequence of the Fibonacci series as follows:
>>> # Fibonacci series:
... # the sum of two elements defines the next
... a, b = 0, 1
>>> while a < 10:
... print(a)
... a, b = b, a+b
...
0
1
1
2
3
5
8
This example introduces several new features.
• The first line contains a multiple assignment: the variables a and b simultaneously get the new values
0 and 1. On the last line this is used again, demonstrating that the expressions on the right-hand side
are all evaluated first before any of the assignments take place. The right-hand side expressions are
evaluated from the left to the right.
• The while loop executes as long as the condition (here: a < 10) remains true. In Python, like in C,
any non-zero integer value is true; zero is false. The condition may also be a string or list value, in
fact any sequence; anything with a non-zero length is true, empty sequences are false. The test used
in the example is a simple comparison. The standard comparison operators are written the same as in
C: < (less than), > (greater than), == (equal to), <= (less than or equal to), >= (greater than or equal
to) and != (not equal to).
• The body of the loop is indented: indentation is Python’s way of grouping statements. At the interactive
prompt, you have to type a tab or space(s) for each indented line. In practice you will prepare more
complicated input for Python with a text editor; all decent text editors have an auto-indent facility.
When a compound statement is entered interactively, it must be followed by a blank line to indicate
completion (since the parser cannot guess when you have typed the last line). Note that each line
within a basic block must be indented by the same amount.
• The print() function writes the value of the argument(s) it is given. It differs from just writing
the expression you want to write (as we did earlier in the calculator examples) in the way it handles
multiple arguments, floating point quantities, and strings. Strings are printed without quotes, and a
space is inserted between items, so you can format things nicely, like this:
16 Chapter 3. An Informal Introduction to Python
Python Tutorial, Release 3.7.0
>>> i = 256*256
>>> print('The value of i is', i)
The value of i is 65536
The keyword argument end can be used to avoid the newline after the output, or end the output with
a different string:
>>> a, b = 0, 1
>>> while a < 1000:
... print(a, end=',')
... a, b = b, a+b
...
0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
3.2. First Steps Towards Programming 17
Python Tutorial, Release 3.7.0
18 Chapter 3. An Informal Introduction to Python
CHAPTER
FOUR
MORE CONTROL FLOW TOOLS
Besides the while statement just introduced, Python knows the usual control flow statements known from
other languages, with some twists.
4.1 if Statements
Perhaps the most well-known statement type is the if statement. For example:
>>> x = int(input("Please enter an integer: "))
Please enter an integer: 42
>>> if x < 0:
... x = 0
... print('Negative changed to zero')
... elif x == 0:
... print('Zero')
... elif x == 1:
... print('Single')
... else:
... print('More')
...
More
There can be zero or more elif parts, and the else part is optional. The keyword ‘elif’ is short for ‘else
if’, and is useful to avoid excessive indentation. An if … elif … elif … sequence is a substitute for the
switch or case statements found in other languages.
4.2 for Statements
The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always
iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define
both the iteration step and halting condition (as C), Python’s for statement iterates over the items of any
sequence (a list or a string), in the order that they appear in the sequence. For example (no pun intended):
>>> # Measure some strings:
... words = ['cat', 'window', 'defenestrate']
>>> for w in words:
... print(w, len(w))
...
cat 3
window 6
defenestrate 12
19
Python Tutorial, Release 3.7.0
If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate
selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly
make a copy. The slice notation makes this especially convenient:
>>> for w in words[:]: # Loop over a slice copy of the entire list.
... if len(w) > 6:
... words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']
With for w in words:, the example would attempt to create an infinite list, inserting defenestrate over
and over again.
4.3 The range() Function
If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It
generates arithmetic progressions:
>>> for i in range(5):
... print(i)
...
0
1
2
3
4
The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices
for items of a sequence of length 10. It is possible to let the range start at another number, or to specify a
different increment (even negative; sometimes this is called the ‘step’):
range(5, 10)
5, 6, 7, 8, 9
range(0, 10, 3)
0, 3, 6, 9
range(-10, -100, -30)
-10, -40, -70
To iterate over the indices of a sequence, you can combine range() and len() as follows:
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']
>>> for i in range(len(a)):
... print(i, a[i])
...
0 Mary
1 had
2 a
3 little
4 lamb
In most such cases, however, it is convenient to use the enumerate() function, see Looping Techniques.
A strange thing happens if you just print a range:
20 Chapter 4. More Control Flow Tools
Python Tutorial, Release 3.7.0
>>> print(range(10))
range(0, 10)
In many ways the object returned by range() behaves as if it is a list, but in fact it isn’t. It is an object
which returns the successive items of the desired sequence when you iterate over it, but it doesn’t really
make the list, thus saving space.
We say such an object is iterable, that is, suitable as a target for functions and constructs that expect
something from which they can obtain successive items until the supply is exhausted. We have seen that
the for statement is such an iterator. The function list() is another; it creates lists from iterables:
>>> list(range(5))
[0, 1, 2, 3, 4]
Later we will see more functions that return iterables and take iterables as argument.
4.4 break and continue Statements, and else Clauses on Loops
The break statement, like in C, breaks out of the innermost enclosing for or while loop.
Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of
the list (with for) or when the condition becomes false (with while), but not when the loop is terminated
by a break statement. This is exemplified by the following loop, which searches for prime numbers:
>>> for n in range(2, 10):
... for x in range(2, n):
... if n % x == 0:
... print(n, 'equals', x, '*', n//x)
... break
... else:
... # loop fell through without finding a factor
... print(n, 'is a prime number')
...
2 is a prime number
3 is a prime number
4 equals 2 * 2
5 is a prime number
6 equals 2 * 3
7 is a prime number
8 equals 2 * 4
9 equals 3 * 3
(Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.)
When used with a loop, the else clause has more in common with the else clause of a try statement than it
does that of if statements: a try statement’s else clause runs when no exception occurs, and a loop’s else
clause runs when no break occurs. For more on the try statement and exceptions, see Handling Exceptions.
The continue statement, also borrowed from C, continues with the next iteration of the loop:
>>> for num in range(2, 10):
... if num % 2 == 0:
... print("Found an even number", num)
... continue
... print("Found a number", num)
Found an even number 2
(continues on next page)
4.4. break and continue Statements, and else Clauses on Loops 21
Python Tutorial, Release 3.7.0
(continued from previous page)
Found a number 3
Found an even number 4
Found a number 5
Found an even number 6
Found a number 7
Found an even number 8
Found a number 9
4.5 pass Statements
The pass statement does nothing. It can be used when a statement is required syntactically but the program
requires no action. For example:
>>> while True:
... pass # Busy-wait for keyboard interrupt (Ctrl+C)
...
This is commonly used for creating minimal classes:
>>> class MyEmptyClass:
... pass
...
Another place pass can be used is as a place-holder for a function or conditional body when you are working
on new code, allowing you to keep thinking at a more abstract level. The pass is silently ignored:
>>> def initlog(*args):
... pass # Remember to implement this!
...
4.6 Defining Functions
We can create a function that writes the Fibonacci series to an arbitrary boundary:
>>> def fib(n): # write Fibonacci series up to n
... """Print a Fibonacci series up to n."""
... a, b = 0, 1
... while a < n:
... print(a, end=' ')
... a, b = b, a+b
... print()
...
>>> # Now call the function we just defined:
... fib(2000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
The keyword def introduces a function definition. It must be followed by the function name and the
parenthesized list of formal parameters. The statements that form the body of the function start at the next
line, and must be indented.
The first statement of the function body can optionally be a string literal; this string literal is the function’s
documentation string, or docstring. (More about docstrings can be found in the section Documentation
22 Chapter 4. More Control Flow Tools
Python Tutorial, Release 3.7.0
Strings.) There are tools which use docstrings to automatically produce online or printed documentation,
or to let the user interactively browse through code; it’s good practice to include docstrings in code that you
write, so make a habit of it.
The execution of a function introduces a new symbol table used for the local variables of the function. More
precisely, all variable assignments in a function store the value in the local symbol table; whereas variable
references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in
the global symbol table, and finally in the table of built-in names. Thus, global variables cannot be directly
assigned a value within a function (unless named in a global statement), although they may be referenced.
The actual parameters (arguments) to a function call are introduced in the local symbol table of the called
function when it is called; thus, arguments are passed using call by value (where the value is always an object
reference, not the value of the object).1 When a function calls another function, a new local symbol table is
created for that call.
A function definition introduces the function name in the current symbol table. The value of the function
name has a type that is recognized by the interpreter as a user-defined function. This value can be assigned
to another name which can then also be used as a function. This serves as a general renaming mechanism:
>>> fib
<function fib at 10042ed0>
>>> f = fib
>>> f(100)
0 1 1 2 3 5 8 13 21 34 55 89
Coming from other languages, you might object that fib is not a function but a procedure since it doesn’t
return a value. In fact, even functions without a return statement do return a value, albeit a rather boring
one. This value is called None (it’s a built-in name). Writing the value None is normally suppressed by the
interpreter if it would be the only value written. You can see it if you really want to using print():
>>> fib(0)
>>> print(fib(0))
None
It is simple to write a function that returns a list of the numbers of the Fibonacci series, instead of printing
it:
>>> def fib2(n): # return Fibonacci series up to n
... """Return a list containing the Fibonacci series up to n."""
... result = []
... a, b = 0, 1
... while a < n:
... result.append(a) # see below
... a, b = b, a+b
... return result
...
>>> f100 = fib2(100) # call it
>>> f100 # write the result
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
This example, as usual, demonstrates some new Python features:
• The return statement returns with a value from a function. return without an expression argument
returns None. Falling off the end of a function also returns None.
• The statement result.append(a) calls a method of the list object result. A method is a function
that ‘belongs’ to an object and is named obj.methodname, where obj is some object (this may be an
1 Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any
changes the callee makes to it (items inserted into a list).
4.6. Defining Functions 23
Python Tutorial, Release 3.7.0
expression), and methodname is the name of a method that is defined by the object’s type. Different
types define different methods. Methods of different types may have the same name without causing
ambiguity. (It is possible to define your own object types and methods, using classes, see Classes) The
method append() shown in the example is defined for list objects; it adds a new element at the end of
the list. In this example it is equivalent to result = result + [a], but more efficient.
4.7 More on Defining Functions
It is also possible to define functions with a variable number of arguments. There are three forms, which
can be combined.
4.7.1 Default Argument Values
The most useful form is to specify a default value for one or more arguments. This creates a function that
can be called with fewer arguments than it is defined to allow. For example:
def ask_ok(prompt, retries=4, reminder='Please try again!'):
while True:
ok = input(prompt)
if ok in ('y', 'ye', 'yes'):
return True
if ok in ('n', 'no', 'nop', 'nope'):
return False
retries = retries - 1
if retries < 0:
raise ValueError('invalid user response')
print(reminder)
This function can be called in several ways:
• giving only the mandatory argument: ask_ok('Do you really want to quit?')
• giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2)
• or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or
no!')
This example also introduces the in keyword. This tests whether or not a sequence contains a certain value.
The default values are evaluated at the point of function definition in the defining scope, so that
i = 5
def f(arg=i):
print(arg)
i = 6
f()
will print 5.
Important warning: The default value is evaluated only once. This makes a difference when the default is
a mutable object such as a list, dictionary, or instances of most classes. For example, the following function
accumulates the arguments passed to it on subsequent calls:
24 Chapter 4. More Control Flow Tools
Python Tutorial, Release 3.7.0
def f(a, L=[]):
L.append(a)
return L
print(f(1))
print(f(2))
print(f(3))
This will print
[1]
[1, 2]
[1, 2, 3]
If you don’t want the default to be shared between subsequent calls, you can write the function like this
instead:
def f(a, L=None):
if L is None:
L = []
L.append(a)
return L
4.7.2 Keyword Arguments
Functions can also be called using keyword arguments of the form kwarg=value. For instance, the following
function:
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
print("-- This parrot wouldn't", action, end=' ')
print("if you put", voltage, "volts through it.")
print("-- Lovely plumage, the", type)
print("-- It's", state, "!")
accepts one required argument (voltage) and three optional arguments (state, action, and type). This
function can be called in any of the following ways:
parrot(1000) # 1 positional argument
parrot(voltage=1000) # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM') # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000) # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump') # 3 positional arguments
parrot('a thousand', state='pushing up the daisies') # 1 positional, 1 keyword
but all the following calls would be invalid:
parrot() # required argument missing
parrot(voltage=5.0, 'dead') # non-keyword argument after a keyword argument
parrot(110, voltage=220) # duplicate value for the same argument
parrot(actor='John Cleese') # unknown keyword argument
In a function call, keyword arguments must follow positional arguments. All the keyword arguments
passed must match one of the arguments accepted by the function (e.g. actor is not a valid argument
for the parrot function), and their order is not important. This also includes non-optional arguments (e.g.
parrot(voltage=1000) is valid too). No argument may receive a value more than once. Here’s an example
that fails due to this restriction:
4.7. More on Defining Functions 25
Python Tutorial, Release 3.7.0
>>> def function(a):
... pass
...
>>> function(0, a=0)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: function() got multiple values for keyword argument 'a'
When a final formal parameter of the form **name is present, it receives a dictionary (see typesmapping)
containing all keyword arguments except for those corresponding to a formal parameter. This may be
combined with a formal parameter of the form *name (described in the next subsection) which receives
a tuple containing the positional arguments beyond the formal parameter list. (*name must occur before
**name.) For example, if we define a function like this:
def cheeseshop(kind, *arguments, **keywords):
print("-- Do you have any", kind, "?")
print("-- I'm sorry, we're all out of", kind)
for arg in arguments:
print(arg)
print("-" * 40)
for kw in keywords:
print(kw, ":", keywords[kw])
It could be called like this:
cheeseshop("Limburger", "It's very runny, sir.",
"It's really very, VERY runny, sir.",
shopkeeper="Michael Palin",
client="John Cleese",
sketch="Cheese Shop Sketch")
and of course it would print:
-- Do you have any Limburger ?
-- I'm sorry, we're all out of Limburger
It's very runny, sir.
It's really very, VERY runny, sir.
----------------------------------------
shopkeeper : Michael Palin
client : John Cleese
sketch : Cheese Shop Sketch
Note that the order in which the keyword arguments are printed is guaranteed to match the order in which
they were provided in the function call.
4.7.3 Arbitrary Argument Lists
Finally, the least frequently used option is to specify that a function can be called with an arbitrary number
of arguments. These arguments will be wrapped up in a tuple (see Tuples and Sequences). Before the
variable number of arguments, zero or more normal arguments may occur.
def write_multiple_items(file, separator, *args):
file.write(separator.join(args))
Normally, these variadic arguments will be last in the list of formal parameters, because they scoop up
all remaining input arguments that are passed to the function. Any formal parameters which occur after
26 Chapter 4. More Control Flow Tools
Python Tutorial, Release 3.7.0
the *args parameter are ‘keyword-only’ arguments, meaning that they can only be used as keywords rather
than positional arguments.
>>> def concat(*args, sep="/"):
... return sep.join(args)
...
>>> concat("earth", "mars", "venus")
'earth/mars/venus'
>>> concat("earth", "mars", "venus", sep=".")
'earth.mars.venus'
4.7.4 Unpacking Argument Lists
The reverse situation occurs when the arguments are already in a list or tuple but need to be unpacked for
a function call requiring separate positional arguments. For instance, the built-in range() function expects
separate start and stop arguments. If they are not available separately, write the function call with the
*-operator to unpack the arguments out of a list or tuple:
>>> list(range(3, 6)) # normal call with separate arguments
[3, 4, 5]
>>> args = [3, 6]
>>> list(range(*args)) # call with arguments unpacked from a list
[3, 4, 5]
In the same fashion, dictionaries can deliver keyword arguments with the **-operator:
>>> def parrot(voltage, state='a stiff', action='voom'):
... print("-- This parrot wouldn't", action, end=' ')
... print("if you put", voltage, "volts through it.", end=' ')
... print("E's", state, "!")
...
>>> d = {"voltage": "four million", "state": "bleedin' demised", "action": "VOOM"}
>>> parrot(**d)
-- This parrot wouldn't VOOM if you put four million volts through it. E's bleedin' demised !
4.7.5 Lambda Expressions
Small anonymous functions can be created with the lambda keyword. This function returns the sum of its
two arguments: lambda a, b: a+b. Lambda functions can be used wherever function objects are required.
They are syntactically restricted to a single expression. Semantically, they are just syntactic sugar for a
normal function definition. Like nested function definitions, lambda functions can reference variables from
the containing scope:
>>> def make_incrementor(n):
... return lambda x: x + n
...
>>> f = make_incrementor(42)
>>> f(0)
42
>>> f(1)
43
The above example uses a lambda expression to return a function. Another use is to pass a small function
as an argument:
4.7. More on Defining Functions 27
Python Tutorial, Release 3.7.0
>>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]
>>> pairs.sort(key=lambda pair: pair[1])
>>> pairs
[(4, 'four'), (1, 'one'), (3, 'three'), (2, 'two')]
4.7.6 Documentation Strings
Here are some conventions about the content and formatting of documentation strings.
The first line should always be a short, concise summary of the object’s purpose. For brevity, it should
not explicitly state the object’s name or type, since these are available by other means (except if the name
happens to be a verb describing a function’s operation). This line should begin with a capital letter and end
with a period.
If there are more lines in the documentation string, the second line should be blank, visually separating the
summary from the rest of the description. The following lines should be one or more paragraphs describing
the object’s calling conventions, its side effects, etc.
The Python parser does not strip indentation from multi-line string literals in Python, so tools that process
documentation have to strip indentation if desired. This is done using the following convention. The
first non-blank line after the first line of the string determines the amount of indentation for the entire
documentation string. (We can’t use the first line since it is generally adjacent to the string’s opening quotes
so its indentation is not apparent in the string literal.) Whitespace “equivalent” to this indentation is then
stripped from the start of all lines of the string. Lines that are indented less should not occur, but if they
occur all their leading whitespace should be stripped. Equivalence of whitespace should be tested after
expansion of tabs (to 8 spaces, normally).
Here is an example of a multi-line docstring:
>>> def my_function():
... """Do nothing, but document it.
...
... No, really, it doesn't do anything.
... """
... pass
...
>>> print(my_function.__doc__)
Do nothing, but document it.
No, really, it doesn't do anything.
4.7.7 Function Annotations
Function annotations are completely optional metadata information about the types used by user-defined
functions (see PEP 3107 and PEP 484 for more information).
Annotations are stored in the __annotations__ attribute of the function as a dictionary and have no effect
on any other part of the function. Parameter annotations are defined by a colon after the parameter name,
followed by an expression evaluating to the value of the annotation. Return annotations are defined by a
literal ->, followed by an expression, between the parameter list and the colon denoting the end of the def
statement. The following example has a positional argument, a keyword argument, and the return value
annotated:
>>> def f(ham: str, eggs: str = 'eggs') -> str:
... print("Annotations:", f.__annotations__)
(continues on next page)
28 Chapter 4. More Control Flow Tools
Python Tutorial, Release 3.7.0
(continued from previous page)
... print("Arguments:", ham, eggs)
... return ham + ' and ' + eggs
...
>>> f('spam')
Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>}
Arguments: spam eggs
'spam and eggs'
4.8 Intermezzo: Coding Style
Now that you are about to write longer, more complex pieces of Python, it is a good time to talk about
coding style. Most languages can be written (or more concise, formatted) in different styles; some are more
readable than others. Making it easy for others to read your code is always a good idea, and adopting a nice
coding style helps tremendously for that.
For Python, PEP 8 has emerged as the style guide that most projects adhere to; it promotes a very
readable and eye-pleasing coding style. Every Python developer should read it at some point; here are the
most important points extracted for you:
• Use 4-space indentation, and no tabs.
4 spaces are a good compromise between small indentation (allows greater nesting depth) and large
indentation (easier to read). Tabs introduce confusion, and are best left out.
• Wrap lines so that they don’t exceed 79 characters.
This helps users with small displays and makes it possible to have several code files side-by-side on
larger displays.
• Use blank lines to separate functions and classes, and larger blocks of code inside functions.
• When possible, put comments on a line of their own.
• Use docstrings.
• Use spaces around operators and after commas, but not directly inside bracketing constructs: a =
f(1, 2) + g(3, 4).
• Name your classes and functions consistently; the convention is to use CamelCase for classes and
lower_case_with_underscores for functions and methods. Always use self as the name for the first
method argument (see A First Look at Classes for more on classes and methods).
• Don’t use fancy encodings if your code is meant to be used in international environments. Python’s
default, UTF-8, or even plain ASCII work best in any case.
• Likewise, don’t use non-ASCII characters in identifiers if there is only the slightest chance people
speaking a different language will read or maintain the code.
4.8. Intermezzo: Coding Style 29
Python Tutorial, Release 3.7.0
30 Chapter 4. More Control Flow Tools
CHAPTER
FIVE
DATA STRUCTURES
This chapter describes some things you’ve learned about already in more detail, and adds some new things
as well.
5.1 More on Lists
The list data type has some more methods. Here are all of the methods of list objects:
list.append(x)
Add an item to the end of the list. Equivalent to a[len(a):] = [x].
list.extend(iterable)
Extend the list by appending all the items from the iterable. Equivalent to a[len(a):] = iterable.
list.insert(i, x)
Insert an item at a given position. The first argument is the index of the element before which to
insert, so a.insert(0, x) inserts at the front of the list, and a.insert(len(a), x) is equivalent to
a.append(x).
list.remove(x)
Remove the first item from the list whose value is equal to x. It raises a ValueError if there is no such
item.
list.pop([i ])
Remove the item at the given position in the list, and return it. If no index is specified, a.pop() removes
and returns the last item in the list. (The square brackets around the i in the method signature denote
that the parameter is optional, not that you should type square brackets at that position. You will see
this notation frequently in the Python Library Reference.)
list.clear()
Remove all items from the list. Equivalent to del a[:].
list.index(x[, start[, end ]])
Return zero-based index in the list of the first item whose value is equal to x. Raises a ValueError if
there is no such item.
The optional arguments start and end are interpreted as in the slice notation and are used to limit the
search to a particular subsequence of the list. The returned index is computed relative to the beginning
of the full sequence rather than the start argument.
list.count(x)
Return the number of times x appears in the list.
list.sort(key=None, reverse=False)
Sort the items of the list in place (the arguments can be used for sort customization, see sorted() for
their explanation).
31
Python Tutorial, Release 3.7.0
list.reverse()
Reverse the elements of the list in place.
list.copy()
Return a shallow copy of the list. Equivalent to a[:].
An example that uses most of the list methods:
>>> fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
>>> fruits.count('apple')
2
>>> fruits.count('tangerine')
0
>>> fruits.index('banana')
3
>>> fruits.index('banana', 4) # Find next banana starting a position 4
6
>>> fruits.reverse()
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange']
>>> fruits.append('grape')
>>> fruits
['banana', 'apple', 'kiwi', 'banana', 'pear', 'apple', 'orange', 'grape']
>>> fruits.sort()
>>> fruits
['apple', 'apple', 'banana', 'banana', 'grape', 'kiwi', 'orange', 'pear']
>>> fruits.pop()
'pear'
You might have noticed that methods like insert, remove or sort that only modify the list have no return
value printed – they return the default None.
1 This is a design principle for all mutable data structures in
Python.
5.1.1 Using Lists as Stacks
The list methods make it very easy to use a list as a stack, where the last element added is the first element
retrieved (“last-in, first-out”). To add an item to the top of the stack, use append(). To retrieve an item
from the top of the stack, use pop() without an explicit index. For example:
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]
1 Other languages may return the mutated object, which allows method chaining, such as
d->insert("a")->remove("b")->sort();.
32 Chapter 5. Data Structures
Python Tutorial, Release 3.7.0
5.1.2 Using Lists as Queues
It is also possible to use a list as a queue, where the first element added is the first element retrieved (“first-in,
first-out”); however, lists are not efficient for this purpose. While appends and pops from the end of list are
fast, doing inserts or pops from the beginning of a list is slow (because all of the other elements have to be
shifted by one).
To implement a queue, use collections.deque which was designed to have fast appends and pops from
both ends. For example:
>>> from collections import deque
>>> queue = deque(["Eric", "John", "Michael"])
>>> queue.append("Terry") # Terry arrives
>>> queue.append("Graham") # Graham arrives
>>> queue.popleft() # The first to arrive now leaves
'Eric'
>>> queue.popleft() # The second to arrive now leaves
'John'
>>> queue # Remaining queue in order of arrival
deque(['Michael', 'Terry', 'Graham'])
5.1.3 List Comprehensions
List comprehensions provide a concise way to create lists. Common applications are to make new lists where
each element is the result of some operations applied to each member of another sequence or iterable, or to
create a subsequence of those elements that satisfy a certain condition.
For example, assume we want to create a list of squares, like:
>>> squares = []
>>> for x in range(10):
... squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
Note that this creates (or overwrites) a variable named x that still exists after the loop completes. We can
calculate the list of squares without any side effects using:
squares = list(map(lambda x: x**2, range(10)))
or, equivalently:
squares = [x**2 for x in range(10)]
which is more concise and readable.
A list comprehension consists of brackets containing an expression followed by a for clause, then zero or
more for or if clauses. The result will be a new list resulting from evaluating the expression in the context
of the for and if clauses which follow it. For example, this listcomp combines the elements of two lists if
they are not equal:
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
and it’s equivalent to:
5.1. More on Lists 33
Python Tutorial, Release 3.7.0
>>> combs = []
>>> for x in [1,2,3]:
... for y in [3,1,4]:
... if x != y:
... combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
Note how the order of the for and if statements is the same in both these snippets.
If the expression is a tuple (e.g. the (x, y) in the previous example), it must be parenthesized.
>>> vec = [-4, -2, 0, 2, 4]
>>> # create a new list with the values doubled
>>> [x*2 for x in vec]
[-8, -4, 0, 4, 8]
>>> # filter the list to exclude negative numbers
>>> [x for x in vec if x >= 0]
[0, 2, 4]
>>> # apply a function to all the elements
>>> [abs(x) for x in vec]
[4, 2, 0, 2, 4]
>>> # call a method on each element
>>> freshfruit = [' banana', ' loganberry ', 'passion fruit ']
>>> [weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']
>>> # create a list of 2-tuples like (number, square)
>>> [(x, x**2) for x in range(6)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> # the tuple must be parenthesized, otherwise an error is raised
>>> [x, x**2 for x in range(6)]
File "<stdin>", line 1, in <module>
[x, x**2 for x in range(6)]
^
SyntaxError: invalid syntax
>>> # flatten a list using a listcomp with two 'for'
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
List comprehensions can contain complex expressions and nested functions:
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
5.1.4 Nested List Comprehensions
The initial expression in a list comprehension can be any arbitrary expression, including another list comprehension.
Consider the following example of a 3x4 matrix implemented as a list of 3 lists of length 4:
>>> matrix = [
... [1, 2, 3, 4],
... [5, 6, 7, 8],
(continues on next page)
34 Chapter 5. Data Structures
Python Tutorial, Release 3.7.0
(continued from previous page)
... [9, 10, 11, 12],
... ]
The following list comprehension will transpose rows and columns:
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
As we saw in the previous section, the nested listcomp is evaluated in the context of the for that follows it,
so this example is equivalent to:
>>> transposed = []
>>> for i in range(4):
... transposed.append([row[i] for row in matrix])
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
which, in turn, is the same as:
>>> transposed = []
>>> for i in range(4):
... # the following 3 lines implement the nested listcomp
... transposed_row = []
... for row in matrix:
... transposed_row.append(row[i])
... transposed.append(transposed_row)
...
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
In the real world, you should prefer built-in functions to complex flow statements. The zip() function would
do a great job for this use case:
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
See Unpacking Argument Lists for details on the asterisk in this line.
5.2 The del statement
There is a way to remove an item from a list given its index instead of its value: the del statement. This
differs from the pop() method which returns a value. The del statement can also be used to remove slices
from a list or clear the entire list (which we did earlier by assignment of an empty list to the slice). For
example:
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
(continues on next page)
5.2. The del statement 35
Python Tutorial, Release 3.7.0
(continued from previous page)
>>> a
[]
del can also be used to delete entire variables:
>>> del a
Referencing the name a hereafter is an error (at least until another value is assigned to it). We’ll find other
uses for del later.
5.3 Tuples and Sequences
We saw that lists and strings have many common properties, such as indexing and slicing operations. They
are two examples of sequence data types (see typesseq). Since Python is an evolving language, other sequence
data types may be added. There is also another standard sequence data type: the tuple.
A tuple consists of a number of values separated by commas, for instance:
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> # Tuples may be nested:
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> # Tuples are immutable:
... t[0] = 88888
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> # but they can contain mutable objects:
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
As you see, on output tuples are always enclosed in parentheses, so that nested tuples are interpreted
correctly; they may be input with or without surrounding parentheses, although often parentheses are
necessary anyway (if the tuple is part of a larger expression). It is not possible to assign to the individual
items of a tuple, however it is possible to create tuples which contain mutable objects, such as lists.
Though tuples may seem similar to lists, they are often used in different situations and for different purposes.
Tuples are immutable, and usually contain a heterogeneous sequence of elements that are accessed via
unpacking (see later in this section) or indexing (or even by attribute in the case of namedtuples). Lists are
mutable, and their elements are usually homogeneous and are accessed by iterating over the list.
A special problem is the construction of tuples containing 0 or 1 items: the syntax has some extra quirks to
accommodate these. Empty tuples are constructed by an empty pair of parentheses; a tuple with one item is
constructed by following a value with a comma (it is not sufficient to enclose a single value in parentheses).
Ugly, but effective. For example:
>>> empty = ()
>>> singleton = 'hello', # <-- note trailing comma
>>> len(empty)
(continues on next page)
36 Chapter 5. Data Structures
Python Tutorial, Release 3.7.0
(continued from previous page)
0
>>> len(singleton)
1
>>> singleton
('hello',)
The statement t = 12345, 54321, 'hello!' is an example of tuple packing: the values 12345, 54321 and
'hello!' are packed together in a tuple. The reverse operation is also possible:
>>> x, y, z = t
This is called, appropriately enough, sequence unpacking and works for any sequence on the right-hand side.
Sequence unpacking requires that there are as many variables on the left side of the equals sign as there are
elements in the sequence. Note that multiple assignment is really just a combination of tuple packing and
sequence unpacking.
5.4 Sets
Python also includes a data type for sets. A set is an unordered collection with no duplicate elements. Basic
uses include membership testing and eliminating duplicate entries. Set objects also support mathematical
operations like union, intersection, difference, and symmetric difference.
Curly braces or the set() function can be used to create sets. Note: to create an empty set you have to use
set(), not {}; the latter creates an empty dictionary, a data structure that we discuss in the next section.
Here is a brief demonstration:
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket) # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket # fast membership testing
True
>>> 'crabgrass' in basket
False
>>> # Demonstrate set operations on unique letters from two words
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a # unique letters in a
{'a', 'r', 'b', 'c', 'd'}
>>> a - b # letters in a but not in b
{'r', 'd', 'b'}
>>> a | b # letters in a or b or both
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b # letters in both a and b
{'a', 'c'}
>>> a ^ b # letters in a or b but not both
{'r', 'd', 'b', 'm', 'z', 'l'}
Similarly to list comprehensions, set comprehensions are also supported:
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
5.4. Sets 37
Python Tutorial, Release 3.7.0
5.5 Dictionaries
Another useful data type built into Python is the dictionary (see typesmapping). Dictionaries are sometimes
found in other languages as “associative memories” or “associative arrays”. Unlike sequences, which are
indexed by a range of numbers, dictionaries are indexed by keys, which can be any immutable type; strings
and numbers can always be keys. Tuples can be used as keys if they contain only strings, numbers, or tuples;
if a tuple contains any mutable object either directly or indirectly, it cannot be used as a key. You can’t use
lists as keys, since lists can be modified in place using index assignments, slice assignments, or methods like
append() and extend().
It is best to think of a dictionary as a set of key: value pairs, with the requirement that the keys are unique
(within one dictionary). A pair of braces creates an empty dictionary: {}. Placing a comma-separated
list of key:value pairs within the braces adds initial key:value pairs to the dictionary; this is also the way
dictionaries are written on output.
The main operations on a dictionary are storing a value with some key and extracting the value given the
key. It is also possible to delete a key:value pair with del. If you store using a key that is already in use,
the old value associated with that key is forgotten. It is an error to extract a value using a non-existent key.
Performing list(d) on a dictionary returns a list of all the keys used in the dictionary, in insertion order
(if you want it sorted, just use sorted(d) instead). To check whether a single key is in the dictionary, use
the in keyword.
Here is a small example using a dictionary:
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel['guido'] = 4127
>>> tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
>>> list(tel)
['jack', 'guido', 'irv']
>>> sorted(tel)
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
The dict() constructor builds dictionaries directly from sequences of key-value pairs:
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
In addition, dict comprehensions can be used to create dictionaries from arbitrary key and value expressions:
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
When the keys are simple strings, it is sometimes easier to specify pairs using keyword arguments:
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape': 4139, 'guido': 4127, 'jack': 4098}
38 Chapter 5. Data Structures
Python Tutorial, Release 3.7.0
5.6 Looping Techniques
When looping through dictionaries, the key and corresponding value can be retrieved at the same time using
the items() method.
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
... print(k, v)
...
gallahad the pure
robin the brave
When looping through a sequence, the position index and corresponding value can be retrieved at the same
time using the enumerate() function.
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
... print(i, v)
...
0 tic
1 tac
2 toe
To loop over two or more sequences at the same time, the entries can be paired with the zip() function.
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
... print('What is your {0}? It is {1}.'.format(q, a))
...
What is your name? It is lancelot.
What is your quest? It is the holy grail.
What is your favorite color? It is blue.
To loop over a sequence in reverse, first specify the sequence in a forward direction and then call the
reversed() function.
>>> for i in reversed(range(1, 10, 2)):
... print(i)
...
9
7
5
3
1
To loop over a sequence in sorted order, use the sorted() function which returns a new sorted list while
leaving the source unaltered.
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):
... print(f)
...
apple
banana
orange
pear
5.6. Looping Techniques 39
Python Tutorial, Release 3.7.0
It is sometimes tempting to change a list while you are looping over it; however, it is often simpler and safer
to create a new list instead.
>>> import math
>>> raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
>>> filtered_data = []
>>> for value in raw_data:
... if not math.isnan(value):
... filtered_data.append(value)
...
>>> filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
5.7 More on Conditions
The conditions used in while and if statements can contain any operators, not just comparisons.
The comparison operators in and not in check whether a value occurs (does not occur) in a sequence. The
operators is and is not compare whether two objects are really the same object; this only matters for
mutable objects like lists. All comparison operators have the same priority, which is lower than that of all
numerical operators.
Comparisons can be chained. For example, a < b == c tests whether a is less than b and moreover b equals
c.
Comparisons may be combined using the Boolean operators and and or, and the outcome of a comparison
(or of any other Boolean expression) may be negated with not. These have lower priorities than comparison
operators; between them, not has the highest priority and or the lowest, so that A and not B or C is
equivalent to (A and (not B)) or C. As always, parentheses can be used to express the desired composition.
The Boolean operators and and or are so-called short-circuit operators: their arguments are evaluated from
left to right, and evaluation stops as soon as the outcome is determined. For example, if A and C are true
but B is false, A and B and C does not evaluate the expression C. When used as a general value and not as
a Boolean, the return value of a short-circuit operator is the last evaluated argument.
It is possible to assign the result of a comparison or other Boolean expression to a variable. For example,
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>> non_null
'Trondheim'
Note that in Python, unlike C, assignment cannot occur inside expressions. C programmers may grumble
about this, but it avoids a common class of problems encountered in C programs: typing = in an expression
when == was intended.
5.8 Comparing Sequences and Other Types
Sequence objects may be compared to other objects with the same sequence type. The comparison uses lexicographical ordering: first the first two items are compared, and if they differ this determines the outcome
of the comparison; if they are equal, the next two items are compared, and so on, until either sequence is
exhausted. If two items to be compared are themselves sequences of the same type, the lexicographical comparison is carried out recursively. If all items of two sequences compare equal, the sequences are considered
equal. If one sequence is an initial sub-sequence of the other, the shorter sequence is the smaller (lesser)
40 Chapter 5. Data Structures
Python Tutorial, Release 3.7.0
one. Lexicographical ordering for strings uses the Unicode code point number to order individual characters.
Some examples of comparisons between sequences of the same type:
(1, 2, 3) < (1, 2, 4)
[1, 2, 3] < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4) < (1, 2, 4)
(1, 2) < (1, 2, -1)
(1, 2, 3) == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)
Note that comparing objects of different types with < or > is legal provided that the objects have appropriate
comparison methods. For example, mixed numeric types are compared according to their numeric value,
so 0 equals 0.0, etc. Otherwise, rather than providing an arbitrary ordering, the interpreter will raise a
TypeError exception.
5.8. Comparing Sequences and Other Types 41
Python Tutorial, Release 3.7.0
42 Chapter 5. Data Structures
CHAPTER
SIX
MODULES
If you quit from the Python interpreter and enter it again, the definitions you have made (functions and
variables) are lost. Therefore, if you want to write a somewhat longer program, you are better off using a
text editor to prepare the input for the interpreter and running it with that file as input instead. This is
known as creating a script. As your program gets longer, you may want to split it into several files for easier
maintenance. You may also want to use a handy function that you’ve written in several programs without
copying its definition into each program.
To support this, Python has a way to put definitions in a file and use them in a script or in an interactive
instance of the interpreter. Such a file is called a module; definitions from a module can be imported into
other modules or into the main module (the collection of variables that you have access to in a script executed
at the top level and in calculator mode).
A module is a file containing Python definitions and statements. The file name is the module name with
the suffix .py appended. Within a module, the module’s name (as a string) is available as the value of the
global variable __name__. For instance, use your favorite text editor to create a file called fibo.py in the
current directory with the following contents:
# Fibonacci numbers module
def fib(n): # write Fibonacci series up to n
a, b = 0, 1
while a < n:
print(a, end=' ')
a, b = b, a+b
print()
def fib2(n): # return Fibonacci series up to n
result = []
a, b = 0, 1
while a < n:
result.append(a)
a, b = b, a+b
return result
Now enter the Python interpreter and import this module with the following command:
>>> import fibo
This does not enter the names of the functions defined in fibo directly in the current symbol table; it only
enters the module name fibo there. Using the module name you can access the functions:
>>> fibo.fib(1000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
(continues on next page)
43
Python Tutorial, Release 3.7.0
(continued from previous page)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
If you intend to use a function often you can assign it to a local name:
>>> fib = fibo.fib
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
6.1 More on Modules
A module can contain executable statements as well as function definitions. These statements are intended
to initialize the module. They are executed only the first time the module name is encountered in an import
statement.1
(They are also run if the file is executed as a script.)
Each module has its own private symbol table, which is used as the global symbol table by all functions
defined in the module. Thus, the author of a module can use global variables in the module without
worrying about accidental clashes with a user’s global variables. On the other hand, if you know what you
are doing you can touch a module’s global variables with the same notation used to refer to its functions,
modname.itemname.
Modules can import other modules. It is customary but not required to place all import statements at the
beginning of a module (or script, for that matter). The imported module names are placed in the importing
module’s global symbol table.
There is a variant of the import statement that imports names from a module directly into the importing
module’s symbol table. For example:
>>> from fibo import fib, fib2
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
This does not introduce the module name from which the imports are taken in the local symbol table (so in
the example, fibo is not defined).
There is even a variant to import all names that a module defines:
>>> from fibo import *
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
This imports all names except those beginning with an underscore (_). In most cases Python programmers
do not use this facility since it introduces an unknown set of names into the interpreter, possibly hiding some
things you have already defined.
Note that in general the practice of importing * from a module or package is frowned upon, since it often
causes poorly readable code. However, it is okay to use it to save typing in interactive sessions.
If the module name is followed by as, then the name following as is bound directly to the imported module.
>>> import fibo as fib
>>> fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
1
In fact function definitions are also ‘statements’ that are ‘executed’; the execution of a module-level function definition
enters the function name in the module’s global symbol table.
44 Chapter 6. Modules
Python Tutorial, Release 3.7.0
This is effectively importing the module in the same way that import fibo will do, with the only difference
of it being available as fib.
It can also be used when utilising from with similar effects:
>>> from fibo import fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
Note: For efficiency reasons, each module is only imported once per interpreter session. Therefore, if
you change your modules, you must restart the interpreter – or, if it’s just one module you want to test
interactively, use importlib.reload(), e.g. import importlib; importlib.reload(modulename).
6.1.1 Executing modules as scripts
When you run a Python module with
python fibo.py <arguments>
the code in the module will be executed, just as if you imported it, but with the __name__ set to "__main__".
That means that by adding this code at the end of your module:
if __name__ == "__main__":
import sys
fib(int(sys.argv[1]))
you can make the file usable as a script as well as an importable module, because the code that parses the
command line only runs if the module is executed as the “main” file:
$ python fibo.py 50
0 1 1 2 3 5 8 13 21 34
If the module is imported, the code is not run:
>>> import fibo
>>>
This is often used either to provide a convenient user interface to a module, or for testing purposes (running
the module as a script executes a test suite).
6.1.2 The Module Search Path
When a module named spam is imported, the interpreter first searches for a built-in module with that name.
If not found, it then searches for a file named spam.py in a list of directories given by the variable sys.path.
sys.path is initialized from these locations:
• The directory containing the input script (or the current directory when no file is specified).
• PYTHONPATH (a list of directory names, with the same syntax as the shell variable PATH).
• The installation-dependent default.
Note: On file systems which support symlinks, the directory containing the input script is calculated after
the symlink is followed. In other words the directory containing the symlink is not added to the module
6.1. More on Modules 45
Python Tutorial, Release 3.7.0
search path.
After initialization, Python programs can modify sys.path. The directory containing the script being run
is placed at the beginning of the search path, ahead of the standard library path. This means that scripts in
that directory will be loaded instead of modules of the same name in the library directory. This is an error
unless the replacement is intended. See section Standard Modules for more information.
6.1.3 “Compiled” Python files
To speed up loading modules, Python caches the compiled version of each module in the __pycache__
directory under the name module.version.pyc, where the version encodes the format of the compiled file;
it generally contains the Python version number. For example, in CPython release 3.3 the compiled version of
spam.py would be cached as __pycache__/spam.cpython-33.pyc. This naming convention allows compiled
modules from different releases and different versions of Python to coexist.
Python checks the modification date of the source against the compiled version to see if it’s out of date
and needs to be recompiled. This is a completely automatic process. Also, the compiled modules are
platform-independent, so the same library can be shared among systems with different architectures.
Python does not check the cache in two circumstances. First, it always recompiles and does not store the
result for the module that’s loaded directly from the command line. Second, it does not check the cache if
there is no source module. To support a non-source (compiled only) distribution, the compiled module must
be in the source directory, and there must not be a source module.
Some tips for experts:
• You can use the -O or -OO switches on the Python command to reduce the size of a compiled module.
The -O switch removes assert statements, the -OO switch removes both assert statements and __doc__
strings. Since some programs may rely on having these available, you should only use this option if
you know what you’re doing. “Optimized” modules have an opt- tag and are usually smaller. Future
releases may change the effects of optimization.
• A program doesn’t run any faster when it is read from a .pyc file than when it is read from a .py file;
the only thing that’s faster about .pyc files is the speed with which they are loaded.
• The module compileall can create .pyc files for all modules in a directory.
• There is more detail on this process, including a flow chart of the decisions, in PEP 3147.
6.2 Standard Modules
Python comes with a library of standard modules, described in a separate document, the Python Library
Reference (“Library Reference” hereafter). Some modules are built into the interpreter; these provide access
to operations that are not part of the core of the language but are nevertheless built in, either for efficiency
or to provide access to operating system primitives such as system calls. The set of such modules is a
configuration option which also depends on the underlying platform. For example, the winreg module is
only provided on Windows systems. One particular module deserves some attention: sys, which is built
into every Python interpreter. The variables sys.ps1 and sys.ps2 define the strings used as primary and
secondary prompts:
>>> import sys
>>> sys.ps1
'>>> '
>>> sys.ps2
'... '
(continues on next page)
46 Chapter 6. Modules
Python Tutorial, Release 3.7.0
(continued from previous page)
>>> sys.ps1 = 'C> '
C> print('Yuck!')
Yuck!
C>
These two variables are only defined if the interpreter is in interactive mode.
The variable sys.path is a list of strings that determines the interpreter’s search path for modules. It is
initialized to a default path taken from the environment variable PYTHONPATH, or from a built-in default if
PYTHONPATH is not set. You can modify it using standard list operations:
>>> import sys
>>> sys.path.append('/ufs/guido/lib/python')
6.3 The dir() Function
The built-in function dir() is used to find out which names a module defines. It returns a sorted list of
strings:
>>> import fibo, sys
>>> dir(fibo)
['__name__', 'fib', 'fib2']
>>> dir(sys)
['__displayhook__', '__doc__', '__excepthook__', '__loader__', '__name__',
'__package__', '__stderr__', '__stdin__', '__stdout__',
'_clear_type_cache', '_current_frames', '_debugmallocstats', '_getframe',
'_home', '_mercurial', '_xoptions', 'abiflags', 'api_version', 'argv',
'base_exec_prefix', 'base_prefix', 'builtin_module_names', 'byteorder',
'call_tracing', 'callstats', 'copyright', 'displayhook',
'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix',
'executable', 'exit', 'flags', 'float_info', 'float_repr_style',
'getcheckinterval', 'getdefaultencoding', 'getdlopenflags',
'getfilesystemencoding', 'getobjects', 'getprofile', 'getrecursionlimit',
'getrefcount', 'getsizeof', 'getswitchinterval', 'gettotalrefcount',
'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',
'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',
'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1',
'setcheckinterval', 'setdlopenflags', 'setprofile', 'setrecursionlimit',
'setswitchinterval', 'settrace', 'stderr', 'stdin', 'stdout',
'thread_info', 'version', 'version_info', 'warnoptions']
Without arguments, dir() lists the names you have defined currently:
>>> a = [1, 2, 3, 4, 5]
>>> import fibo
>>> fib = fibo.fib
>>> dir()
['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']
Note that it lists all types of names: variables, modules, functions, etc.
dir() does not list the names of built-in functions and variables. If you want a list of those, they are defined
in the standard module builtins:
6.3. The dir() Function 47
Python Tutorial, Release 3.7.0
>>> import builtins
>>> dir(builtins)
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',
'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',
'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',
'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',
'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',
'FileExistsError', 'FileNotFoundError', 'FloatingPointError',
'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',
'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',
'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',
'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',
'NotImplementedError', 'OSError', 'OverflowError',
'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',
'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',
'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',
'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',
'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',
'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',
'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',
'__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',
'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',
'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',
'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',
'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',
'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',
'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',
'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',
'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',
'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',
'zip']
6.4 Packages
Packages are a way of structuring Python’s module namespace by using “dotted module names”. For example,
the module name A.B designates a submodule named B in a package named A. Just like the use of modules
saves the authors of different modules from having to worry about each other’s global variable names, the
use of dotted module names saves the authors of multi-module packages like NumPy or Pillow from having
to worry about each other’s module names.
Suppose you want to design a collection of modules (a “package”) for the uniform handling of sound files and
sound data. There are many different sound file formats (usually recognized by their extension, for example:
.wav, .aiff, .au), so you may need to create and maintain a growing collection of modules for the conversion
between the various file formats. There are also many different operations you might want to perform on
sound data (such as mixing, adding echo, applying an equalizer function, creating an artificial stereo effect),
so in addition you will be writing a never-ending stream of modules to perform these operations. Here’s a
possible structure for your package (expressed in terms of a hierarchical filesystem):
sound/ Top-level package
__init__.py Initialize the sound package
formats/ Subpackage for file format conversions
__init__.py
wavread.py
wavwrite.py
(continues on next page)
48 Chapter 6. Modules
Python Tutorial, Release 3.7.0
(continued from previous page)
aiffread.py
aiffwrite.py
auread.py
auwrite.py
...
effects/ Subpackage for sound effects
__init__.py
echo.py
surround.py
reverse.py
...
filters/ Subpackage for filters
__init__.py
equalizer.py
vocoder.py
karaoke.py
...
When importing the package, Python searches through the directories on sys.path looking for the package
subdirectory.
The __init__.py files are required to make Python treat the directories as containing packages; this is done
to prevent directories with a common name, such as string, from unintentionally hiding valid modules that
occur later on the module search path. In the simplest case, __init__.py can just be an empty file, but it
can also execute initialization code for the package or set the __all__ variable, described later.
Users of the package can import individual modules from the package, for example:
import sound.effects.echo
This loads the submodule sound.effects.echo. It must be referenced with its full name.
sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
An alternative way of importing the submodule is:
from sound.effects import echo
This also loads the submodule echo, and makes it available without its package prefix, so it can be used as
follows:
echo.echofilter(input, output, delay=0.7, atten=4)
Yet another variation is to import the desired function or variable directly:
from sound.effects.echo import echofilter
Again, this loads the submodule echo, but this makes its function echofilter() directly available:
echofilter(input, output, delay=0.7, atten=4)
Note that when using from package import item, the item can be either a submodule (or subpackage)
of the package, or some other name defined in the package, like a function, class or variable. The import
statement first tests whether the item is defined in the package; if not, it assumes it is a module and attempts
to load it. If it fails to find it, an ImportError exception is raised.
Contrarily, when using syntax like import item.subitem.subsubitem, each item except for the last must
be a package; the last item can be a module or a package but can’t be a class or function or variable defined
6.4. Packages 49
Python Tutorial, Release 3.7.0
in the previous item.
6.4.1 Importing * From a Package
Now what happens when the user writes from sound.effects import *? Ideally, one would hope that this
somehow goes out to the filesystem, finds which submodules are present in the package, and imports them
all. This could take a long time and importing sub-modules might have unwanted side-effects that should
only happen when the sub-module is explicitly imported.
The only solution is for the package author to provide an explicit index of the package. The import statement
uses the following convention: if a package’s __init__.py code defines a list named __all__, it is taken to
be the list of module names that should be imported when from package import * is encountered. It is up
to the package author to keep this list up-to-date when a new version of the package is released. Package
authors may also decide not to support it, if they don’t see a use for importing * from their package. For
example, the file sound/effects/__init__.py could contain the following code:
__all__ = ["echo", "surround", "reverse"]
This would mean that from sound.effects import * would import the three named submodules of the
sound package.
If __all__ is not defined, the statement from sound.effects import * does not import all submodules from
the package sound.effects into the current namespace; it only ensures that the package sound.effects
has been imported (possibly running any initialization code in __init__.py) and then imports whatever
names are defined in the package. This includes any names defined (and submodules explicitly loaded) by
__init__.py. It also includes any submodules of the package that were explicitly loaded by previous import
statements. Consider this code:
import sound.effects.echo
import sound.effects.surround
from sound.effects import *
In this example, the echo and surround modules are imported in the current namespace because they are
defined in the sound.effects package when the from...import statement is executed. (This also works
when __all__ is defined.)
Although certain modules are designed to export only names that follow certain patterns when you use
import *, it is still considered bad practice in production code.
Remember, there is nothing wrong with using from Package import specific_submodule! In fact, this is
the recommended notation unless the importing module needs to use submodules with the same name from
different packages.
6.4.2 Intra-package References
When packages are structured into subpackages (as with the sound package in the example), you can use
absolute imports to refer to submodules of siblings packages. For example, if the module sound.filters.
vocoder needs to use the echo module in the sound.effects package, it can use from sound.effects
import echo.
You can also write relative imports, with the from module import name form of import statement. These
imports use leading dots to indicate the current and parent packages involved in the relative import. From
the surround module for example, you might use:
50 Chapter 6. Modules
Python Tutorial, Release 3.7.0
from . import echo
from .. import formats
from ..filters import equalizer
Note that relative imports are based on the name of the current module. Since the name of the main module
is always "__main__", modules intended for use as the main module of a Python application must always
use absolute imports.
6.4.3 Packages in Multiple Directories
Packages support one more special attribute, __path__. This is initialized to be a list containing the name
of the directory holding the package’s __init__.py before the code in that file is executed. This variable
can be modified; doing so affects future searches for modules and subpackages contained in the package.
While this feature is not often needed, it can be used to extend the set of modules found in a package.
6.4. Packages 51
Python Tutorial, Release 3.7.0
52 Chapter 6. Modules
CHAPTER
SEVEN
INPUT AND OUTPUT
There are several ways to present the output of a program; data can be printed in a human-readable form,
or written to a file for future use. This chapter will discuss some of the possibilities.
7.1 Fancier Output Formatting
So far we’ve encountered two ways of writing values: expression statements and the print() function.
(A third way is using the write() method of file objects; the standard output file can be referenced as
sys.stdout. See the Library Reference for more information on this.)
Often you’ll want more control over the formatting of your output than simply printing space-separated
values. There are several ways to format output.
• To use formatted string literals, begin a string with f or F before the opening quotation mark or triple
quotation mark. Inside this string, you can write a Python expression between { and } characters that
can refer to variables or literal values.
>>> year = 2016 ; event = 'Referendum'
>>> f'Results of the {year} {event}'
'Results of the 2016 Referendum'
• The str.format() method of strings requires more manual effort. You’ll still use { and } to mark
where a variable will be substituted and can provide detailed formatting directives, but you’ll also need
to provide the information to be formatted.
>>> yes_votes = 42_572_654 ; no_votes = 43_132_495
>>> percentage = yes_votes/(yes_votes+no_votes)
>>> '{:-9} YES votes {:2.2%}'.format(yes_votes, percentage)
' 42572654 YES votes 49.67%'
• Finally, you can do all the string handling yourself by using string slicing and concatenation operations
to create any layout you can imagine. The string type has some methods that perform useful operations
for padding strings to a given column width.
When you don’t need fancy output but just want a quick display of some variables for debugging purposes,
you can convert any value to a string with the repr() or str() functions.
The str() function is meant to return representations of values which are fairly human-readable, while
repr() is meant to generate representations which can be read by the interpreter (or will force a SyntaxError
if there is no equivalent syntax). For objects which don’t have a particular representation for human consumption, str() will return the same value as repr(). Many values, such as numbers or structures like lists
and dictionaries, have the same representation using either function. Strings, in particular, have two distinct
representations.
Some examples:
53
Python Tutorial, Release 3.7.0
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(1/7)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
>>> print(s)
The value of x is 32.5, and y is 40000...
>>> # The repr() of a string adds string quotes and backslashes:
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hellos)
'hello, world\n'
>>> # The argument to repr() may be any Python object:
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"
The string module contains a Template class that offers yet another way to substitute values into strings,
using placeholders like $x and replacing them with values from a dictionary, but offers much less control of
the formatting.
7.1.1 Formatted String Literals
Formatted string literals (also called f-strings for short) let you include the value of Python expressions inside
a string by prefixing the string with f or F and writing expressions as {expression}.
An optional format specifier can follow the expression. This allows greater control over how the value is
formatted. The following example rounds pi to three places after the decimal:
>>> import math
>>> print(f'The value of pi is approximately {math.pi:.3f}.')
Passing an integer after the ':' will cause that field to be a minimum number of characters wide. This is
useful for making columns line up.
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
>>> for name, phone in table.items():
... print(f'{name:10} ==> {phone:10d}')
...
Sjoerd ==> 4127
Jack ==> 4098
Dcab ==> 7678
Other modifiers can be used to convert the value before it is formatted. '!a' applies ascii(), '!s' applies
str(), and '!r' applies repr():
>>> animals = 'eels'
>>> print(f'My hovercraft is full of {animals}.')
My hovercraft is full of eels.
>>> print('My hovercraft is full of {animals !r}.')
My hovercraft is full of 'eels'.
For a reference on these format specifications, see the reference guide for the formatspec.
54 Chapter 7. Input and Output
Python Tutorial, Release 3.7.0
7.1.2 The String format() Method
Basic usage of the str.format() method looks like this:
>>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
We are the knights who say "Ni!"
The brackets and characters within them (called format fields) are replaced with the objects passed into the
str.format() method. A number in the brackets can be used to refer to the position of the object passed
into the str.format() method.
>>> print('{0} and {1}'.format('spam', 'eggs'))
spam and eggs
>>> print('{1} and {0}'.format('spam', 'eggs'))
eggs and spam
If keyword arguments are used in the str.format() method, their values are referred to by using the name
of the argument.
>>> print('This {food} is {adjective}.'.format(
... food='spam', adjective='absolutely horrible'))
This spam is absolutely horrible.
Positional and keyword arguments can be arbitrarily combined:
>>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',
other='Georg'))
The story of Bill, Manfred, and Georg.
If you have a really long format string that you don’t want to split up, it would be nice if you could reference
the variables to be formatted by name instead of by position. This can be done by simply passing the dict
and using square brackets '[]' to access the keys
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
... 'Dcab: {0[Dcab]:d}'.format(table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
This could also be done by passing the table as keyword arguments with the ‘**’ notation.
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
This is particularly useful in combination with the built-in function vars(), which returns a dictionary
containing all local variables.
As an example, the following lines produce a tidily-aligned set of columns giving integers and their squares
and cubes:
>>> for x in range(1, 11):
... print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
...
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
(continues on next page)
7.1. Fancier Output Formatting 55
Python Tutorial, Release 3.7.0
(continued from previous page)
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
For a complete overview of string formatting with str.format(), see formatstrings.
7.1.3 Manual String Formatting
Here’s the same table of squares and cubes, formatted manually:
>>> for x in range(1, 11):
... print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
... # Note use of 'end' on previous line
... print(repr(x*x*x).rjust(4))
...
1 1 1
2 4 8
3 9 27
4 16 64
5 25 125
6 36 216
7 49 343
8 64 512
9 81 729
10 100 1000
(Note that the one space between each column was added by the way print() works: it always adds spaces
between its arguments.)
The str.rjust() method of string objects right-justifies a string in a field of a given width by padding it
with spaces on the left. There are similar methods str.ljust() and str.center(). These methods do not
write anything, they just return a new string. If the input string is too long, they don’t truncate it, but
return it unchanged; this will mess up your column lay-out but that’s usually better than the alternative,
which would be lying about a value. (If you really want truncation you can always add a slice operation, as
in x.ljust(n)[:n].)
There is another method, str.zfill(), which pads a numeric string on the left with zeros. It understands
about plus and minus signs:
>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zfill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359'
7.1.4 Old string formatting
The % operator can also be used for string formatting. It interprets the left argument much like a sprintf()-
style format string to be applied to the right argument, and returns the string resulting from this formatting
operation. For example:
56 Chapter 7. Input and Output
Python Tutorial, Release 3.7.0
>>> import math
>>> print('The value of pi is approximately %5.3f.' % math.pi)
The value of pi is approximately 3.142.
More information can be found in the old-string-formatting section.
7.2 Reading and Writing Files
open() returns a file object, and is most commonly used with two arguments: open(filename, mode).
>>> f = open('workfile', 'w')
The first argument is a string containing the filename. The second argument is another string containing a
few characters describing the way in which the file will be used. mode can be 'r' when the file will only
be read, 'w' for only writing (an existing file with the same name will be erased), and 'a' opens the file
for appending; any data written to the file is automatically added to the end. 'r+' opens the file for both
reading and writing. The mode argument is optional; 'r' will be assumed if it’s omitted.
Normally, files are opened in text mode, that means, you read and write strings from and to the file, which are
encoded in a specific encoding. If encoding is not specified, the default is platform dependent (see open()).
'b' appended to the mode opens the file in binary mode: now the data is read and written in the form of
bytes objects. This mode should be used for all files that don’t contain text.
In text mode, the default when reading is to convert platform-specific line endings (\n on Unix, \r\n on
Windows) to just \n. When writing in text mode, the default is to convert occurrences of \n back to
platform-specific line endings. This behind-the-scenes modification to file data is fine for text files, but will
corrupt binary data like that in JPEG or EXE files. Be very careful to use binary mode when reading and
writing such files.
It is good practice to use the with keyword when dealing with file objects. The advantage is that the file is
properly closed after its suite finishes, even if an exception is raised at some point. Using with is also much
shorter than writing equivalent try-finally blocks:
>>> with open('workfile') as f:
... read_data = f.read()
>>> f.closed
True
If you’re not using the with keyword, then you should call f.close() to close the file and immediately
free up any system resources used by it. If you don’t explicitly close a file, Python’s garbage collector will
eventually destroy the object and close the open file for you, but the file may stay open for a while. Another
risk is that different Python implementations will do this clean-up at different times.
After a file object is closed, either by a with statement or by calling f.close(), attempts to use the file
object will automatically fail.
>>> f.close()
>>> f.read()
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: I/O operation on closed file.
7.2.1 Methods of File Objects
The rest of the examples in this section will assume that a file object called f has already been created.
7.2. Reading and Writing Files 57
Python Tutorial, Release 3.7.0
To read a file’s contents, call f.read(size), which reads some quantity of data and returns it as a string (in
text mode) or bytes object (in binary mode). size is an optional numeric argument. When size is omitted
or negative, the entire contents of the file will be read and returned; it’s your problem if the file is twice as
large as your machine’s memory. Otherwise, at most size bytes are read and returned. If the end of the file
has been reached, f.read() will return an empty string ('').
>>> f.read()
'This is the entire file.\n'
>>> f.read()
''
f.readline() reads a single line from the file; a newline character (\n) is left at the end of the string, and
is only omitted on the last line of the file if the file doesn’t end in a newline. This makes the return value
unambiguous; if f.readline() returns an empty string, the end of the file has been reached, while a blank
line is represented by '\n', a string containing only a single newline.
>>> f.readline()
'This is the first line of the file.\n'
>>> f.readline()
'Second line of the file\n'
>>> f.readline()
''
For reading lines from a file, you can loop over the file object. This is memory efficient, fast, and leads to
simple code:
>>> for line in f:
... print(line, end='')
...
This is the first line of the file.
Second line of the file
If you want to read all the lines of a file in a list you can also use list(f) or f.readlines().
f.write(string) writes the contents of string to the file, returning the number of characters written.
>>> f.write('This is a test\n')
15
Other types of objects need to be converted – either to a string (in text mode) or a bytes object (in binary
mode) – before writing them:
>>> value = ('the answer', 42)
>>> s = str(value) # convert the tuple to string
>>> f.write(s)
18
f.tell() returns an integer giving the file object’s current position in the file represented as number of bytes
from the beginning of the file when in binary mode and an opaque number when in text mode.
To change the file object’s position, use f.seek(offset, from_what). The position is computed from
adding offset to a reference point; the reference point is selected by the from_what argument. A from_what
value of 0 measures from the beginning of the file, 1 uses the current file position, and 2 uses the end of the
file as the reference point. from_what can be omitted and defaults to 0, using the beginning of the file as
the reference point.
>>> f = open('workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
(continues on next page)
58 Chapter 7. Input and Output
Python Tutorial, Release 3.7.0
(continued from previous page)
16
>>> f.seek(5) # Go to the 6th byte in the file
5
>>> f.read(1)
b'5'
>>> f.seek(-3, 2) # Go to the 3rd byte before the end
13
>>> f.read(1)
b'd'
In text files (those opened without a b in the mode string), only seeks relative to the beginning of the file are
allowed (the exception being seeking to the very file end with seek(0, 2)) and the only valid offset values
are those returned from the f.tell(), or zero. Any other offset value produces undefined behaviour.
File objects have some additional methods, such as isatty() and truncate() which are less frequently
used; consult the Library Reference for a complete guide to file objects.
7.2.2 Saving structured data with json
Strings can easily be written to and read from a file. Numbers take a bit more effort, since the read()
method only returns strings, which will have to be passed to a function like int(), which takes a string like
'123' and returns its numeric value 123. When you want to save more complex data types like nested lists
and dictionaries, parsing and serializing by hand becomes complicated.
Rather than having users constantly writing and debugging code to save complicated data types to files,
Python allows you to use the popular data interchange format called JSON (JavaScript Object Notation).
The standard module called json can take Python data hierarchies, and convert them to string representations; this process is called serializing. Reconstructing the data from the string representation is called
deserializing. Between serializing and deserializing, the string representing the object may have been stored
in a file or data, or sent over a network connection to some distant machine.
Note: The JSON format is commonly used by modern applications to allow for data exchange. Many
programmers are already familiar with it, which makes it a good choice for interoperability.
If you have an object x, you can view its JSON string representation with a simple line of code:
>>> import json
>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'
Another variant of the dumps() function, called dump(), simply serializes the object to a text file. So if f is
a text file object opened for writing, we can do this:
json.dump(x, f)
To decode the object again, if f is a text file object which has been opened for reading:
x = json.load(f)
This simple serialization technique can handle lists and dictionaries, but serializing arbitrary class instances
in JSON requires a bit of extra effort. The reference for the json module contains an explanation of this.
See also:
pickle - the pickle module
7.2. Reading and Writing Files 59
Python Tutorial, Release 3.7.0
Contrary to JSON, pickle is a protocol which allows the serialization of arbitrarily complex Python objects.
As such, it is specific to Python and cannot be used to communicate with applications written in other
languages. It is also insecure by default: deserializing pickle data coming from an untrusted source can
execute arbitrary code, if the data was crafted by a skilled attacker.
60 Chapter 7. Input and Output
CHAPTER
EIGHT
ERRORS AND EXCEPTIONS
Until now error messages haven’t been more than mentioned, but if you have tried out the examples you have
probably seen some. There are (at least) two distinguishable kinds of errors: syntax errors and exceptions.
8.1 Syntax Errors
Syntax errors, also known as parsing errors, are perhaps the most common kind of complaint you get while
you are still learning Python:
>>> while True print('Hello world')
File "<stdin>", line 1
while True print('Hello world')
^
SyntaxError: invalid syntax
The parser repeats the offending line and displays a little ‘arrow’ pointing at the earliest point in the line
where the error was detected. The error is caused by (or at least detected at) the token preceding the arrow:
in the example, the error is detected at the function print(), since a colon (':') is missing before it. File
name and line number are printed so you know where to look in case the input came from a script.
8.2 Exceptions
Even if a statement or expression is syntactically correct, it may cause an error when an attempt is made
to execute it. Errors detected during execution are called exceptions and are not unconditionally fatal: you
will soon learn how to handle them in Python programs. Most exceptions are not handled by programs,
however, and result in error messages as shown here:
>>> 10 * (1/0)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
>>> 4 + spam*3
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'spam' is not defined
>>> '2' + 2
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: Can't convert 'int' object to str implicitly
61
Python Tutorial, Release 3.7.0
The last line of the error message indicates what happened. Exceptions come in different types, and the
type is printed as part of the message: the types in the example are ZeroDivisionError, NameError and
TypeError. The string printed as the exception type is the name of the built-in exception that occurred.
This is true for all built-in exceptions, but need not be true for user-defined exceptions (although it is a
useful convention). Standard exception names are built-in identifiers (not reserved keywords).
The rest of the line provides detail based on the type of exception and what caused it.
The preceding part of the error message shows the context where the exception happened, in the form of
a stack traceback. In general it contains a stack traceback listing source lines; however, it will not display
lines read from standard input.
bltin-exceptions lists the built-in exceptions and their meanings.
8.3 Handling Exceptions
It is possible to write programs that handle selected exceptions. Look at the following example, which asks
the user for input until a valid integer has been entered, but allows the user to interrupt the program (using
Control-C or whatever the operating system supports); note that a user-generated interruption is signalled
by raising the KeyboardInterrupt exception.
>>> while True:
... try:
... x = int(input("Please enter a number: "))
... break
... except ValueError:
... print("Oops! That was no valid number. Try again...")
...
The try statement works as follows.
• First, the try clause (the statement(s) between the try and except keywords) is executed.
• If no exception occurs, the except clause is skipped and execution of the try statement is finished.
• If an exception occurs during execution of the try clause, the rest of the clause is skipped. Then if its
type matches the exception named after the except keyword, the except clause is executed, and then
execution continues after the try statement.
• If an exception occurs which does not match the exception named in the except clause, it is passed on
to outer try statements; if no handler is found, it is an unhandled exception and execution stops with
a message as shown above.
A try statement may have more than one except clause, to specify handlers for different exceptions. At
most one handler will be executed. Handlers only handle exceptions that occur in the corresponding try
clause, not in other handlers of the same try statement. An except clause may name multiple exceptions as
a parenthesized tuple, for example:
... except (RuntimeError, TypeError, NameError):
... pass
A class in an except clause is compatible with an exception if it is the same class or a base class thereof (but
not the other way around — an except clause listing a derived class is not compatible with a base class).
For example, the following code will print B, C, D in that order:
class B(Exception):
pass
(continues on next page)
62 Chapter 8. Errors and Exceptions
Python Tutorial, Release 3.7.0
(continued from previous page)
class C(B):
pass
class D(C):
pass
for cls in [B, C, D]:
try:
raise cls()
except D:
print("D")
except C:
print("C")
except B:
print("B")
Note that if the except clauses were reversed (with except B first), it would have printed B, B, B — the
first matching except clause is triggered.
The last except clause may omit the exception name(s), to serve as a wildcard. Use this with extreme
caution, since it is easy to mask a real programming error in this way! It can also be used to print an error
message and then re-raise the exception (allowing a caller to handle the exception as well):
import sys
try:
f = open('myfile.txt')
s = f.readline()
i = int(s.strip())
except OSError as err:
print("OS error: {0}".format(err))
except ValueError:
print("Could not convert data to an integer.")
except:
print("Unexpected error:", sys.exc_info()[0])
raise
The try … except statement has an optional else clause, which, when present, must follow all except clauses.
It is useful for code that must be executed if the try clause does not raise an exception. For example:
for arg in sys.argv[1:]:
try:
f = open(arg, 'r')
except OSError:
print('cannot open', arg)
else:
print(arg, 'has', len(f.readlines()), 'lines')
f.close()
The use of the else clause is better than adding additional code to the try clause because it avoids accidentally catching an exception that wasn’t raised by the code being protected by the try … except statement.
When an exception occurs, it may have an associated value, also known as the exception’s argument. The
presence and type of the argument depend on the exception type.
The except clause may specify a variable after the exception name. The variable is bound to an exception
instance with the arguments stored in instance.args. For convenience, the exception instance defines
__str__() so the arguments can be printed directly without having to reference .args. One may also
8.3. Handling Exceptions 63
Python Tutorial, Release 3.7.0
instantiate an exception first before raising it and add any attributes to it as desired.
>>> try:
... raise Exception('spam', 'eggs')
... except Exception as inst:
... print(type(inst)) # the exception instance
... print(inst.args) # arguments stored in .args
... print(inst) # __str__ allows args to be printed directly,
... # but may be overridden in exception subclasses
... x, y = inst.args # unpack args
... print('x =', x)
... print('y =', y)
...
<class 'Exception'>
('spam', 'eggs')
('spam', 'eggs')
x = spam
y = eggs
If an exception has arguments, they are printed as the last part (‘detail’) of the message for unhandled
exceptions.
Exception handlers don’t just handle exceptions if they occur immediately in the try clause, but also if they
occur inside functions that are called (even indirectly) in the try clause. For example:
>>> def this_fails():
... x = 1/0
...
>>> try:
... this_fails()
... except ZeroDivisionError as err:
... print('Handling run-time error:', err)
...
Handling run-time error: division by zero
8.4 Raising Exceptions
The raise statement allows the programmer to force a specified exception to occur. For example:
>>> raise NameError('HiThere')
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: HiThere
The sole argument to raise indicates the exception to be raised. This must be either an exception instance or
an exception class (a class that derives from Exception). If an exception class is passed, it will be implicitly
instantiated by calling its constructor with no arguments:
raise ValueError # shorthand for 'raise ValueError()'
If you need to determine whether an exception was raised but don’t intend to handle it, a simpler form of
the raise statement allows you to re-raise the exception:
>>> try:
... raise NameError('HiThere')
... except NameError:
(continues on next page)
64 Chapter 8. Errors and Exceptions
Python Tutorial, Release 3.7.0
(continued from previous page)
... print('An exception flew by!')
... raise
...
An exception flew by!
Traceback (most recent call last):
File "<stdin>", line 2, in <module>
NameError: HiThere
8.5 User-defined Exceptions
Programs may name their own exceptions by creating a new exception class (see Classes for more about
Python classes). Exceptions should typically be derived from the Exception class, either directly or indirectly.
Exception classes can be defined which do anything any other class can do, but are usually kept simple, often
only offering a number of attributes that allow information about the error to be extracted by handlers for
the exception. When creating a module that can raise several distinct errors, a common practice is to create
a base class for exceptions defined by that module, and subclass that to create specific exception classes for
different error conditions:
class Error(Exception):
"""Base class for exceptions in this module."""
pass
class InputError(Error):
"""Exception raised for errors in the input.
Attributes:
expression -- input expression in which the error occurred
message -- explanation of the error
"""
def __init__(self, expression, message):
self.expression = expression
self.message = message
class TransitionError(Error):
"""Raised when an operation attempts a state transition that's not
allowed.
Attributes:
previous -- state at beginning of transition
next -- attempted new state
message -- explanation of why the specific transition is not allowed
"""
def __init__(self, previous, next, message):
self.previous = previous
self.next = next
self.message = message
Most exceptions are defined with names that end in “Error,” similar to the naming of the standard exceptions.
Many standard modules define their own exceptions to report errors that may occur in functions they define.
More information on classes is presented in chapter Classes.
8.5. User-defined Exceptions 65
Python Tutorial, Release 3.7.0
8.6 Defining Clean-up Actions
The try statement has another optional clause which is intended to define clean-up actions that must be
executed under all circumstances. For example:
>>> try:
... raise KeyboardInterrupt
... finally:
... print('Goodbye, world!')
...
Goodbye, world!
KeyboardInterrupt
Traceback (most recent call last):
File "<stdin>", line 2, in <module>
A finally clause is always executed before leaving the try statement, whether an exception has occurred or
not. When an exception has occurred in the try clause and has not been handled by an except clause (or it
has occurred in an except or else clause), it is re-raised after the finally clause has been executed. The
finally clause is also executed “on the way out” when any other clause of the try statement is left via a
break, continue or return statement. A more complicated example:
>>> def divide(x, y):
... try:
... result = x / y
... except ZeroDivisionError:
... print("division by zero!")
... else:
... print("result is", result)
... finally:
... print("executing finally clause")
...
>>> divide(2, 1)
result is 2.0
executing finally clause
>>> divide(2, 0)
division by zero!
executing finally clause
>>> divide("2", "1")
executing finally clause
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
File "<stdin>", line 3, in divide
TypeError: unsupported operand type(s) for /: 'str' and 'str'
As you can see, the finally clause is executed in any event. The TypeError raised by dividing two strings
is not handled by the except clause and therefore re-raised after the finally clause has been executed.
In real world applications, the finally clause is useful for releasing external resources (such as files or
network connections), regardless of whether the use of the resource was successful.
8.7 Predefined Clean-up Actions
Some objects define standard clean-up actions to be undertaken when the object is no longer needed, regardless of whether or not the operation using the object succeeded or failed. Look at the following example,
which tries to open a file and print its contents to the screen.
66 Chapter 8. Errors and Exceptions
Python Tutorial, Release 3.7.0
for line in open("myfile.txt"):
print(line, end="")
The problem with this code is that it leaves the file open for an indeterminate amount of time after this part
of the code has finished executing. This is not an issue in simple scripts, but can be a problem for larger
applications. The with statement allows objects like files to be used in a way that ensures they are always
cleaned up promptly and correctly.
with open("myfile.txt") as f:
for line in f:
print(line, end="")
After the statement is executed, the file f is always closed, even if a problem was encountered while processing the lines. Objects which, like files, provide predefined clean-up actions will indicate this in their
documentation.
8.7. Predefined Clean-up Actions 67
Python Tutorial, Release 3.7.0
68 Chapter 8. Errors and Exceptions
CHAPTER
NINE
CLASSES
Classes provide a means of bundling data and functionality together. Creating a new class creates a new type
of object, allowing new instances of that type to be made. Each class instance can have attributes attached
to it for maintaining its state. Class instances can also have methods (defined by its class) for modifying its
state.
Compared with other programming languages, Python’s class mechanism adds classes with a minimum of
new syntax and semantics. It is a mixture of the class mechanisms found in C++ and Modula-3. Python
classes provide all the standard features of Object Oriented Programming: the class inheritance mechanism
allows multiple base classes, a derived class can override any methods of its base class or classes, and a
method can call the method of a base class with the same name. Objects can contain arbitrary amounts and
kinds of data. As is true for modules, classes partake of the dynamic nature of Python: they are created at
runtime, and can be modified further after creation.
In C++ terminology, normally class members (including the data members) are public (except see below
Private Variables), and all member functions are virtual. As in Modula-3, there are no shorthands for
referencing the object’s members from its methods: the method function is declared with an explicit first
argument representing the object, which is provided implicitly by the call. As in Smalltalk, classes themselves
are objects. This provides semantics for importing and renaming. Unlike C++ and Modula-3, built-in types
can be used as base classes for extension by the user. Also, like in C++, most built-in operators with special
syntax (arithmetic operators, subscripting etc.) can be redefined for class instances.
(Lacking universally accepted terminology to talk about classes, I will make occasional use of Smalltalk and
C++ terms. I would use Modula-3 terms, since its object-oriented semantics are closer to those of Python
than C++, but I expect that few readers have heard of it.)
9.1 A Word About Names and Objects
Objects have individuality, and multiple names (in multiple scopes) can be bound to the same object. This
is known as aliasing in other languages. This is usually not appreciated on a first glance at Python, and
can be safely ignored when dealing with immutable basic types (numbers, strings, tuples). However, aliasing
has a possibly surprising effect on the semantics of Python code involving mutable objects such as lists,
dictionaries, and most other types. This is usually used to the benefit of the program, since aliases behave
like pointers in some respects. For example, passing an object is cheap since only a pointer is passed by the
implementation; and if a function modifies an object passed as an argument, the caller will see the change
— this eliminates the need for two different argument passing mechanisms as in Pascal.
9.2 Python Scopes and Namespaces
Before introducing classes, I first have to tell you something about Python’s scope rules. Class definitions
play some neat tricks with namespaces, and you need to know how scopes and namespaces work to fully
69
Python Tutorial, Release 3.7.0
understand what’s going on. Incidentally, knowledge about this subject is useful for any advanced Python
programmer.
Let’s begin with some definitions.
A namespace is a mapping from names to objects. Most namespaces are currently implemented as Python
dictionaries, but that’s normally not noticeable in any way (except for performance), and it may change
in the future. Examples of namespaces are: the set of built-in names (containing functions such as abs(),
and built-in exception names); the global names in a module; and the local names in a function invocation.
In a sense the set of attributes of an object also form a namespace. The important thing to know about
namespaces is that there is absolutely no relation between names in different namespaces; for instance, two
different modules may both define a function maximize without confusion — users of the modules must
prefix it with the module name.
By the way, I use the word attribute for any name following a dot — for example, in the expression z.
real, real is an attribute of the object z. Strictly speaking, references to names in modules are attribute
references: in the expression modname.funcname, modname is a module object and funcname is an attribute
of it. In this case there happens to be a straightforward mapping between the module’s attributes and the
global names defined in the module: they share the same namespace!1
Attributes may be read-only or writable. In the latter case, assignment to attributes is possible. Module
attributes are writable: you can write modname.the_answer = 42. Writable attributes may also be deleted
with the del statement. For example, del modname.the_answer will remove the attribute the_answer from
the object named by modname.
Namespaces are created at different moments and have different lifetimes. The namespace containing the
built-in names is created when the Python interpreter starts up, and is never deleted. The global namespace
for a module is created when the module definition is read in; normally, module namespaces also last until
the interpreter quits. The statements executed by the top-level invocation of the interpreter, either read
from a script file or interactively, are considered part of a module called __main__, so they have their own
global namespace. (The built-in names actually also live in a module; this is called builtins.)
The local namespace for a function is created when the function is called, and deleted when the function
returns or raises an exception that is not handled within the function. (Actually, forgetting would be a
better way to describe what actually happens.) Of course, recursive invocations each have their own local
namespace.
A scope is a textual region of a Python program where a namespace is directly accessible. “Directly accessible”
here means that an unqualified reference to a name attempts to find the name in the namespace.
Although scopes are determined statically, they are used dynamically. At any time during execution, there
are at least three nested scopes whose namespaces are directly accessible:
• the innermost scope, which is searched first, contains the local names
• the scopes of any enclosing functions, which are searched starting with the nearest enclosing scope,
contains non-local, but also non-global names
• the next-to-last scope contains the current module’s global names
• the outermost scope (searched last) is the namespace containing built-in names
If a name is declared global, then all references and assignments go directly to the middle scope containing the
module’s global names. To rebind variables found outside of the innermost scope, the nonlocal statement
can be used; if not declared nonlocal, those variables are read-only (an attempt to write to such a variable
will simply create a new local variable in the innermost scope, leaving the identically named outer variable
unchanged).
1 Except for one thing. Module objects have a secret read-only attribute called __dict__ which returns the dictionary used
to implement the module’s namespace; the name __dict__ is an attribute but not a global name. Obviously, using this violates
the abstraction of namespace implementation, and should be restricted to things like post-mortem debuggers.
70 Chapter 9. Classes
Python Tutorial, Release 3.7.0
Usually, the local scope references the local names of the (textually) current function. Outside functions, the
local scope references the same namespace as the global scope: the module’s namespace. Class definitions
place yet another namespace in the local scope.
It is important to realize that scopes are determined textually: the global scope of a function defined in a
module is that module’s namespace, no matter from where or by what alias the function is called. On the
other hand, the actual search for names is done dynamically, at run time — however, the language definition
is evolving towards static name resolution, at “compile” time, so don’t rely on dynamic name resolution! (In
fact, local variables are already determined statically.)
A special quirk of Python is that – if no global statement is in effect – assignments to names always go into
the innermost scope. Assignments do not copy data — they just bind names to objects. The same is true for
deletions: the statement del x removes the binding of x from the namespace referenced by the local scope.
In fact, all operations that introduce new names use the local scope: in particular, import statements and
function definitions bind the module or function name in the local scope.
The global statement can be used to indicate that particular variables live in the global scope and should
be rebound there; the nonlocal statement indicates that particular variables live in an enclosing scope and
should be rebound there.
9.2.1 Scopes and Namespaces Example
This is an example demonstrating how to reference the different scopes and namespaces, and how global
and nonlocal affect variable binding:
def scope_test():
def do_local():
spam = "local spam"
def do_nonlocal():
nonlocal spam
spam = "nonlocal spam"
def do_global():
global spam
spam = "global spam"
spam = "test spam"
do_local()
print("After local assignment:", spam)
do_nonlocal()
print("After nonlocal assignment:", spam)
do_global()
print("After global assignment:", spam)
scope_test()
print("In global scope:", spam)
The output of the example code is:
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
Note how the local assignment (which is default) didn’t change scope_test’s binding of spam. The nonlocal
assignment changed scope_test’s binding of spam, and the global assignment changed the module-level
binding.
9.2. Python Scopes and Namespaces 71
Python Tutorial, Release 3.7.0
You can also see that there was no previous binding for spam before the global assignment.
9.3 A First Look at Classes
Classes introduce a little bit of new syntax, three new object types, and some new semantics.
9.3.1 Class Definition Syntax
The simplest form of class definition looks like this:
class ClassName:
<statement-1>
.
.
.
<statement-N>
Class definitions, like function definitions (def statements) must be executed before they have any effect.
(You could conceivably place a class definition in a branch of an if statement, or inside a function.)
In practice, the statements inside a class definition will usually be function definitions, but other statements
are allowed, and sometimes useful — we’ll come back to this later. The function definitions inside a class
normally have a peculiar form of argument list, dictated by the calling conventions for methods — again,
this is explained later.
When a class definition is entered, a new namespace is created, and used as the local scope — thus, all
assignments to local variables go into this new namespace. In particular, function definitions bind the name
of the new function here.
When a class definition is left normally (via the end), a class object is created. This is basically a wrapper
around the contents of the namespace created by the class definition; we’ll learn more about class objects
in the next section. The original local scope (the one in effect just before the class definition was entered)
is reinstated, and the class object is bound here to the class name given in the class definition header
(ClassName in the example).
9.3.2 Class Objects
Class objects support two kinds of operations: attribute references and instantiation.
Attribute references use the standard syntax used for all attribute references in Python: obj.name. Valid
attribute names are all the names that were in the class’s namespace when the class object was created. So,
if the class definition looked like this:
class MyClass:
"""A simple example class"""
i = 12345
def f(self):
return 'hello world'
then MyClass.i and MyClass.f are valid attribute references, returning an integer and a function object,
respectively. Class attributes can also be assigned to, so you can change the value of MyClass.i by assignment. __doc__ is also a valid attribute, returning the docstring belonging to the class: "A simple example
class".
72 Chapter 9. Classes
Python Tutorial, Release 3.7.0
Class instantiation uses function notation. Just pretend that the class object is a parameterless function
that returns a new instance of the class. For example (assuming the above class):
x = MyClass()
creates a new instance of the class and assigns this object to the local variable x.
The instantiation operation (“calling” a class object) creates an empty object. Many classes like to create
objects with instances customized to a specific initial state. Therefore a class may define a special method
named __init__(), like this:
def __init__(self):
self.data = []
When a class defines an __init__() method, class instantiation automatically invokes __init__() for the
newly-created class instance. So in this example, a new, initialized instance can be obtained by:
x = MyClass()
Of course, the __init__() method may have arguments for greater flexibility. In that case, arguments given
to the class instantiation operator are passed on to __init__(). For example,
>>> class Complex:
... def __init__(self, realpart, imagpart):
... self.r = realpart
... self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)
9.3.3 Instance Objects
Now what can we do with instance objects? The only operations understood by instance objects are attribute
references. There are two kinds of valid attribute names, data attributes and methods.
data attributes correspond to “instance variables” in Smalltalk, and to “data members” in C++. Data
attributes need not be declared; like local variables, they spring into existence when they are first assigned
to. For example, if x is the instance of MyClass created above, the following piece of code will print the
value 16, without leaving a trace:
x.counter = 1
while x.counter < 10:
x.counter = x.counter * 2
print(x.counter)
del x.counter
The other kind of instance attribute reference is a method. A method is a function that “belongs to” an
object. (In Python, the term method is not unique to class instances: other object types can have methods
as well. For example, list objects have methods called append, insert, remove, sort, and so on. However, in
the following discussion, we’ll use the term method exclusively to mean methods of class instance objects,
unless explicitly stated otherwise.)
Valid method names of an instance object depend on its class. By definition, all attributes of a class that
are function objects define corresponding methods of its instances. So in our example, x.f is a valid method
reference, since MyClass.f is a function, but x.i is not, since MyClass.i is not. But x.f is not the same
thing as MyClass.f — it is a method object, not a function object.
9.3. A First Look at Classes 73
Python Tutorial, Release 3.7.0
9.3.4 Method Objects
Usually, a method is called right after it is bound:
x.f()
In the MyClass example, this will return the string 'hello world'. However, it is not necessary to call a
method right away: x.f is a method object, and can be stored away and called at a later time. For example:
xf = x.f
while True:
print(xf())
will continue to print hello world until the end of time.
What exactly happens when a method is called? You may have noticed that x.f() was called without an
argument above, even though the function definition for f() specified an argument. What happened to the
argument? Surely Python raises an exception when a function that requires an argument is called without
any — even if the argument isn’t actually used…
Actually, you may have guessed the answer: the special thing about methods is that the instance object is
passed as the first argument of the function. In our example, the call x.f() is exactly equivalent to MyClass.
f(x). In general, calling a method with a list of n arguments is equivalent to calling the corresponding
function with an argument list that is created by inserting the method’s instance object before the first
argument.
If you still don’t understand how methods work, a look at the implementation can perhaps clarify matters.
When a non-data attribute of an instance is referenced, the instance’s class is searched. If the name denotes
a valid class attribute that is a function object, a method object is created by packing (pointers to) the
instance object and the function object just found together in an abstract object: this is the method object.
When the method object is called with an argument list, a new argument list is constructed from the instance
object and the argument list, and the function object is called with this new argument list.
9.3.5 Class and Instance Variables
Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:
class Dog:
kind = 'canine' # class variable shared by all instances
def __init__(self, name):
self.name = name # instance variable unique to each instance
>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind # shared by all dogs
'canine'
>>> e.kind # shared by all dogs
'canine'
>>> d.name # unique to d
'Fido'
>>> e.name # unique to e
'Buddy'
74 Chapter 9. Classes
Python Tutorial, Release 3.7.0
As discussed in A Word About Names and Objects, shared data can have possibly surprising effects with
involving mutable objects such as lists and dictionaries. For example, the tricks list in the following code
should not be used as a class variable because just a single list would be shared by all Dog instances:
class Dog:
tricks = [] # mistaken use of a class variable
def __init__(self, name):
self.name = name
def add_trick(self, trick):
self.tricks.append(trick)
>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks # unexpectedly shared by all dogs
['roll over', 'play dead']
Correct design of the class should use an instance variable instead:
class Dog:
def __init__(self, name):
self.name = name
self.tricks = [] # creates a new empty list for each dog
def add_trick(self, trick):
self.tricks.append(trick)
>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']
9.4 Random Remarks
Data attributes override method attributes with the same name; to avoid accidental name conflicts, which
may cause hard-to-find bugs in large programs, it is wise to use some kind of convention that minimizes the
chance of conflicts. Possible conventions include capitalizing method names, prefixing data attribute names
with a small unique string (perhaps just an underscore), or using verbs for methods and nouns for data
attributes.
Data attributes may be referenced by methods as well as by ordinary users (“clients”) of an object. In
other words, classes are not usable to implement pure abstract data types. In fact, nothing in Python
makes it possible to enforce data hiding — it is all based upon convention. (On the other hand, the Python
implementation, written in C, can completely hide implementation details and control access to an object if
necessary; this can be used by extensions to Python written in C.)
Clients should use data attributes with care — clients may mess up invariants maintained by the methods
9.4. Random Remarks 75
Python Tutorial, Release 3.7.0
by stamping on their data attributes. Note that clients may add data attributes of their own to an instance
object without affecting the validity of the methods, as long as name conflicts are avoided — again, a naming
convention can save a lot of headaches here.
There is no shorthand for referencing data attributes (or other methods!) from within methods. I find that
this actually increases the readability of methods: there is no chance of confusing local variables and instance
variables when glancing through a method.
Often, the first argument of a method is called self. This is nothing more than a convention: the name
self has absolutely no special meaning to Python. Note, however, that by not following the convention
your code may be less readable to other Python programmers, and it is also conceivable that a class browser
program might be written that relies upon such a convention.
Any function object that is a class attribute defines a method for instances of that class. It is not necessary
that the function definition is textually enclosed in the class definition: assigning a function object to a local
variable in the class is also ok. For example:
# Function defined outside the class
def f1(self, x, y):
return min(x, x+y)
class C:
f = f1
def g(self):
return 'hello world'
h = g
Now f, g and h are all attributes of class C that refer to function objects, and consequently they are all
methods of instances of C — h being exactly equivalent to g. Note that this practice usually only serves to
confuse the reader of a program.
Methods may call other methods by using method attributes of the self argument:
class Bag:
def __init__(self):
self.data = []
def add(self, x):
self.data.append(x)
def addtwice(self, x):
self.add(x)
self.add(x)
Methods may reference global names in the same way as ordinary functions. The global scope associated
with a method is the module containing its definition. (A class is never used as a global scope.) While one
rarely encounters a good reason for using global data in a method, there are many legitimate uses of the
global scope: for one thing, functions and modules imported into the global scope can be used by methods,
as well as functions and classes defined in it. Usually, the class containing the method is itself defined in this
global scope, and in the next section we’ll find some good reasons why a method would want to reference its
own class.
Each value is an object, and therefore has a class (also called its type). It is stored as object.__class__.
76 Chapter 9. Classes
Python Tutorial, Release 3.7.0
9.5 Inheritance
Of course, a language feature would not be worthy of the name “class” without supporting inheritance. The
syntax for a derived class definition looks like this:
class DerivedClassName(BaseClassName):
<statement-1>
.
.
.
<statement-N>
The name BaseClassName must be defined in a scope containing the derived class definition. In place of
a base class name, other arbitrary expressions are also allowed. This can be useful, for example, when the
base class is defined in another module:
class DerivedClassName(modname.BaseClassName):
Execution of a derived class definition proceeds the same as for a base class. When the class object is
constructed, the base class is remembered. This is used for resolving attribute references: if a requested
attribute is not found in the class, the search proceeds to look in the base class. This rule is applied
recursively if the base class itself is derived from some other class.
There’s nothing special about instantiation of derived classes: DerivedClassName() creates a new instance of
the class. Method references are resolved as follows: the corresponding class attribute is searched, descending
down the chain of base classes if necessary, and the method reference is valid if this yields a function object.
Derived classes may override methods of their base classes. Because methods have no special privileges when
calling other methods of the same object, a method of a base class that calls another method defined in the
same base class may end up calling a method of a derived class that overrides it. (For C++ programmers:
all methods in Python are effectively virtual.)
An overriding method in a derived class may in fact want to extend rather than simply replace the base
class method of the same name. There is a simple way to call the base class method directly: just call
BaseClassName.methodname(self, arguments). This is occasionally useful to clients as well. (Note that
this only works if the base class is accessible as BaseClassName in the global scope.)
Python has two built-in functions that work with inheritance:
• Use isinstance() to check an instance’s type: isinstance(obj, int) will be True only if obj.
__class__ is int or some class derived from int.
• Use issubclass() to check class inheritance: issubclass(bool, int) is True since bool is a subclass
of int. However, issubclass(float, int) is False since float is not a subclass of int.
9.5.1 Multiple Inheritance
Python supports a form of multiple inheritance as well. A class definition with multiple base classes looks
like this:
class DerivedClassName(Base1, Base2, Base3):
<statement-1>
.
.
.
<statement-N>
9.5. Inheritance 77
Python Tutorial, Release 3.7.0
For most purposes, in the simplest cases, you can think of the search for attributes inherited from a parent
class as depth-first, left-to-right, not searching twice in the same class where there is an overlap in the hierarchy. Thus, if an attribute is not found in DerivedClassName, it is searched for in Base1, then (recursively)
in the base classes of Base1, and if it was not found there, it was searched for in Base2, and so on.
In fact, it is slightly more complex than that; the method resolution order changes dynamically to support
cooperative calls to super(). This approach is known in some other multiple-inheritance languages as
call-next-method and is more powerful than the super call found in single-inheritance languages.
Dynamic ordering is necessary because all cases of multiple inheritance exhibit one or more diamond relationships (where at least one of the parent classes can be accessed through multiple paths from the
bottommost class). For example, all classes inherit from object, so any case of multiple inheritance
provides more than one path to reach object. To keep the base classes from being accessed more than
once, the dynamic algorithm linearizes the search order in a way that preserves the left-to-right ordering specified in each class, that calls each parent only once, and that is monotonic (meaning that a class
can be subclassed without affecting the precedence order of its parents). Taken together, these properties
make it possible to design reliable and extensible classes with multiple inheritance. For more detail, see
https://www.python.org/download/releases/2.3/mro/.
9.6 Private Variables
“Private” instance variables that cannot be accessed except from inside an object don’t exist in Python.
However, there is a convention that is followed by most Python code: a name prefixed with an underscore
(e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data
member). It should be considered an implementation detail and subject to change without notice.
Since there is a valid use-case for class-private members (namely to avoid name clashes of names with names
defined by subclasses), there is limited support for such a mechanism, called name mangling. Any identifier
of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced
with _classname__spam, where classname is the current class name with leading underscore(s) stripped.
This mangling is done without regard to the syntactic position of the identifier, as long as it occurs within
the definition of a class.
Name mangling is helpful for letting subclasses override methods without breaking intraclass method calls.
For example:
class Mapping:
def __init__(self, iterable):
self.items_list = []
self.__update(iterable)
def update(self, iterable):
for item in iterable:
self.items_list.append(item)
__update = update # private copy of original update() method
class MappingSubclass(Mapping):
def update(self, keys, values):
# provides new signature for update()
# but does not break __init__()
for item in zip(keys, values):
self.items_list.append(item)
Note that the mangling rules are designed mostly to avoid accidents; it still is possible to access or modify a
variable that is considered private. This can even be useful in special circumstances, such as in the debugger.
78 Chapter 9. Classes
Python Tutorial, Release 3.7.0
Notice that code passed to exec() or eval() does not consider the classname of the invoking class to be the
current class; this is similar to the effect of the global statement, the effect of which is likewise restricted to
code that is byte-compiled together. The same restriction applies to getattr(), setattr() and delattr(),
as well as when referencing __dict__ directly.
9.7 Odds and Ends
Sometimes it is useful to have a data type similar to the Pascal “record” or C “struct”, bundling together a
few named data items. An empty class definition will do nicely:
class Employee:
pass
john = Employee() # Create an empty employee record
# Fill the fields of the record
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
A piece of Python code that expects a particular abstract data type can often be passed a class that emulates
the methods of that data type instead. For instance, if you have a function that formats some data from
a file object, you can define a class with methods read() and readline() that get the data from a string
buffer instead, and pass it as an argument.
Instance method objects have attributes, too: m.__self__ is the instance object with the method m(), and
m.__func__ is the function object corresponding to the method.
9.8 Iterators
By now you have probably noticed that most container objects can be looped over using a for statement:
for element in [1, 2, 3]:
print(element)
for element in (1, 2, 3):
print(element)
for key in {'one':1, 'two':2}:
print(key)
for char in "123":
print(char)
for line in open("myfile.txt"):
print(line, end='')
This style of access is clear, concise, and convenient. The use of iterators pervades and unifies Python.
Behind the scenes, the for statement calls iter() on the container object. The function returns an iterator
object that defines the method __next__() which accesses elements in the container one at a time. When
there are no more elements, __next__() raises a StopIteration exception which tells the for loop to
terminate. You can call the __next__() method using the next() built-in function; this example shows how
it all works:
>>> s = 'abc'
>>> it = iter(s)
>>> it
(continues on next page)
9.7. Odds and Ends 79
Python Tutorial, Release 3.7.0
(continued from previous page)
<iterator object at 0x00A1DB50>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
next(it)
StopIteration
Having seen the mechanics behind the iterator protocol, it is easy to add iterator behavior to your classes.
Define an __iter__() method which returns an object with a __next__() method. If the class defines
__next__(), then __iter__() can just return self:
class Reverse:
"""Iterator for looping over a sequence backwards."""
def __init__(self, data):
self.data = data
self.index = len(data)
def __iter__(self):
return self
def __next__(self):
if self.index == 0:
raise StopIteration
self.index = self.index - 1
return self.data[self.index]
>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at 0x00A1DB50>
>>> for char in rev:
... print(char)
...
m
a
p
s
9.9 Generators
Generators are a simple and powerful tool for creating iterators. They are written like regular functions but
use the yield statement whenever they want to return data. Each time next() is called on it, the generator
resumes where it left off (it remembers all the data values and which statement was last executed). An
example shows that generators can be trivially easy to create:
def reverse(data):
for index in range(len(data)-1, -1, -1):
yield data[index]
80 Chapter 9. Classes
Python Tutorial, Release 3.7.0
>>> for char in reverse('golf'):
... print(char)
...
f
l
o
g
Anything that can be done with generators can also be done with class-based iterators as described in the
previous section. What makes generators so compact is that the __iter__() and __next__() methods are
created automatically.
Another key feature is that the local variables and execution state are automatically saved between calls.
This made the function easier to write and much more clear than an approach using instance variables like
self.index and self.data.
In addition to automatic method creation and saving program state, when generators terminate, they automatically raise StopIteration. In combination, these features make it easy to create iterators with no
more effort than writing a regular function.
9.10 Generator Expressions
Some simple generators can be coded succinctly as expressions using a syntax similar to list comprehensions
but with parentheses instead of square brackets. These expressions are designed for situations where the generator is used right away by an enclosing function. Generator expressions are more compact but less versatile
than full generator definitions and tend to be more memory friendly than equivalent list comprehensions.
Examples:
>>> sum(i*i for i in range(10)) # sum of squares
285
>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec)) # dot product
260
>>> from math import pi, sin
>>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}
>>> unique_words = set(word for line in page for word in line.split())
>>> valedictorian = max((student.gpa, student.name) for student in graduates)
>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']
9.10. Generator Expressions 81
Python Tutorial, Release 3.7.0
82 Chapter 9. Classes
CHAPTER
TEN
BRIEF TOUR OF THE STANDARD LIBRARY
10.1 Operating System Interface
The os module provides dozens of functions for interacting with the operating system:
>>> import os
>>> os.getcwd() # Return the current working directory
'C:\\Python37'
>>> os.chdir('/server/accesslogs') # Change current working directory
>>> os.system('mkdir today') # Run the command mkdir in the system shell
0
Be sure to use the import os style instead of from os import *. This will keep os.open() from shadowing
the built-in open() function which operates much differently.
The built-in dir() and help() functions are useful as interactive aids for working with large modules like
os:
>>> import os
>>> dir(os)
<returns a list of all module functions>
>>> help(os)
<returns an extensive manual page created from the module's docstrings>
For daily file and directory management tasks, the shutil module provides a higher level interface that is
easier to use:
>>> import shutil
>>> shutil.copyfile('data.db', 'archive.db')
'archive.db'
>>> shutil.move('/build/executables', 'installdir')
'installdir'
10.2 File Wildcards
The glob module provides a function for making file lists from directory wildcard searches:
>>> import glob
>>> glob.glob('*.py')
['primes.py', 'random.py', 'quote.py']
83
Python Tutorial, Release 3.7.0
10.3 Command Line Arguments
Common utility scripts often need to process command line arguments. These arguments are stored in the
sys module’s argv attribute as a list. For instance the following output results from running python demo.py
one two three at the command line:
>>> import sys
>>> print(sys.argv)
['demo.py', 'one', 'two', 'three']
The getopt module processes sys.argv using the conventions of the Unix getopt() function. More powerful
and flexible command line processing is provided by the argparse module.
10.4 Error Output Redirection and Program Termination
The sys module also has attributes for stdin, stdout, and stderr. The latter is useful for emitting warnings
and error messages to make them visible even when stdout has been redirected:
>>> sys.stderr.write('Warning, log file not found starting a new one\n')
Warning, log file not found starting a new one
The most direct way to terminate a script is to use sys.exit().
10.5 String Pattern Matching
The re module provides regular expression tools for advanced string processing. For complex matching and
manipulation, regular expressions offer succinct, optimized solutions:
>>> import re
>>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
['foot', 'fell', 'fastest']
>>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
'cat in the hat'
When only simple capabilities are needed, string methods are preferred because they are easier to read and
debug:
>>> 'tea for too'.replace('too', 'two')
'tea for two'
10.6 Mathematics
The math module gives access to the underlying C library functions for floating point math:
>>> import math
>>> math.cos(math.pi / 4)
0.70710678118654757
>>> math.log(1024, 2)
10.0
The random module provides tools for making random selections:
84 Chapter 10. Brief Tour of the Standard Library
Python Tutorial, Release 3.7.0
>>> import random
>>> random.choice(['apple', 'pear', 'banana'])
'apple'
>>> random.sample(range(100), 10) # sampling without replacement
[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
>>> random.random() # random float
0.17970987693706186
>>> random.randrange(6) # random integer chosen from range(6)
4
The statistics module calculates basic statistical properties (the mean, median, variance, etc.) of numeric
data:
>>> import statistics
>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
>>> statistics.mean(data)
1.6071428571428572
>>> statistics.median(data)
1.25
>>> statistics.variance(data)
1.3720238095238095
The SciPy project <https://scipy.org> has many other modules for numerical computations.
10.7 Internet Access
There are a number of modules for accessing the internet and processing internet protocols. Two of the
simplest are urllib.request for retrieving data from URLs and smtplib for sending mail:
>>> from urllib.request import urlopen
>>> with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
... for line in response:
... line = line.decode('utf-8') # Decoding the binary data to text.
... if 'EST' in line or 'EDT' in line: # look for Eastern Time
... print(line)
<BR>Nov. 25, 09:43:32 PM EST
>>> import smtplib
>>> server = smtplib.SMTP('localhost')
>>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
... """To: jcaesar@example.org
... From: soothsayer@example.org
...
... Beware the Ides of March.
... """)
>>> server.quit()
(Note that the second example needs a mailserver running on localhost.)
10.8 Dates and Times
The datetime module supplies classes for manipulating dates and times in both simple and complex ways.
While date and time arithmetic is supported, the focus of the implementation is on efficient member extrac10.7. Internet Access 85
Python Tutorial, Release 3.7.0
tion for output formatting and manipulation. The module also supports objects that are timezone aware.
>>> # dates are easily constructed and formatted
>>> from datetime import date
>>> now = date.today()
>>> now
datetime.date(2003, 12, 2)
>>> now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")
'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'
>>> # dates support calendar arithmetic
>>> birthday = date(1964, 7, 31)
>>> age = now - birthday
>>> age.days
14368
10.9 Data Compression
Common data archiving and compression formats are directly supported by modules including: zlib, gzip,
bz2, lzma, zipfile and tarfile.
>>> import zlib
>>> s = b'witch which has which witches wrist watch'
>>> len(s)
41
>>> t = zlib.compress(s)
>>> len(t)
37
>>> zlib.decompress(t)
b'witch which has which witches wrist watch'
>>> zlib.crc32(s)
226805979
10.10 Performance Measurement
Some Python users develop a deep interest in knowing the relative performance of different approaches to
the same problem. Python provides a measurement tool that answers those questions immediately.
For example, it may be tempting to use the tuple packing and unpacking feature instead of the traditional approach to swapping arguments. The timeit module quickly demonstrates a modest performance
advantage:
>>> from timeit import Timer
>>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
0.57535828626024577
>>> Timer('a,b = b,a', 'a=1; b=2').timeit()
0.54962537085770791
In contrast to timeit’s fine level of granularity, the profile and pstats modules provide tools for identifying
time critical sections in larger blocks of code.
86 Chapter 10. Brief Tour of the Standard Library
Python Tutorial, Release 3.7.0
10.11 Quality Control
One approach for developing high quality software is to write tests for each function as it is developed and
to run those tests frequently during the development process.
The doctest module provides a tool for scanning a module and validating tests embedded in a program’s
docstrings. Test construction is as simple as cutting-and-pasting a typical call along with its results into
the docstring. This improves the documentation by providing the user with an example and it allows the
doctest module to make sure the code remains true to the documentation:
def average(values):
"""Computes the arithmetic mean of a list of numbers.
>>> print(average([20, 30, 70]))
40.0
"""
return sum(values) / len(values)
import doctest
doctest.testmod() # automatically validate the embedded tests
The unittest module is not as effortless as the doctest module, but it allows a more comprehensive set of
tests to be maintained in a separate file:
import unittest
class TestStatisticalFunctions(unittest.TestCase):
def test_average(self):
self.assertEqual(average([20, 30, 70]), 40.0)
self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
with self.assertRaises(ZeroDivisionError):
average([])
with self.assertRaises(TypeError):
average(20, 30, 70)
unittest.main() # Calling from the command line invokes all tests
10.12 Batteries Included
Python has a “batteries included” philosophy. This is best seen through the sophisticated and robust
capabilities of its larger packages. For example:
• The xmlrpc.client and xmlrpc.server modules make implementing remote procedure calls into an
almost trivial task. Despite the modules names, no direct knowledge or handling of XML is needed.
• The email package is a library for managing email messages, including MIME and other RFC 2822-
based message documents. Unlike smtplib and poplib which actually send and receive messages, the
email package has a complete toolset for building or decoding complex message structures (including
attachments) and for implementing internet encoding and header protocols.
• The json package provides robust support for parsing this popular data interchange format. The csv
module supports direct reading and writing of files in Comma-Separated Value format, commonly supported by databases and spreadsheets. XML processing is supported by the xml.etree.ElementTree,
xml.dom and xml.sax packages. Together, these modules and packages greatly simplify data interchange between Python applications and other tools.
10.11. Quality Control 87
Python Tutorial, Release 3.7.0
• The sqlite3 module is a wrapper for the SQLite database library, providing a persistent database
that can be updated and accessed using slightly nonstandard SQL syntax.
• Internationalization is supported by a number of modules including gettext, locale, and the codecs
package.
88 Chapter 10. Brief Tour of the Standard Library
CHAPTER
ELEVEN
BRIEF TOUR OF THE STANDARD LIBRARY — PART II
This second tour covers more advanced modules that support professional programming needs. These modules rarely occur in small scripts.
11.1 Output Formatting
The reprlib module provides a version of repr() customized for abbreviated displays of large or deeply
nested containers:
>>> import reprlib
>>> reprlib.repr(set('supercalifragilisticexpialidocious'))
"{'a', 'c', 'd', 'e', 'f', 'g', ...}"
The pprint module offers more sophisticated control over printing both built-in and user defined objects in
a way that is readable by the interpreter. When the result is longer than one line, the “pretty printer” adds
line breaks and indentation to more clearly reveal data structure:
>>> import pprint
>>> t = [[[['black', 'cyan'], 'white', ['green', 'red']], [['magenta',
... 'yellow'], 'blue']]]
...
>>> pprint.pprint(t, width=30)
[[[['black', 'cyan'],
'white',
['green', 'red']],
[['magenta', 'yellow'],
'blue']]]
The textwrap module formats paragraphs of text to fit a given screen width:
>>> import textwrap
>>> doc = """The wrap() method is just like fill() except that it returns
... a list of strings instead of one big string with newlines to separate
... the wrapped lines."""
...
>>> print(textwrap.fill(doc, width=40))
The wrap() method is just like fill()
except that it returns a list of strings
instead of one big string with newlines
to separate the wrapped lines.
The locale module accesses a database of culture specific data formats. The grouping attribute of locale’s
format function provides a direct way of formatting numbers with group separators:
89
Python Tutorial, Release 3.7.0
>>> import locale
>>> locale.setlocale(locale.LC_ALL, 'English_United States.1252')
'English_United States.1252'
>>> conv = locale.localeconv() # get a mapping of conventions
>>> x = 1234567.8
>>> locale.format("%d", x, grouping=True)
'1,234,567'
>>> locale.format_string("%s%.*f", (conv['currency_symbol'],
... conv['frac_digits'], x), grouping=True)
'$1,234,567.80'
11.2 Templating
The string module includes a versatile Template class with a simplified syntax suitable for editing by
end-users. This allows users to customize their applications without having to alter the application.
The format uses placeholder names formed by $ with valid Python identifiers (alphanumeric characters and
underscores). Surrounding the placeholder with braces allows it to be followed by more alphanumeric letters
with no intervening spaces. Writing $$ creates a single escaped $:
>>> from string import Template
>>> t = Template('${village}folk send $$10 to $cause.')
>>> t.substitute(village='Nottingham', cause='the ditch fund')
'Nottinghamfolk send $10 to the ditch fund.'
The substitute() method raises a KeyError when a placeholder is not supplied in a dictionary or a
keyword argument. For mail-merge style applications, user supplied data may be incomplete and the
safe_substitute() method may be more appropriate — it will leave placeholders unchanged if data is
missing:
>>> t = Template('Return the $item to $owner.')
>>> d = dict(item='unladen swallow')
>>> t.substitute(d)
Traceback (most recent call last):
...
KeyError: 'owner'
>>> t.safe_substitute(d)
'Return the unladen swallow to $owner.'
Template subclasses can specify a custom delimiter. For example, a batch renaming utility for a photo
browser may elect to use percent signs for placeholders such as the current date, image sequence number, or
file format:
>>> import time, os.path
>>> photofiles = ['img_1074.jpg', 'img_1076.jpg', 'img_1077.jpg']
>>> class BatchRename(Template):
... delimiter = '%'
>>> fmt = input('Enter rename style (%d-date %n-seqnum %f-format): ')
Enter rename style (%d-date %n-seqnum %f-format): Ashley_%n%f
>>> t = BatchRename(fmt)
>>> date = time.strftime('%d%b%y')
>>> for i, filename in enumerate(photofiles):
... base, ext = os.path.splitext(filename)
... newname = t.substitute(d=date, n=i, f=ext)
(continues on next page)
90 Chapter 11. Brief Tour of the Standard Library — Part II
Python Tutorial, Release 3.7.0
(continued from previous page)
... print('{0} --> {1}'.format(filename, newname))
img_1074.jpg --> Ashley_0.jpg
img_1076.jpg --> Ashley_1.jpg
img_1077.jpg --> Ashley_2.jpg
Another application for templating is separating program logic from the details of multiple output formats.
This makes it possible to substitute custom templates for XML files, plain text reports, and HTML web
reports.
11.3 Working with Binary Data Record Layouts
The struct module provides pack() and unpack() functions for working with variable length binary record
formats. The following example shows how to loop through header information in a ZIP file without using
the zipfile module. Pack codes "H" and "I" represent two and four byte unsigned numbers respectively.
The "<" indicates that they are standard size and in little-endian byte order:
import struct
with open('myfile.zip', 'rb') as f:
data = f.read()
start = 0
for i in range(3): # show the first 3 file headers
start += 14
fields = struct.unpack('<IIIHH', data[start:start+16])
crc32, comp_size, uncomp_size, filenamesize, extra_size = fields
start += 16
filename = data[start:start+filenamesize]
start += filenamesize
extra = data[start:start+extra_size]
print(filename, hex(crc32), comp_size, uncomp_size)
start += extra_size + comp_size # skip to the next header
11.4 Multi-threading
Threading is a technique for decoupling tasks which are not sequentially dependent. Threads can be used to
improve the responsiveness of applications that accept user input while other tasks run in the background.
A related use case is running I/O in parallel with computations in another thread.
The following code shows how the high level threading module can run tasks in background while the main
program continues to run:
import threading, zipfile
class AsyncZip(threading.Thread):
def __init__(self, infile, outfile):
threading.Thread.__init__(self)
self.infile = infile
self.outfile = outfile
(continues on next page)
11.3. Working with Binary Data Record Layouts 91
Python Tutorial, Release 3.7.0
(continued from previous page)
def run(self):
f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
f.write(self.infile)
f.close()
print('Finished background zip of:', self.infile)
background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')
background.join() # Wait for the background task to finish
print('Main program waited until background was done.')
The principal challenge of multi-threaded applications is coordinating threads that share data or other
resources. To that end, the threading module provides a number of synchronization primitives including
locks, events, condition variables, and semaphores.
While those tools are powerful, minor design errors can result in problems that are difficult to reproduce.
So, the preferred approach to task coordination is to concentrate all access to a resource in a single thread
and then use the queue module to feed that thread with requests from other threads. Applications using
Queue objects for inter-thread communication and coordination are easier to design, more readable, and
more reliable.
11.5 Logging
The logging module offers a full featured and flexible logging system. At its simplest, log messages are sent
to a file or to sys.stderr:
import logging
logging.debug('Debugging information')
logging.info('Informational message')
logging.warning('Warning:config file %s not found', 'server.conf')
logging.error('Error occurred')
logging.critical('Critical error -- shutting down')
This produces the following output:
WARNING:root:Warning:config file server.conf not found
ERROR:root:Error occurred
CRITICAL:root:Critical error -- shutting down
By default, informational and debugging messages are suppressed and the output is sent to standard error. Other output options include routing messages through email, datagrams, sockets, or to an HTTP
Server. New filters can select different routing based on message priority: DEBUG, INFO, WARNING, ERROR, and
CRITICAL.
The logging system can be configured directly from Python or can be loaded from a user editable configuration
file for customized logging without altering the application.
92 Chapter 11. Brief Tour of the Standard Library — Part II
Python Tutorial, Release 3.7.0
11.6 Weak References
Python does automatic memory management (reference counting for most objects and garbage collection to
eliminate cycles). The memory is freed shortly after the last reference to it has been eliminated.
This approach works fine for most applications but occasionally there is a need to track objects only as long
as they are being used by something else. Unfortunately, just tracking them creates a reference that makes
them permanent. The weakref module provides tools for tracking objects without creating a reference.
When the object is no longer needed, it is automatically removed from a weakref table and a callback is
triggered for weakref objects. Typical applications include caching objects that are expensive to create:
>>> import weakref, gc
>>> class A:
... def __init__(self, value):
... self.value = value
... def __repr__(self):
... return str(self.value)
...
>>> a = A(10) # create a reference
>>> d = weakref.WeakValueDictionary()
>>> d['primary'] = a # does not create a reference
>>> d['primary'] # fetch the object if it is still alive
10
>>> del a # remove the one reference
>>> gc.collect() # run garbage collection right away
0
>>> d['primary'] # entry was automatically removed
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
d['primary'] # entry was automatically removed
File "C:/python37/lib/weakref.py", line 46, in __getitem__
o = self.data[key]()
KeyError: 'primary'
11.7 Tools for Working with Lists
Many data structure needs can be met with the built-in list type. However, sometimes there is a need for
alternative implementations with different performance trade-offs.
The array module provides an array() object that is like a list that stores only homogeneous data and stores
it more compactly. The following example shows an array of numbers stored as two byte unsigned binary
numbers (typecode "H") rather than the usual 16 bytes per entry for regular lists of Python int objects:
>>> from array import array
>>> a = array('H', [4000, 10, 700, 22222])
>>> sum(a)
26932
>>> a[1:3]
array('H', [10, 700])
The collections module provides a deque() object that is like a list with faster appends and pops from
the left side but slower lookups in the middle. These objects are well suited for implementing queues and
breadth first tree searches:
11.6. Weak References 93
Python Tutorial, Release 3.7.0
>>> from collections import deque
>>> d = deque(["task1", "task2", "task3"])
>>> d.append("task4")
>>> print("Handling", d.popleft())
Handling task1
unsearched = deque([starting_node])
def breadth_first_search(unsearched):
node = unsearched.popleft()
for m in gen_moves(node):
if is_goal(m):
return m
unsearched.append(m)
In addition to alternative list implementations, the library also offers other tools such as the bisect module
with functions for manipulating sorted lists:
>>> import bisect
>>> scores = [(100, 'perl'), (200, 'tcl'), (400, 'lua'), (500, 'python')]
>>> bisect.insort(scores, (300, 'ruby'))
>>> scores
[(100, 'perl'), (200, 'tcl'), (300, 'ruby'), (400, 'lua'), (500, 'python')]
The heapq module provides functions for implementing heaps based on regular lists. The lowest valued entry
is always kept at position zero. This is useful for applications which repeatedly access the smallest element
but do not want to run a full list sort:
>>> from heapq import heapify, heappop, heappush
>>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
>>> heapify(data) # rearrange the list into heap order
>>> heappush(data, -5) # add a new entry
>>> [heappop(data) for i in range(3)] # fetch the three smallest entries
[-5, 0, 1]
11.8 Decimal Floating Point Arithmetic
The decimal module offers a Decimal datatype for decimal floating point arithmetic. Compared to the
built-in float implementation of binary floating point, the class is especially helpful for
• financial applications and other uses which require exact decimal representation,
• control over precision,
• control over rounding to meet legal or regulatory requirements,
• tracking of significant decimal places, or
• applications where the user expects the results to match calculations done by hand.
For example, calculating a 5% tax on a 70 cent phone charge gives different results in decimal floating point
and binary floating point. The difference becomes significant if the results are rounded to the nearest cent:
>>> from decimal import *
>>> round(Decimal('0.70') * Decimal('1.05'), 2)
Decimal('0.74')
>>> round(.70 * 1.05, 2)
0.73
94 Chapter 11. Brief Tour of the Standard Library — Part II
Python Tutorial, Release 3.7.0
The Decimal result keeps a trailing zero, automatically inferring four place significance from multiplicands
with two place significance. Decimal reproduces mathematics as done by hand and avoids issues that can
arise when binary floating point cannot exactly represent decimal quantities.
Exact representation enables the Decimal class to perform modulo calculations and equality tests that are
unsuitable for binary floating point:
>>> Decimal('1.00') % Decimal('.10')
Decimal('0.00')
>>> 1.00 % 0.10
0.09999999999999995
>>> sum([Decimal('0.1')]*10) == Decimal('1.0')
True
>>> sum([0.1]*10) == 1.0
False
The decimal module provides arithmetic with as much precision as needed:
>>> getcontext().prec = 36
>>> Decimal(1) / Decimal(7)
Decimal('0.142857142857142857142857142857142857')
11.8. Decimal Floating Point Arithmetic 95
Python Tutorial, Release 3.7.0
96 Chapter 11. Brief Tour of the Standard Library — Part II
CHAPTER
TWELVE
VIRTUAL ENVIRONMENTS AND PACKAGES
12.1 Introduction
Python applications will often use packages and modules that don’t come as part of the standard library.
Applications will sometimes need a specific version of a library, because the application may require that a
particular bug has been fixed or the application may be written using an obsolete version of the library’s
interface.
This means it may not be possible for one Python installation to meet the requirements of every application.
If application A needs version 1.0 of a particular module but application B needs version 2.0, then the
requirements are in conflict and installing either version 1.0 or 2.0 will leave one application unable to run.
The solution for this problem is to create a virtual environment, a self-contained directory tree that contains
a Python installation for a particular version of Python, plus a number of additional packages.
Different applications can then use different virtual environments. To resolve the earlier example of conflicting
requirements, application A can have its own virtual environment with version 1.0 installed while application
B has another virtual environment with version 2.0. If application B requires a library be upgraded to version
3.0, this will not affect application A’s environment.
12.2 Creating Virtual Environments
The module used to create and manage virtual environments is called venv. venv will usually install the
most recent version of Python that you have available. If you have multiple versions of Python on your
system, you can select a specific Python version by running python3 or whichever version you want.
To create a virtual environment, decide upon a directory where you want to place it, and run the venv
module as a script with the directory path:
python3 -m venv tutorial-env
This will create the tutorial-env directory if it doesn’t exist, and also create directories inside it containing
a copy of the Python interpreter, the standard library, and various supporting files.
Once you’ve created a virtual environment, you may activate it.
On Windows, run:
tutorial-env\Scripts\activate.bat
On Unix or MacOS, run:
source tutorial-env/bin/activate
97
Python Tutorial, Release 3.7.0
(This script is written for the bash shell. If you use the csh or fish shells, there are alternate activate.csh
and activate.fish scripts you should use instead.)
Activating the virtual environment will change your shell’s prompt to show what virtual environment you’re
using, and modify the environment so that running python will get you that particular version and installation of Python. For example:
$ source ~/envs/tutorial-env/bin/activate
(tutorial-env) $ python
Python 3.5.1 (default, May 6 2016, 10:59:36)
...
>>> import sys
>>> sys.path
['', '/usr/local/lib/python35.zip', ...,
'~/envs/tutorial-env/lib/python3.5/site-packages']
>>>
12.3 Managing Packages with pip
You can install, upgrade, and remove packages using a program called pip. By default pip will install
packages from the Python Package Index, <https://pypi.org>. You can browse the Python Package Index
by going to it in your web browser, or you can use pip’s limited search feature:
(tutorial-env) $ pip search astronomy
skyfield - Elegant astronomy for Python
gary - Galactic astronomy and gravitational dynamics.
novas - The United States Naval Observatory NOVAS astronomy library
astroobs - Provides astronomy ephemeris to plan telescope observations
PyAstronomy - A collection of astronomy related tools for Python.
...
pip has a number of subcommands: “search”, “install”, “uninstall”, “freeze”, etc. (Consult the installingindex guide for complete documentation for pip.)
You can install the latest version of a package by specifying a package’s name:
(tutorial-env) $ pip install novas
Collecting novas
Downloading novas-3.1.1.3.tar.gz (136kB)
Installing collected packages: novas
Running setup.py install for novas
Successfully installed novas-3.1.1.3
You can also install a specific version of a package by giving the package name followed by == and the version
number:
(tutorial-env) $ pip install requests==2.6.0
Collecting requests==2.6.0
Using cached requests-2.6.0-py2.py3-none-any.whl
Installing collected packages: requests
Successfully installed requests-2.6.0
If you re-run this command, pip will notice that the requested version is already installed and do nothing.
You can supply a different version number to get that version, or you can run pip install --upgrade to
upgrade the package to the latest version:
98 Chapter 12. Virtual Environments and Packages
Python Tutorial, Release 3.7.0
(tutorial-env) $ pip install --upgrade requests
Collecting requests
Installing collected packages: requests
Found existing installation: requests 2.6.0
Uninstalling requests-2.6.0:
Successfully uninstalled requests-2.6.0
Successfully installed requests-2.7.0
pip uninstall followed by one or more package names will remove the packages from the virtual environment.
pip show will display information about a particular package:
(tutorial-env) $ pip show requests
---
Metadata-Version: 2.0
Name: requests
Version: 2.7.0
Summary: Python HTTP for Humans.
Home-page: http://python-requests.org
Author: Kenneth Reitz
Author-email: me@kennethreitz.com
License: Apache 2.0
Location: /Users/akuchling/envs/tutorial-env/lib/python3.4/site-packages
Requires:
pip list will display all of the packages installed in the virtual environment:
(tutorial-env) $ pip list
novas (3.1.1.3)
numpy (1.9.2)
pip (7.0.3)
requests (2.7.0)
setuptools (16.0)
pip freeze will produce a similar list of the installed packages, but the output uses the format that pip
install expects. A common convention is to put this list in a requirements.txt file:
(tutorial-env) $ pip freeze > requirements.txt
(tutorial-env) $ cat requirements.txt
novas==3.1.1.3
numpy==1.9.2
requests==2.7.0
The requirements.txt can then be committed to version control and shipped as part of an application.
Users can then install all the necessary packages with install -r:
(tutorial-env) $ pip install -r requirements.txt
Collecting novas==3.1.1.3 (from -r requirements.txt (line 1))
...
Collecting numpy==1.9.2 (from -r requirements.txt (line 2))
...
Collecting requests==2.7.0 (from -r requirements.txt (line 3))
...
Installing collected packages: novas, numpy, requests
Running setup.py install for novas
Successfully installed novas-3.1.1.3 numpy-1.9.2 requests-2.7.0
12.3. Managing Packages with pip 99
Python Tutorial, Release 3.7.0
pip has many more options. Consult the installing-index guide for complete documentation for pip. When
you’ve written a package and want to make it available on the Python Package Index, consult the distributingindex guide.
100 Chapter 12. Virtual Environments and Packages
CHAPTER
THIRTEEN
WHAT NOW?
Reading this tutorial has probably reinforced your interest in using Python — you should be eager to apply
Python to solving your real-world problems. Where should you go to learn more?
This tutorial is part of Python’s documentation set. Some other documents in the set are:
• library-index:
You should browse through this manual, which gives complete (though terse) reference material about
types, functions, and the modules in the standard library. The standard Python distribution includes
a lot of additional code. There are modules to read Unix mailboxes, retrieve documents via HTTP,
generate random numbers, parse command-line options, write CGI programs, compress data, and many
other tasks. Skimming through the Library Reference will give you an idea of what’s available.
• installing-index explains how to install additional modules written by other Python users.
• reference-index: A detailed explanation of Python’s syntax and semantics. It’s heavy reading, but is
useful as a complete guide to the language itself.
More Python resources:
• https://www.python.org: The major Python Web site. It contains code, documentation, and pointers
to Python-related pages around the Web. This Web site is mirrored in various places around the world,
such as Europe, Japan, and Australia; a mirror may be faster than the main site, depending on your
geographical location.
• https://docs.python.org: Fast access to Python’s documentation.
• https://pypi.org: The Python Package Index, previously also nicknamed the Cheese Shop, is an index
of user-created Python modules that are available for download. Once you begin releasing code, you
can register it here so that others can find it.
• https://code.activestate.com/recipes/langs/python/: The Python Cookbook is a sizable collection of
code examples, larger modules, and useful scripts. Particularly notable contributions are collected in
a book also titled Python Cookbook (O’Reilly & Associates, ISBN 0-596-00797-3.)
• http://www.pyvideo.org collects links to Python-related videos from conferences and user-group meetings.
• https://scipy.org: The Scientific Python project includes modules for fast array computations and
manipulations plus a host of packages for such things as linear algebra, Fourier transforms, non-linear
solvers, random number distributions, statistical analysis and the like.
For Python-related questions and problem reports, you can post to the newsgroup comp.lang.python, or
send them to the mailing list at python-list@python.org. The newsgroup and mailing list are gatewayed,
so messages posted to one will automatically be forwarded to the other. There are hundreds of postings a
day, asking (and answering) questions, suggesting new features, and announcing new modules. Mailing list
archives are available at https://mail.python.org/pipermail/.
101
Python Tutorial, Release 3.7.0
Before posting, be sure to check the list of Frequently Asked Questions (also called the FAQ). The FAQ
answers many of the questions that come up again and again, and may already contain the solution for your
problem.
102 Chapter 13. What Now?
CHAPTER
FOURTEEN
INTERACTIVE INPUT EDITING AND HISTORY SUBSTITUTION
Some versions of the Python interpreter support editing of the current input line and history substitution,
similar to facilities found in the Korn shell and the GNU Bash shell. This is implemented using the GNU
Readline library, which supports various styles of editing. This library has its own documentation which we
won’t duplicate here.
14.1 Tab Completion and History Editing
Completion of variable and module names is automatically enabled at interpreter startup so that the Tab
key invokes the completion function; it looks at Python statement names, the current local variables, and
the available module names. For dotted expressions such as string.a, it will evaluate the expression up to
the final '.' and then suggest completions from the attributes of the resulting object. Note that this may
execute application-defined code if an object with a __getattr__() method is part of the expression. The
default configuration also saves your history into a file named .python_history in your user directory. The
history will be available again during the next interactive interpreter session.
14.2 Alternatives to the Interactive Interpreter
This facility is an enormous step forward compared to earlier versions of the interpreter; however, some
wishes are left: It would be nice if the proper indentation were suggested on continuation lines (the parser
knows if an indent token is required next). The completion mechanism might use the interpreter’s symbol
table. A command to check (or even suggest) matching parentheses, quotes, etc., would also be useful.
One alternative enhanced interactive interpreter that has been around for quite some time is IPython, which
features tab completion, object exploration and advanced history management. It can also be thoroughly
customized and embedded into other applications. Another similar enhanced interactive environment is
bpython.
103
Python Tutorial, Release 3.7.0
104 Chapter 14. Interactive Input Editing and History Substitution
CHAPTER
FIFTEEN
FLOATING POINT ARITHMETIC: ISSUES AND LIMITATIONS
Floating-point numbers are represented in computer hardware as base 2 (binary) fractions. For example,
the decimal fraction
0.125
has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction
0.001
has value 0/2 + 0/4 + 1/8. These two fractions have identical values, the only real difference being that the
first is written in base 10 fractional notation, and the second in base 2.
Unfortunately, most decimal fractions cannot be represented exactly as binary fractions. A consequence is
that, in general, the decimal floating-point numbers you enter are only approximated by the binary floatingpoint numbers actually stored in the machine.
The problem is easier to understand at first in base 10. Consider the fraction 1/3. You can approximate
that as a base 10 fraction:
0.3
or, better,
0.33
or, better,
0.333
and so on. No matter how many digits you’re willing to write down, the result will never be exactly 1/3,
but will be an increasingly better approximation of 1/3.
In the same way, no matter how many base 2 digits you’re willing to use, the decimal value 0.1 cannot be
represented exactly as a base 2 fraction. In base 2, 1/10 is the infinitely repeating fraction
0.0001100110011001100110011001100110011001100110011...
Stop at any finite number of bits, and you get an approximation. On most machines today, floats are
approximated using a binary fraction with the numerator using the first 53 bits starting with the most
significant bit and with the denominator as a power of two. In the case of 1/10, the binary fraction is
3602879701896397 / 2 ** 55 which is close to but not exactly equal to the true value of 1/10.
Many users are not aware of the approximation because of the way values are displayed. Python only prints
a decimal approximation to the true decimal value of the binary approximation stored by the machine. On
most machines, if Python were to print the true decimal value of the binary approximation stored for 0.1, it
would have to display
105
Python Tutorial, Release 3.7.0
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
That is more digits than most people find useful, so Python keeps the number of digits manageable by
displaying a rounded value instead
>>> 1 / 10
0.1
Just remember, even though the printed result looks like the exact value of 1/10, the actual stored value is
the nearest representable binary fraction.
Interestingly, there are many different decimal numbers that share the same nearest approximate binary fraction. For example, the numbers 0.1 and 0.10000000000000001 and
0.1000000000000000055511151231257827021181583404541015625 are all approximated by
3602879701896397 / 2 ** 55. Since all of these decimal values share the same approximation,
any one of them could be displayed while still preserving the invariant eval(repr(x)) == x.
Historically, the Python prompt and built-in repr() function would choose the one with 17 significant
digits, 0.10000000000000001. Starting with Python 3.1, Python (on most systems) is now able to choose
the shortest of these and simply display 0.1.
Note that this is in the very nature of binary floating-point: this is not a bug in Python, and it is not a
bug in your code either. You’ll see the same kind of thing in all languages that support your hardware’s
floating-point arithmetic (although some languages may not display the difference by default, or in all output
modes).
For more pleasant output, you may wish to use string formatting to produce a limited number of significant
digits:
>>> format(math.pi, '.12g') # give 12 significant digits
'3.14159265359'
>>> format(math.pi, '.2f') # give 2 digits after the point
'3.14'
>>> repr(math.pi)
'3.141592653589793'
It’s important to realize that this is, in a real sense, an illusion: you’re simply rounding the display of the
true machine value.
One illusion may beget another. For example, since 0.1 is not exactly 1/10, summing three values of 0.1 may
not yield exactly 0.3, either:
>>> .1 + .1 + .1 == .3
False
Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 cannot get any closer to the exact
value of 3/10, then pre-rounding with round() function cannot help:
>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
False
Though the numbers cannot be made closer to their intended exact values, the round() function can be
useful for post-rounding so that results with inexact values become comparable to one another:
>>> round(.1 + .1 + .1, 10) == round(.3, 10)
True
106 Chapter 15. Floating Point Arithmetic: Issues and Limitations
Python Tutorial, Release 3.7.0
Binary floating-point arithmetic holds many surprises like this. The problem with “0.1” is explained in
precise detail below, in the “Representation Error” section. See The Perils of Floating Point for a more
complete account of other common surprises.
As that says near the end, “there are no easy answers.” Still, don’t be unduly wary of floating-point! The
errors in Python float operations are inherited from the floating-point hardware, and on most machines are
on the order of no more than 1 part in 2**53 per operation. That’s more than adequate for most tasks, but
you do need to keep in mind that it’s not decimal arithmetic and that every float operation can suffer a new
rounding error.
While pathological cases do exist, for most casual use of floating-point arithmetic you’ll see the result you
expect in the end if you simply round the display of your final results to the number of decimal digits you
expect. str() usually suffices, and for finer control see the str.format() method’s format specifiers in
formatstrings.
For use cases which require exact decimal representation, try using the decimal module which implements
decimal arithmetic suitable for accounting applications and high-precision applications.
Another form of exact arithmetic is supported by the fractions module which implements arithmetic based
on rational numbers (so the numbers like 1/3 can be represented exactly).
If you are a heavy user of floating point operations you should take a look at the Numerical Python package
and many other packages for mathematical and statistical operations supplied by the SciPy project. See
<https://scipy.org>.
Python provides tools that may help on those rare occasions when you really do want to know the exact
value of a float. The float.as_integer_ratio() method expresses the value of a float as a fraction:
>>> x = 3.14159
>>> x.as_integer_ratio()
(3537115888337719, 1125899906842624)
Since the ratio is exact, it can be used to losslessly recreate the original value:
>>> x == 3537115888337719 / 1125899906842624
True
The float.hex() method expresses a float in hexadecimal (base 16), again giving the exact value stored by
your computer:
>>> x.hex()
'0x1.921f9f01b866ep+1'
This precise hexadecimal representation can be used to reconstruct the float value exactly:
>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True
Since the representation is exact, it is useful for reliably porting values across different versions of Python
(platform independence) and exchanging data with other languages that support the same format (such as
Java and C99).
Another helpful tool is the math.fsum() function which helps mitigate loss-of-precision during summation.
It tracks “lost digits” as values are added onto a running total. That can make a difference in overall accuracy
so that the errors do not accumulate to the point where they affect the final total:
>>> sum([0.1] * 10) == 1.0
False
>>> math.fsum([0.1] * 10) == 1.0
True
107
Python Tutorial, Release 3.7.0
15.1 Representation Error
This section explains the “0.1” example in detail, and shows how you can perform an exact analysis of cases
like this yourself. Basic familiarity with binary floating-point representation is assumed.
Representation error refers to the fact that some (most, actually) decimal fractions cannot be represented
exactly as binary (base 2) fractions. This is the chief reason why Python (or Perl, C, C++, Java, Fortran,
and many others) often won’t display the exact decimal number you expect.
Why is that? 1/10 is not exactly representable as a binary fraction. Almost all machines today (November
2000) use IEEE-754 floating point arithmetic, and almost all platforms map Python floats to IEEE-754
“double precision”. 754 doubles contain 53 bits of precision, so on input the computer strives to convert 0.1
to the closest fraction it can of the form J/2**N where J is an integer containing exactly 53 bits. Rewriting
1 / 10 ~= J / (2**N)
as
J ~= 2**N / 10
and recalling that J has exactly 53 bits (is >= 2**52 but < 2**53), the best value for N is 56:
>>> 2**52 <= 2**56 // 10 < 2**53
True
That is, 56 is the only value for N that leaves J with exactly 53 bits. The best possible value for J is then
that quotient rounded:
>>> q, r = divmod(2**56, 10)
>>> r
6
Since the remainder is more than half of 10, the best approximation is obtained by rounding up:
>>> q+1
7205759403792794
Therefore the best possible approximation to 1/10 in 754 double precision is:
7205759403792794 / 2 ** 56
Dividing both the numerator and denominator by two reduces the fraction to:
3602879701896397 / 2 ** 55
Note that since we rounded up, this is actually a little bit larger than 1/10; if we had not rounded up, the
quotient would have been a little bit smaller than 1/10. But in no case can it be exactly 1/10!
So the computer never “sees” 1/10: what it sees is the exact fraction given above, the best 754 double
approximation it can get:
>>> 0.1 * 2 ** 55
3602879701896397.0
If we multiply that fraction by 10**55, we can see the value out to 55 decimal digits:
>>> 3602879701896397 * 10 ** 55 // 2 ** 55
1000000000000000055511151231257827021181583404541015625
108 Chapter 15. Floating Point Arithmetic: Issues and Limitations
Python Tutorial, Release 3.7.0
meaning that the exact number stored in the computer is equal to the decimal value
0.1000000000000000055511151231257827021181583404541015625. Instead of displaying the full decimal
value, many languages (including older versions of Python), round the result to 17 significant digits:
>>> format(0.1, '.17f')
'0.10000000000000001'
The fractions and decimal modules make these calculations easy:
>>> from decimal import Decimal
>>> from fractions import Fraction
>>> Fraction.from_float(0.1)
Fraction(3602879701896397, 36028797018963968)
>>> (0.1).as_integer_ratio()
(3602879701896397, 36028797018963968)
>>> Decimal.from_float(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')
>>> format(Decimal.from_float(0.1), '.17')
'0.10000000000000001'
15.1. Representation Error 109
Python Tutorial, Release 3.7.0
110 Chapter 15. Floating Point Arithmetic: Issues and Limitations
CHAPTER
SIXTEEN
APPENDIX
16.1 Interactive Mode
16.1.1 Error Handling
When an error occurs, the interpreter prints an error message and a stack trace. In interactive mode, it
then returns to the primary prompt; when input came from a file, it exits with a nonzero exit status after
printing the stack trace. (Exceptions handled by an except clause in a try statement are not errors in this
context.) Some errors are unconditionally fatal and cause an exit with a nonzero exit; this applies to internal
inconsistencies and some cases of running out of memory. All error messages are written to the standard
error stream; normal output from executed commands is written to standard output.
Typing the interrupt character (usually Control-C or Delete) to the primary or secondary prompt cancels
the input and returns to the primary prompt.1 Typing an interrupt while a command is executing raises
the KeyboardInterrupt exception, which may be handled by a try statement.
16.1.2 Executable Python Scripts
On BSD’ish Unix systems, Python scripts can be made directly executable, like shell scripts, by putting the
line
#!/usr/bin/env python3.5
(assuming that the interpreter is on the user’s PATH) at the beginning of the script and giving the file an
executable mode. The #! must be the first two characters of the file. On some platforms, this first line
must end with a Unix-style line ending ('\n'), not a Windows ('\r\n') line ending. Note that the hash, or
pound, character, '#', is used to start a comment in Python.
The script can be given an executable mode, or permission, using the chmod command.
$ chmod +x myscript.py
On Windows systems, there is no notion of an “executable mode”. The Python installer automatically
associates .py files with python.exe so that a double-click on a Python file will run it as a script. The
extension can also be .pyw, in that case, the console window that normally appears is suppressed.
16.1.3 The Interactive Startup File
When you use Python interactively, it is frequently handy to have some standard commands executed every
time the interpreter is started. You can do this by setting an environment variable named PYTHONSTARTUP
1 A problem with the GNU Readline package may prevent this.
111
Python Tutorial, Release 3.7.0
to the name of a file containing your start-up commands. This is similar to the .profile feature of the Unix
shells.
This file is only read in interactive sessions, not when Python reads commands from a script, and not when
/dev/tty is given as the explicit source of commands (which otherwise behaves like an interactive session). It
is executed in the same namespace where interactive commands are executed, so that objects that it defines
or imports can be used without qualification in the interactive session. You can also change the prompts
sys.ps1 and sys.ps2 in this file.
If you want to read an additional start-up file from the current directory, you can program this in the
global start-up file using code like if os.path.isfile('.pythonrc.py'): exec(open('.pythonrc.py').
read()). If you want to use the startup file in a script, you must do this explicitly in the script:
import os
filename = os.environ.get('PYTHONSTARTUP')
if filename and os.path.isfile(filename):
with open(filename) as fobj:
startup_file = fobj.read()
exec(startup_file)
16.1.4 The Customization Modules
Python provides two hooks to let you customize it: sitecustomize and usercustomize. To see how it
works, you need first to find the location of your user site-packages directory. Start Python and run this
code:
>>> import site
>>> site.getusersitepackages()
'/home/user/.local/lib/python3.5/site-packages'
Now you can create a file named usercustomize.py in that directory and put anything you want in it. It
will affect every invocation of Python, unless it is started with the -s option to disable the automatic import.
sitecustomize works in the same way, but is typically created by an administrator of the computer in the
global site-packages directory, and is imported before usercustomize. See the documentation of the site
module for more details.
112 Chapter 16. Appendix
APPENDIX
A
GLOSSARY
>>> The default Python prompt of the interactive shell. Often seen for code examples which can be executed
interactively in the interpreter.
... The default Python prompt of the interactive shell when entering code for an indented code block, when
within a pair of matching left and right delimiters (parentheses, square brackets, curly braces or triple
quotes), or after specifying a decorator.
2to3 A tool that tries to convert Python 2.x code to Python 3.x code by handling most of the incompatibilities which can be detected by parsing the source and traversing the parse tree.
2to3 is available in the standard library as lib2to3; a standalone entry point is provided as Tools/
scripts/2to3. See 2to3-reference.
abstract base class Abstract base classes complement duck-typing by providing a way to define interfaces
when other techniques like hasattr() would be clumsy or subtly wrong (for example with magic
methods). ABCs introduce virtual subclasses, which are classes that don’t inherit from a class but
are still recognized by isinstance() and issubclass(); see the abc module documentation. Python
comes with many built-in ABCs for data structures (in the collections.abc module), numbers (in
the numbers module), streams (in the io module), import finders and loaders (in the importlib.abc
module). You can create your own ABCs with the abc module.
annotation A label associated with a variable, a class attribute or a function parameter or return value,
used by convention as a type hint.
Annotations of local variables cannot be accessed at runtime, but annotations of global variables, class
attributes, and functions are stored in the __annotations__ special attribute of modules, classes, and
functions, respectively.
See variable annotation, function annotation, PEP 484 and PEP 526, which describe this functionality.
argument A value passed to a function (or method) when calling the function. There are two kinds of
argument:
• keyword argument: an argument preceded by an identifier (e.g. name=) in a function call or passed
as a value in a dictionary preceded by **. For example, 3 and 5 are both keyword arguments in
the following calls to complex():
complex(real=3, imag=5)
complex(**{'real': 3, 'imag': 5})
• positional argument: an argument that is not a keyword argument. Positional arguments can
appear at the beginning of an argument list and/or be passed as elements of an iterable preceded
by *. For example, 3 and 5 are both positional arguments in the following calls:
complex(3, 5)
complex(*(3, 5))
113
Python Tutorial, Release 3.7.0
Arguments are assigned to the named local variables in a function body. See the calls section for the
rules governing this assignment. Syntactically, any expression can be used to represent an argument;
the evaluated value is assigned to the local variable.
See also the parameter glossary entry, the FAQ question on the difference between arguments and
parameters, and PEP 362.
asynchronous context manager An object which controls the environment seen in an async with statement by defining __aenter__() and __aexit__() methods. Introduced by PEP 492.
asynchronous generator A function which returns an asynchronous generator iterator. It looks like a
coroutine function defined with async def except that it contains yield expressions for producing a
series of values usable in an async for loop.
Usually refers to a asynchronous generator function, but may refer to an asynchronous generator
iterator in some contexts. In cases where the intended meaning isn’t clear, using the full terms avoids
ambiguity.
An asynchronous generator function may contain await expressions as well as async for, and async
with statements.
asynchronous generator iterator An object created by a asynchronous generator function.
This is an asynchronous iterator which when called using the __anext__() method returns an awaitable
object which will execute that the body of the asynchronous generator function until the next yield
expression.
Each yield temporarily suspends processing, remembering the location execution state (including local
variables and pending try-statements). When the asynchronous generator iterator effectively resumes
with another awaitable returned by __anext__(), it picks up where it left off. See PEP 492 and PEP
525.
asynchronous iterable An object, that can be used in an async for statement. Must return an asynchronous iterator from its __aiter__() method. Introduced by PEP 492.
asynchronous iterator An object that implements the __aiter__() and __anext__() methods.
__anext__ must return an awaitable object. async for resolves the awaitables returned by an asynchronous iterator’s __anext__() method until it raises a StopAsyncIteration exception. Introduced
by PEP 492.
attribute A value associated with an object which is referenced by name using dotted expressions. For
example, if an object o has an attribute a it would be referenced as o.a.
awaitable An object that can be used in an await expression. Can be a coroutine or an object with an
__await__() method. See also PEP 492.
BDFL Benevolent Dictator For Life, a.k.a. Guido van Rossum, Python’s creator.
binary file A file object able to read and write bytes-like objects. Examples of binary files are files opened
in binary mode ('rb', 'wb' or 'rb+'), sys.stdin.buffer, sys.stdout.buffer, and instances of
io.BytesIO and gzip.GzipFile.
See also text file for a file object able to read and write str objects.
bytes-like object An object that supports the bufferobjects and can export a C-contiguous buffer. This
includes all bytes, bytearray, and array.array objects, as well as many common memoryview objects. Bytes-like objects can be used for various operations that work with binary data; these include
compression, saving to a binary file, and sending over a socket.
Some operations need the binary data to be mutable. The documentation often refers to these as “readwrite bytes-like objects”. Example mutable buffer objects include bytearray and a memoryview of a
bytearray. Other operations require the binary data to be stored in immutable objects (“read-only
bytes-like objects”); examples of these include bytes and a memoryview of a bytes object.
114 Appendix A. Glossary
Python Tutorial, Release 3.7.0
bytecode Python source code is compiled into bytecode, the internal representation of a Python program
in the CPython interpreter. The bytecode is also cached in .pyc files so that executing the same file
is faster the second time (recompilation from source to bytecode can be avoided). This “intermediate
language” is said to run on a virtual machine that executes the machine code corresponding to each
bytecode. Do note that bytecodes are not expected to work between different Python virtual machines,
nor to be stable between Python releases.
A list of bytecode instructions can be found in the documentation for the dis module.
class A template for creating user-defined objects. Class definitions normally contain method definitions
which operate on instances of the class.
class variable A variable defined in a class and intended to be modified only at class level (i.e., not in an
instance of the class).
coercion The implicit conversion of an instance of one type to another during an operation which involves
two arguments of the same type. For example, int(3.15) converts the floating point number to the
integer 3, but in 3+4.5, each argument is of a different type (one int, one float), and both must be
converted to the same type before they can be added or it will raise a TypeError. Without coercion, all
arguments of even compatible types would have to be normalized to the same value by the programmer,
e.g., float(3)+4.5 rather than just 3+4.5.
complex number An extension of the familiar real number system in which all numbers are expressed as
a sum of a real part and an imaginary part. Imaginary numbers are real multiples of the imaginary
unit (the square root of -1), often written i in mathematics or j in engineering. Python has built-in
support for complex numbers, which are written with this latter notation; the imaginary part is written
with a j suffix, e.g., 3+1j. To get access to complex equivalents of the math module, use cmath. Use
of complex numbers is a fairly advanced mathematical feature. If you’re not aware of a need for them,
it’s almost certain you can safely ignore them.
context manager An object which controls the environment seen in a with statement by defining
__enter__() and __exit__() methods. See PEP 343.
contiguous A buffer is considered contiguous exactly if it is either C-contiguous or Fortran contiguous.
Zero-dimensional buffers are C and Fortran contiguous. In one-dimensional arrays, the items must
be laid out in memory next to each other, in order of increasing indexes starting from zero. In
multidimensional C-contiguous arrays, the last index varies the fastest when visiting items in order of
memory address. However, in Fortran contiguous arrays, the first index varies the fastest.
coroutine Coroutines is a more generalized form of subroutines. Subroutines are entered at one point and
exited at another point. Coroutines can be entered, exited, and resumed at many different points.
They can be implemented with the async def statement. See also PEP 492.
coroutine function A function which returns a coroutine object. A coroutine function may be defined
with the async def statement, and may contain await, async for, and async with keywords. These
were introduced by PEP 492.
CPython The canonical implementation of the Python programming language, as distributed on
python.org. The term “CPython” is used when necessary to distinguish this implementation from
others such as Jython or IronPython.
decorator A function returning another function, usually applied as a function transformation using the
@wrapper syntax. Common examples for decorators are classmethod() and staticmethod().
The decorator syntax is merely syntactic sugar, the following two function definitions are semantically
equivalent:
def f(...):
...
f = staticmethod(f)
(continues on next page)
115
Python Tutorial, Release 3.7.0
(continued from previous page)
@staticmethod
def f(...):
...
The same concept exists for classes, but is less commonly used there. See the documentation for
function definitions and class definitions for more about decorators.
descriptor Any object which defines the methods __get__(), __set__(), or __delete__(). When a class
attribute is a descriptor, its special binding behavior is triggered upon attribute lookup. Normally,
using a.b to get, set or delete an attribute looks up the object named b in the class dictionary for a, but
if b is a descriptor, the respective descriptor method gets called. Understanding descriptors is a key
to a deep understanding of Python because they are the basis for many features including functions,
methods, properties, class methods, static methods, and reference to super classes.
For more information about descriptors’ methods, see descriptors.
dictionary An associative array, where arbitrary keys are mapped to values. The keys can be any object
with __hash__() and __eq__() methods. Called a hash in Perl.
dictionary view The objects returned from dict.keys(), dict.values(), and dict.items() are called
dictionary views. They provide a dynamic view on the dictionary’s entries, which means that when
the dictionary changes, the view reflects these changes. To force the dictionary view to become a full
list use list(dictview). See dict-views.
docstring A string literal which appears as the first expression in a class, function or module. While ignored
when the suite is executed, it is recognized by the compiler and put into the __doc__ attribute of the
enclosing class, function or module. Since it is available via introspection, it is the canonical place for
documentation of the object.
duck-typing A programming style which does not look at an object’s type to determine if it has the right
interface; instead, the method or attribute is simply called or used (“If it looks like a duck and quacks
like a duck, it must be a duck.”) By emphasizing interfaces rather than specific types, well-designed
code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using
type() or isinstance(). (Note, however, that duck-typing can be complemented with abstract base
classes.) Instead, it typically employs hasattr() tests or EAFP programming.
EAFP Easier to ask for forgiveness than permission. This common Python coding style assumes the
existence of valid keys or attributes and catches exceptions if the assumption proves false. This clean
and fast style is characterized by the presence of many try and except statements. The technique
contrasts with the LBYL style common to many other languages such as C.
expression A piece of syntax which can be evaluated to some value. In other words, an expression is
an accumulation of expression elements like literals, names, attribute access, operators or function
calls which all return a value. In contrast to many other languages, not all language constructs are
expressions. There are also statements which cannot be used as expressions, such as if. Assignments
are also statements, not expressions.
extension module A module written in C or C++, using Python’s C API to interact with the core and
with user code.
f-string String literals prefixed with 'f' or 'F' are commonly called “f-strings” which is short for formatted
string literals. See also PEP 498.
file object An object exposing a file-oriented API (with methods such as read() or write()) to an underlying resource. Depending on the way it was created, a file object can mediate access to a real on-disk file
or to another type of storage or communication device (for example standard input/output, in-memory
buffers, sockets, pipes, etc.). File objects are also called file-like objects or streams.
There are actually three categories of file objects: raw binary files, buffered binary files and text files.
Their interfaces are defined in the io module. The canonical way to create a file object is by using the
116 Appendix A. Glossary
Python Tutorial, Release 3.7.0
open() function.
file-like object A synonym for file object.
finder An object that tries to find the loader for a module that is being imported.
Since Python 3.3, there are two types of finder: meta path finders for use with sys.meta_path, and
path entry finders for use with sys.path_hooks.
See PEP 302, PEP 420 and PEP 451 for much more detail.
floor division Mathematical division that rounds down to nearest integer. The floor division operator is
//. For example, the expression 11 // 4 evaluates to 2 in contrast to the 2.75 returned by float true
division. Note that (-11) // 4 is -3 because that is -2.75 rounded downward. See PEP 238.
function A series of statements which returns some value to a caller. It can also be passed zero or more
arguments which may be used in the execution of the body. See also parameter, method, and the
function section.
function annotation An annotation of a function parameter or return value.
Function annotations are usually used for type hints: for example this function is expected to take two
int arguments and is also expected to have an int return value:
def sum_two_numbers(a: int, b: int) -> int:
return a + b
Function annotation syntax is explained in section function.
See variable annotation and PEP 484, which describe this functionality.
__future__ A pseudo-module which programmers can use to enable new language features which are
not compatible with the current interpreter.
By importing the __future__ module and evaluating its variables, you can see when a new feature
was first added to the language and when it becomes the default:
>>> import __future__
>>> __future__.division
_Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)
garbage collection The process of freeing memory when it is not used anymore. Python performs garbage
collection via reference counting and a cyclic garbage collector that is able to detect and break reference
cycles. The garbage collector can be controlled using the gc module.
generator A function which returns a generator iterator. It looks like a normal function except that it
contains yield expressions for producing a series of values usable in a for-loop or that can be retrieved
one at a time with the next() function.
Usually refers to a generator function, but may refer to a generator iterator in some contexts. In cases
where the intended meaning isn’t clear, using the full terms avoids ambiguity.
generator iterator An object created by a generator function.
Each yield temporarily suspends processing, remembering the location execution state (including local
variables and pending try-statements). When the generator iterator resumes, it picks up where it left
off (in contrast to functions which start fresh on every invocation).
generator expression An expression that returns an iterator. It looks like a normal expression followed
by a for expression defining a loop variable, range, and an optional if expression. The combined
expression generates values for an enclosing function:
>>> sum(i*i for i in range(10)) # sum of squares 0, 1, 4, ... 81
285
117
Python Tutorial, Release 3.7.0
generic function A function composed of multiple functions implementing the same operation for different
types. Which implementation should be used during a call is determined by the dispatch algorithm.
See also the single dispatch glossary entry, the functools.singledispatch() decorator, and PEP
443.
GIL See global interpreter lock.
global interpreter lock The mechanism used by the CPython interpreter to assure that only one thread
executes Python bytecode at a time. This simplifies the CPython implementation by making the object
model (including critical built-in types such as dict) implicitly safe against concurrent access. Locking
the entire interpreter makes it easier for the interpreter to be multi-threaded, at the expense of much
of the parallelism afforded by multi-processor machines.
However, some extension modules, either standard or third-party, are designed so as to release the GIL
when doing computationally-intensive tasks such as compression or hashing. Also, the GIL is always
released when doing I/O.
Past efforts to create a “free-threaded” interpreter (one which locks shared data at a much finer
granularity) have not been successful because performance suffered in the common single-processor
case. It is believed that overcoming this performance issue would make the implementation much more
complicated and therefore costlier to maintain.
hash-based pyc A bytecode cache file that uses the hash rather than the last-modified time of the corresponding source file to determine its validity. See pyc-invalidation.
hashable An object is hashable if it has a hash value which never changes during its lifetime (it needs a
__hash__() method), and can be compared to other objects (it needs an __eq__() method). Hashable
objects which compare equal must have the same hash value.
Hashability makes an object usable as a dictionary key and a set member, because these data structures
use the hash value internally.
All of Python’s immutable built-in objects are hashable; mutable containers (such as lists or dictionaries) are not. Objects which are instances of user-defined classes are hashable by default. They all
compare unequal (except with themselves), and their hash value is derived from their id().
IDLE An Integrated Development Environment for Python. IDLE is a basic editor and interpreter environment which ships with the standard distribution of Python.
immutable An object with a fixed value. Immutable objects include numbers, strings and tuples. Such an
object cannot be altered. A new object has to be created if a different value has to be stored. They
play an important role in places where a constant hash value is needed, for example as a key in a
dictionary.
import path A list of locations (or path entries) that are searched by the path based finder for modules to
import. During import, this list of locations usually comes from sys.path, but for subpackages it may
also come from the parent package’s __path__ attribute.
importing The process by which Python code in one module is made available to Python code in another
module.
importer An object that both finds and loads a module; both a finder and loader object.
interactive Python has an interactive interpreter which means you can enter statements and expressions
at the interpreter prompt, immediately execute them and see their results. Just launch python with
no arguments (possibly by selecting it from your computer’s main menu). It is a very powerful way to
test out new ideas or inspect modules and packages (remember help(x)).
interpreted Python is an interpreted language, as opposed to a compiled one, though the distinction can
be blurry because of the presence of the bytecode compiler. This means that source files can be run
directly without explicitly creating an executable which is then run. Interpreted languages typically
118 Appendix A. Glossary
Python Tutorial, Release 3.7.0
have a shorter development/debug cycle than compiled ones, though their programs generally also run
more slowly. See also interactive.
interpreter shutdown When asked to shut down, the Python interpreter enters a special phase where it
gradually releases all allocated resources, such as modules and various critical internal structures. It
also makes several calls to the garbage collector. This can trigger the execution of code in user-defined
destructors or weakref callbacks. Code executed during the shutdown phase can encounter various
exceptions as the resources it relies on may not function anymore (common examples are library
modules or the warnings machinery).
The main reason for interpreter shutdown is that the __main__ module or the script being run has
finished executing.
iterable An object capable of returning its members one at a time. Examples of iterables include all
sequence types (such as list, str, and tuple) and some non-sequence types like dict, file objects,
and objects of any classes you define with an __iter__() method or with a __getitem__() method
that implements Sequence semantics.
Iterables can be used in a for loop and in many other places where a sequence is needed (zip(), map(),
…). When an iterable object is passed as an argument to the built-in function iter(), it returns an
iterator for the object. This iterator is good for one pass over the set of values. When using iterables,
it is usually not necessary to call iter() or deal with iterator objects yourself. The for statement
does that automatically for you, creating a temporary unnamed variable to hold the iterator for the
duration of the loop. See also iterator, sequence, and generator.
iterator An object representing a stream of data. Repeated calls to the iterator’s __next__() method
(or passing it to the built-in function next()) return successive items in the stream. When no more
data are available a StopIteration exception is raised instead. At this point, the iterator object is
exhausted and any further calls to its __next__() method just raise StopIteration again. Iterators
are required to have an __iter__() method that returns the iterator object itself so every iterator is
also iterable and may be used in most places where other iterables are accepted. One notable exception
is code which attempts multiple iteration passes. A container object (such as a list) produces a fresh
new iterator each time you pass it to the iter() function or use it in a for loop. Attempting this
with an iterator will just return the same exhausted iterator object used in the previous iteration pass,
making it appear like an empty container.
More information can be found in typeiter.
key function A key function or collation function is a callable that returns a value used for sorting or
ordering. For example, locale.strxfrm() is used to produce a sort key that is aware of locale specific
sort conventions.
A number of tools in Python accept key functions to control how elements are ordered or grouped.
They include min(), max(), sorted(), list.sort(), heapq.merge(), heapq.nsmallest(), heapq.
nlargest(), and itertools.groupby().
There are several ways to create a key function. For example. the str.lower() method can serve
as a key function for case insensitive sorts. Alternatively, a key function can be built from a lambda
expression such as lambda r: (r[0], r[2]). Also, the operator module provides three key function
constructors: attrgetter(), itemgetter(), and methodcaller(). See the Sorting HOW TO for
examples of how to create and use key functions.
keyword argument See argument.
lambda An anonymous inline function consisting of a single expression which is evaluated when the function
is called. The syntax to create a lambda function is lambda [parameters]: expression
LBYL Look before you leap. This coding style explicitly tests for pre-conditions before making calls or
lookups. This style contrasts with the EAFP approach and is characterized by the presence of many
if statements.
119
Python Tutorial, Release 3.7.0
In a multi-threaded environment, the LBYL approach can risk introducing a race condition between
“the looking” and “the leaping”. For example, the code, if key in mapping: return mapping[key]
can fail if another thread removes key from mapping after the test, but before the lookup. This issue
can be solved with locks or by using the EAFP approach.
list A built-in Python sequence. Despite its name it is more akin to an array in other languages than to a
linked list since access to elements is O(1).
list comprehension A compact way to process all or part of the elements in a sequence and return a list
with the results. result = ['{:#04x}'.format(x) for x in range(256) if x % 2 == 0] generates
a list of strings containing even hex numbers (0x..) in the range from 0 to 255. The if clause is
optional. If omitted, all elements in range(256) are processed.
loader An object that loads a module. It must define a method named load_module(). A loader is typically
returned by a finder. See PEP 302 for details and importlib.abc.Loader for an abstract base class.
mapping A container object that supports arbitrary key lookups and implements the methods specified
in the Mapping or MutableMapping abstract base classes. Examples include dict, collections.
defaultdict, collections.OrderedDict and collections.Counter.
meta path finder A finder returned by a search of sys.meta_path. Meta path finders are related to, but
different from path entry finders.
See importlib.abc.MetaPathFinder for the methods that meta path finders implement.
metaclass The class of a class. Class definitions create a class name, a class dictionary, and a list of base
classes. The metaclass is responsible for taking those three arguments and creating the class. Most
object oriented programming languages provide a default implementation. What makes Python special
is that it is possible to create custom metaclasses. Most users never need this tool, but when the need
arises, metaclasses can provide powerful, elegant solutions. They have been used for logging attribute
access, adding thread-safety, tracking object creation, implementing singletons, and many other tasks.
More information can be found in metaclasses.
method A function which is defined inside a class body. If called as an attribute of an instance of that
class, the method will get the instance object as its first argument (which is usually called self). See
function and nested scope.
method resolution order Method Resolution Order is the order in which base classes are searched for
a member during lookup. See The Python 2.3 Method Resolution Order for details of the algorithm
used by the Python interpreter since the 2.3 release.
module An object that serves as an organizational unit of Python code. Modules have a namespace
containing arbitrary Python objects. Modules are loaded into Python by the process of importing.
See also package.
module spec A namespace containing the import-related information used to load a module. An instance
of importlib.machinery.ModuleSpec.
MRO See method resolution order.
mutable Mutable objects can change their value but keep their id(). See also immutable.
named tuple Any tuple-like class whose indexable elements are also accessible using named attributes (for
example, time.localtime() returns a tuple-like object where the year is accessible either with an
index such as t[0] or with a named attribute like t.tm_year).
A named tuple can be a built-in type such as time.struct_time, or it can be created with a regular
class definition. A full featured named tuple can also be created with the factory function collections.
namedtuple(). The latter approach automatically provides extra features such as a self-documenting
representation like Employee(name='jones', title='programmer').
120 Appendix A. Glossary
Python Tutorial, Release 3.7.0
namespace The place where a variable is stored. Namespaces are implemented as dictionaries. There
are the local, global and built-in namespaces as well as nested namespaces in objects (in methods).
Namespaces support modularity by preventing naming conflicts. For instance, the functions builtins.
open and os.open() are distinguished by their namespaces. Namespaces also aid readability and
maintainability by making it clear which module implements a function. For instance, writing random.
seed() or itertools.islice() makes it clear that those functions are implemented by the random
and itertools modules, respectively.
namespace package A PEP 420 package which serves only as a container for subpackages. Namespace
packages may have no physical representation, and specifically are not like a regular package because
they have no __init__.py file.
See also module.
nested scope The ability to refer to a variable in an enclosing definition. For instance, a function defined
inside another function can refer to variables in the outer function. Note that nested scopes by default
work only for reference and not for assignment. Local variables both read and write in the innermost
scope. Likewise, global variables read and write to the global namespace. The nonlocal allows writing
to outer scopes.
new-style class Old name for the flavor of classes now used for all class objects. In earlier Python versions, only new-style classes could use Python’s newer, versatile features like __slots__, descriptors,
properties, __getattribute__(), class methods, and static methods.
object Any data with state (attributes or value) and defined behavior (methods). Also the ultimate base
class of any new-style class.
package A Python module which can contain submodules or recursively, subpackages. Technically, a package is a Python module with an __path__ attribute.
See also regular package and namespace package.
parameter A named entity in a function (or method) definition that specifies an argument (or in some
cases, arguments) that the function can accept. There are five kinds of parameter:
• positional-or-keyword: specifies an argument that can be passed either positionally or as a keyword
argument. This is the default kind of parameter, for example foo and bar in the following:
def func(foo, bar=None): ...
• positional-only: specifies an argument that can be supplied only by position. Python has no
syntax for defining positional-only parameters. However, some built-in functions have positionalonly parameters (e.g. abs()).
• keyword-only: specifies an argument that can be supplied only by keyword. Keyword-only parameters can be defined by including a single var-positional parameter or bare * in the parameter
list of the function definition before them, for example kw_only1 and kw_only2 in the following:
def func(arg, *, kw_only1, kw_only2): ...
• var-positional: specifies that an arbitrary sequence of positional arguments can be provided (in
addition to any positional arguments already accepted by other parameters). Such a parameter
can be defined by prepending the parameter name with *, for example args in the following:
def func(*args, **kwargs): ...
• var-keyword: specifies that arbitrarily many keyword arguments can be provided (in addition to
any keyword arguments already accepted by other parameters). Such a parameter can be defined
by prepending the parameter name with **, for example kwargs in the example above.
Parameters can specify both optional and required arguments, as well as default values for some
optional arguments.
121
Python Tutorial, Release 3.7.0
See also the argument glossary entry, the FAQ question on the difference between arguments and
parameters, the inspect.Parameter class, the function section, and PEP 362.
path entry A single location on the import path which the path based finder consults to find modules for
importing.
path entry finder A finder returned by a callable on sys.path_hooks (i.e. a path entry hook) which knows
how to locate modules given a path entry.
See importlib.abc.PathEntryFinder for the methods that path entry finders implement.
path entry hook A callable on the sys.path_hook list which returns a path entry finder if it knows how
to find modules on a specific path entry.
path based finder One of the default meta path finders which searches an import path for modules.
path-like object An object representing a file system path. A path-like object is either a str or bytes
object representing a path, or an object implementing the os.PathLike protocol. An object that
supports the os.PathLike protocol can be converted to a str or bytes file system path by calling the
os.fspath() function; os.fsdecode() and os.fsencode() can be used to guarantee a str or bytes
result instead, respectively. Introduced by PEP 519.
PEP Python Enhancement Proposal. A PEP is a design document providing information to the Python
community, or describing a new feature for Python or its processes or environment. PEPs should
provide a concise technical specification and a rationale for proposed features.
PEPs are intended to be the primary mechanisms for proposing major new features, for collecting community input on an issue, and for documenting the design decisions that have gone into Python. The
PEP author is responsible for building consensus within the community and documenting dissenting
opinions.
See PEP 1.
portion A set of files in a single directory (possibly stored in a zip file) that contribute to a namespace
package, as defined in PEP 420.
positional argument See argument.
provisional API A provisional API is one which has been deliberately excluded from the standard library’s
backwards compatibility guarantees. While major changes to such interfaces are not expected, as long
as they are marked provisional, backwards incompatible changes (up to and including removal of
the interface) may occur if deemed necessary by core developers. Such changes will not be made
gratuitously – they will occur only if serious fundamental flaws are uncovered that were missed prior
to the inclusion of the API.
Even for provisional APIs, backwards incompatible changes are seen as a “solution of last resort” -
every attempt will still be made to find a backwards compatible resolution to any identified problems.
This process allows the standard library to continue to evolve over time, without locking in problematic
design errors for extended periods of time. See PEP 411 for more details.
provisional package See provisional API.
Python 3000 Nickname for the Python 3.x release line (coined long ago when the release of version 3 was
something in the distant future.) This is also abbreviated “Py3k”.
Pythonic An idea or piece of code which closely follows the most common idioms of the Python language,
rather than implementing code using concepts common to other languages. For example, a common
idiom in Python is to loop over all elements of an iterable using a for statement. Many other languages
don’t have this type of construct, so people unfamiliar with Python sometimes use a numerical counter
instead:
for i in range(len(food)):
print(food[i])
122 Appendix A. Glossary
Python Tutorial, Release 3.7.0
As opposed to the cleaner, Pythonic method:
for piece in food:
print(piece)
qualified name A dotted name showing the “path” from a module’s global scope to a class, function or
method defined in that module, as defined in PEP 3155. For top-level functions and classes, the
qualified name is the same as the object’s name:
>>> class C:
... class D:
... def meth(self):
... pass
...
>>> C.__qualname__
'C'
>>> C.D.__qualname__
'C.D'
>>> C.D.meth.__qualname__
'C.D.meth'
When used to refer to modules, the fully qualified name means the entire dotted path to the module,
including any parent packages, e.g. email.mime.text:
>>> import email.mime.text
>>> email.mime.text.__name__
'email.mime.text'
reference count The number of references to an object. When the reference count of an object drops to
zero, it is deallocated. Reference counting is generally not visible to Python code, but it is a key element
of the CPython implementation. The sys module defines a getrefcount() function that programmers
can call to return the reference count for a particular object.
regular package A traditional package, such as a directory containing an __init__.py file.
See also namespace package.
__slots__ A declaration inside a class that saves memory by pre-declaring space for instance attributes
and eliminating instance dictionaries. Though popular, the technique is somewhat tricky to get right
and is best reserved for rare cases where there are large numbers of instances in a memory-critical
application.
sequence An iterable which supports efficient element access using integer indices via the __getitem__()
special method and defines a __len__() method that returns the length of the sequence. Some built-in
sequence types are list, str, tuple, and bytes. Note that dict also supports __getitem__() and
__len__(), but is considered a mapping rather than a sequence because the lookups use arbitrary
immutable keys rather than integers.
The collections.abc.Sequence abstract base class defines a much richer interface that goes
beyond just __getitem__() and __len__(), adding count(), index(), __contains__(), and
__reversed__(). Types that implement this expanded interface can be registered explicitly using
register().
single dispatch A form of generic function dispatch where the implementation is chosen based on the type
of a single argument.
slice An object usually containing a portion of a sequence. A slice is created using the subscript notation, []
with colons between numbers when several are given, such as in variable_name[1:3:5]. The bracket
(subscript) notation uses slice objects internally.
123
Python Tutorial, Release 3.7.0
special method A method that is called implicitly by Python to execute a certain operation on a type,
such as addition. Such methods have names starting and ending with double underscores. Special
methods are documented in specialnames.
statement A statement is part of a suite (a “block” of code). A statement is either an expression or one of
several constructs with a keyword, such as if, while or for.
struct sequence A tuple with named elements. Struct sequences expose an interface similar to named
tuple in that elements can either be accessed either by index or as an attribute. However, they do
not have any of the named tuple methods like _make() or _asdict(). Examples of struct sequences
include sys.float_info and the return value of os.stat().
text encoding A codec which encodes Unicode strings to bytes.
text file A file object able to read and write str objects. Often, a text file actually accesses a byte-oriented
datastream and handles the text encoding automatically. Examples of text files are files opened in text
mode ('r' or 'w'), sys.stdin, sys.stdout, and instances of io.StringIO.
See also binary file for a file object able to read and write bytes-like objects.
triple-quoted string A string which is bound by three instances of either a quotation mark (“) or an
apostrophe (‘). While they don’t provide any functionality not available with single-quoted strings,
they are useful for a number of reasons. They allow you to include unescaped single and double quotes
within a string and they can span multiple lines without the use of the continuation character, making
them especially useful when writing docstrings.
type The type of a Python object determines what kind of object it is; every object has a type. An object’s
type is accessible as its __class__ attribute or can be retrieved with type(obj).
type alias A synonym for a type, created by assigning the type to an identifier.
Type aliases are useful for simplifying type hints. For example:
from typing import List, Tuple
def remove_gray_shades(
colors: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int]]:
pass
could be made more readable like this:
from typing import List, Tuple
Color = Tuple[int, int, int]
def remove_gray_shades(colors: List[Color]) -> List[Color]:
pass
See typing and PEP 484, which describe this functionality.
type hint An annotation that specifies the expected type for a variable, a class attribute, or a function
parameter or return value.
Type hints are optional and are not enforced by Python but they are useful to static type analysis
tools, and aid IDEs with code completion and refactoring.
Type hints of global variables, class attributes, and functions, but not local variables, can be accessed
using typing.get_type_hints().
See typing and PEP 484, which describe this functionality.
universal newlines A manner of interpreting text streams in which all of the following are recognized as
ending a line: the Unix end-of-line convention '\n', the Windows convention '\r\n', and the old
124 Appendix A. Glossary
Python Tutorial, Release 3.7.0
Macintosh convention '\r'. See PEP 278 and PEP 3116, as well as bytes.splitlines() for an
additional use.
variable annotation An annotation of a variable or a class attribute.
When annotating a variable or a class attribute, assignment is optional:
class C:
field: 'annotation'
Variable annotations are usually used for type hints: for example this variable is expected to take int
values:
count: int = 0
Variable annotation syntax is explained in section annassign.
See function annotation, PEP 484 and PEP 526, which describe this functionality.
virtual environment A cooperatively isolated runtime environment that allows Python users and applications to install and upgrade Python distribution packages without interfering with the behaviour of
other Python applications running on the same system.
See also venv.
virtual machine A computer defined entirely in software. Python’s virtual machine executes the bytecode
emitted by the bytecode compiler.
Zen of Python Listing of Python design principles and philosophies that are helpful in understanding and
using the language. The listing can be found by typing “import this” at the interactive prompt.

Python 3
i
About the Tutorial
Python is a general-purpose interpreted, interactive, object-oriented, and high-level
programming language. It was created by Guido van Rossum during 1985 – 1990. Like
Perl, Python source code is also available under the GNU General Public License (GPL).
Python is named after a TV Show called ‘Monty Python’s Flying Circus’ and not after
Python-the snake.
Python 3.0 was released in 2008. Although this version is supposed to be backward
incompatibles, later on many of its important features have been backported to be
compatible with the version 2.7. This tutorial gives enough understanding on Python 3
version programming language. Please refer to this link for our Python 2 tutorial.
Audience
This tutorial is designed for software programmers who want to upgrade their Python skills
to Python 3. This tutorial can also be used to learn Python programming language from
scratch.
Prerequisites
You should have a basic understanding of Computer Programming terminologies. A basic
understanding of any of the programming languages is a plus.
Execute Python Programs
For most of the examples given in this tutorial you will find Try it option, so just make use
of it and enjoy your learning.
Try the following example using Try it option available at the top right corner of the below
sample code box −
#!/usr/bin/python3
print ("Hello, Python!")
Copyright & Disclaimer
 Copyright 2016 by Tutorials Point (I) Pvt. Ltd.
All the content and graphics published in this e-book are the property of Tutorials Point (I)
Pvt. Ltd. The user of this e-book is prohibited to reuse, retain, copy, distribute or republish
any contents or a part of contents of this e-book in any manner without written consent
of the publisher.
We strive to update the contents of our website and tutorials as timely and as precisely as
possible, however, the contents may contain inaccuracies or errors. Tutorials Point (I) Pvt.
Ltd. provides no guarantee regarding the accuracy, timeliness or completeness of our
website or its contents including this tutorial. If you discover any errors on our website or
in this tutorial, please notify us at contact@tutorialspoint.com
Python 3
ii
Table of Contents
About the Tutorial ............................................................................................................................................ i
Audience........................................................................................................................................................... i
Prerequisites..................................................................................................................................................... i
Execute Python Programs ................................................................................................................................ i
Copyright & Disclaimer..................................................................................................................................... i
Table of Contents ............................................................................................................................................ ii
PYTHON 3 – BASIC TUTORIAL ...................................................................................................... 1
1. Python 3 – What is New? ..........................................................................................................................2
The __future__ module...................................................................................................................................2
The print Function ...........................................................................................................................................2
Reading Input from Keyboard .........................................................................................................................2
Integer Division................................................................................................................................................3
Unicode Representation..................................................................................................................................3
xrange() Function Removed ............................................................................................................................4
raise exceprion ................................................................................................................................................4
Arguments in Exceptions.................................................................................................................................4
next() Function and .next() Method ................................................................................................................4
2to3 Utility.......................................................................................................................................................4
2. Python 3 – Overview.................................................................................................................................6
History of Python.............................................................................................................................................6
Python Features ..............................................................................................................................................7
3. Python 3 – Environment Setup..................................................................................................................8
Local Environment Setup.................................................................................................................................8
Getting Python ................................................................................................................................................8
Setting up PATH...............................................................................................................................................9
Setting Path at Unix/Linux .............................................................................................................................10
Setting Path at Windows...............................................................................................................................10
Python Environment Variables......................................................................................................................10
Running Python .............................................................................................................................................11
4. Python 3 – Basic Syntax ..........................................................................................................................13
First Python Program.....................................................................................................................................13
Python Identifiers..........................................................................................................................................14
Reserved Words ............................................................................................................................................15
Lines and Indentation....................................................................................................................................15
Multi-Line Statements...................................................................................................................................17
Quotation in Python ......................................................................................................................................17
Comments in Python .....................................................................................................................................17
Using Blank Lines...........................................................................................................................................18
Waiting for the User......................................................................................................................................18
Multiple Statements on a Single Line ............................................................................................................18
Multiple Statement Groups as Suites............................................................................................................19
Command Line Arguments............................................................................................................................19
Python 3
iii
Parsing Command-Line Arguments...............................................................................................................20
5. Python 3 – Variable Types.......................................................................................................................23
Assigning Values to Variables........................................................................................................................23
Multiple Assignment .....................................................................................................................................23
Standard Data Types......................................................................................................................................24
Python Numbers............................................................................................................................................24
Python Strings................................................................................................................................................25
Python Lists ...................................................................................................................................................26
Python Tuples................................................................................................................................................27
Python Dictionary..........................................................................................................................................27
Data Type Conversion....................................................................................................................................28
6. Python 3 – Basic Operators.....................................................................................................................30
Types of Operator..........................................................................................................................................30
Python Arithmetic Operators........................................................................................................................30
Python Comparison Operators......................................................................................................................32
Python Assignment Operators ......................................................................................................................33
Python Bitwise Operators..............................................................................................................................35
Python Logical Operators..............................................................................................................................37
Python Membership Operators.....................................................................................................................38
Python Identity Operators.............................................................................................................................39
Python Operators Precedence ......................................................................................................................40
7. Python 3 – Decision Making....................................................................................................................43
IF Statement ..................................................................................................................................................44
IF...ELIF...ELSE Statements.............................................................................................................................45
Nested IF Statements ....................................................................................................................................48
Single Statement Suites.................................................................................................................................49
8. Python 3 – Loops.....................................................................................................................................51
while Loop Statements..................................................................................................................................52
for Loop Statements......................................................................................................................................56
Nested loops..................................................................................................................................................59
Loop Control Statements...............................................................................................................................60
break statement............................................................................................................................................61
continue Statement.......................................................................................................................................63
pass Statement..............................................................................................................................................65
Iterator and Generator..................................................................................................................................66
9. Python 3 – Numbers ...............................................................................................................................68
Mathematical Functions................................................................................................................................70
Number abs() Method...................................................................................................................................71
Number ceil() Method...................................................................................................................................71
Number exp() Method...................................................................................................................................72
Number fabs() Method..................................................................................................................................73
Number floor() Method.................................................................................................................................74
Number log() Method....................................................................................................................................75
Number log10() Method ...............................................................................................................................76
Number max() Method..................................................................................................................................77
Number min() Method ..................................................................................................................................78
Number modf() Method................................................................................................................................79
Python 3
iv
Number pow() Method .................................................................................................................................80
Number round() Method...............................................................................................................................80
Number sqrt() Method ..................................................................................................................................81
Random Number Functions...........................................................................................................................82
Number choice() Method ..............................................................................................................................82
Number randrange() Method........................................................................................................................83
Number random() Method............................................................................................................................84
Number seed() Method.................................................................................................................................85
Number shuffle() Method .............................................................................................................................86
Number uniform() Method ...........................................................................................................................87
Trigonometric Functions ...............................................................................................................................88
Number acos() Method .................................................................................................................................88
Number asin() Method..................................................................................................................................89
Number atan() Method .................................................................................................................................90
Number atan2() Method ...............................................................................................................................91
Number cos() Method ...................................................................................................................................92
Number hypot() Method ...............................................................................................................................93
Number sin() Method....................................................................................................................................94
Number tan() Method ...................................................................................................................................95
Number degrees() Method............................................................................................................................96
Number radians() Method.............................................................................................................................97
Mathematical Constants ...............................................................................................................................98
10. Python 3 – Strings...................................................................................................................................99
Accessing Values in Strings............................................................................................................................99
Updating Strings............................................................................................................................................99
Escape Characters .......................................................................................................................................100
String Special Operators..............................................................................................................................101
String Formatting Operator.........................................................................................................................102
Triple Quotes...............................................................................................................................................104
Unicode String .............................................................................................................................................105
String capitalize() Method ...........................................................................................................................109
String center() Method................................................................................................................................110
String count() Method.................................................................................................................................111
String decode() Method ..............................................................................................................................112
String encode() Method ..............................................................................................................................112
String endswith() Method ...........................................................................................................................113
String expandtabs() Method........................................................................................................................114
String find() Method ....................................................................................................................................115
String index() Method .................................................................................................................................116
String isalnum() Method..............................................................................................................................117
String isalpha() Method...............................................................................................................................118
String isdigit() Method.................................................................................................................................118
String islower() Method...............................................................................................................................119
String isnumeric() Method ..........................................................................................................................120
String isspace() Method...............................................................................................................................121
String istitle() Method .................................................................................................................................122
String isupper() Method ..............................................................................................................................122
String join() Method ....................................................................................................................................123
String len() Method .....................................................................................................................................124
String ljust() Method ...................................................................................................................................125
String lower() Method .................................................................................................................................125
Python 3
v
String lstrip() Method ..................................................................................................................................126
String maketrans() Method .........................................................................................................................127
String max() Method ...................................................................................................................................128
String min() Method ....................................................................................................................................129
String replace() Method ..............................................................................................................................129
String rfind() Method...................................................................................................................................130
String rindex() Method ................................................................................................................................131
String rjust() Method...................................................................................................................................132
String rstrip() Method..................................................................................................................................133
String split() Method ...................................................................................................................................134
String splitlines() Method ............................................................................................................................135
String startswith() Method ..........................................................................................................................135
String strip() Method ...................................................................................................................................136
String swapcase() Method...........................................................................................................................137
String title() Method....................................................................................................................................138
String translate() Method............................................................................................................................138
String upper() Method.................................................................................................................................140
String zfill() Method.....................................................................................................................................140
String isdecimal() Method ...........................................................................................................................141
11. Python 3 – Lists.....................................................................................................................................143
Python Lists .................................................................................................................................................143
Accessing Values in Lists..............................................................................................................................143
Updating Lists..............................................................................................................................................144
Delete List Elements....................................................................................................................................144
Basic List Operations ...................................................................................................................................144
Indexing, Slicing and Matrixes.....................................................................................................................145
Built-in List Functions & Methods ...............................................................................................................145
List len() Method .........................................................................................................................................146
List max() Method .......................................................................................................................................147
List min() Method ........................................................................................................................................147
List list() Method .........................................................................................................................................148
List append() Method ..................................................................................................................................150
List count() Method.....................................................................................................................................151
List extend() Method ...................................................................................................................................151
List index() Method .....................................................................................................................................152
List insert() Method.....................................................................................................................................153
List pop() Method........................................................................................................................................154
List remove() Method..................................................................................................................................154
List reverse() Method ..................................................................................................................................155
List sort() Method........................................................................................................................................156
12. Python 3 – Tuples..................................................................................................................................157
Accessing Values in Tuples ..........................................................................................................................157
Updating Tuples...........................................................................................................................................158
Delete Tuple Elements ................................................................................................................................158
Basic Tuples Operations ..............................................................................................................................159
Indexing, Slicing, and Matrixes....................................................................................................................159
No Enclosing Delimiters...............................................................................................................................160
Built-in Tuple Functions...............................................................................................................................160
Tuple len() Method......................................................................................................................................160
Tuple max() Method....................................................................................................................................161
Python 3
vi
Tuple min() Method ....................................................................................................................................162
Tuple tuple() Method ..................................................................................................................................162
13. Python 3 – Dictionary............................................................................................................................164
Accessing Values in Dictionary ....................................................................................................................164
Updating Dictionary.....................................................................................................................................165
Delete Dictionary Elements.........................................................................................................................165
Properties of Dictionary Keys......................................................................................................................166
Built-in Dictionary Functions & Methods....................................................................................................167
Dictionary len() Method ..............................................................................................................................167
Dictionary str() Method...............................................................................................................................168
Dictionary type() Method............................................................................................................................168
Dictionary clear() Method ...........................................................................................................................170
Dictionary copy() Method ...........................................................................................................................171
Dictionary fromkeys() Method ....................................................................................................................172
Dictionary get() Method..............................................................................................................................172
Dictionary items() Method ..........................................................................................................................173
Dictionary keys() Method ............................................................................................................................174
Dictionary setdefault() Method...................................................................................................................174
Dictionary update() Method........................................................................................................................175
Dictionary values() Method.........................................................................................................................176
14. Python 3 – Date & Time ........................................................................................................................178
What is Tick?................................................................................................................................................178
What is TimeTuple?.....................................................................................................................................178
Getting current time....................................................................................................................................180
Getting formatted time ...............................................................................................................................180
Getting calendar for a month......................................................................................................................180
The time Module.........................................................................................................................................181
Time altzone() Method................................................................................................................................182
Time asctime() Method ...............................................................................................................................183
Time clock() Method ...................................................................................................................................184
Time ctime() Method...................................................................................................................................185
Time gmtime() Method ...............................................................................................................................186
Time localtime() Method.............................................................................................................................187
Time mktime() Method ...............................................................................................................................187
Time sleep() Method ...................................................................................................................................188
Time strftime() Method...............................................................................................................................189
Time strptime() Method..............................................................................................................................191
Time time() Method ....................................................................................................................................193
Time tzset() Method....................................................................................................................................194
The calendar Module ..................................................................................................................................196
Other Modules & Functions ........................................................................................................................198
15. Python 3 – Functions.............................................................................................................................199
Defining a Function......................................................................................................................................199
Calling a Function ........................................................................................................................................200
Pass by Reference vs Value .........................................................................................................................200
Function Arguments....................................................................................................................................202
Required Arguments....................................................................................................................................202
Keyword Arguments....................................................................................................................................202
Default Arguments ......................................................................................................................................203
Python 3
vii
Variable-length Arguments .........................................................................................................................204
The Anonymous Functions..........................................................................................................................205
The return Statement..................................................................................................................................206
Global vs. Local variables.............................................................................................................................206
16. Python 3 – Modules..............................................................................................................................208
The import Statement.................................................................................................................................208
The from...import Statement......................................................................................................................209
The from...import * Statement:..................................................................................................................209
Executing Modules as Scripts......................................................................................................................209
Locating Modules ........................................................................................................................................210
The PYTHONPATH Variable.........................................................................................................................210
Namespaces and Scoping ............................................................................................................................211
The dir( ) Function .......................................................................................................................................212
The globals() and locals() Functions............................................................................................................212
The reload() Function..................................................................................................................................212
Packages in Python......................................................................................................................................213
17. Python 3 – Files I/O...............................................................................................................................215
Printing to the Screen..................................................................................................................................215
Reading Keyboard Input..............................................................................................................................215
The input Function ......................................................................................................................................215
Opening and Closing Files............................................................................................................................216
The open Function ......................................................................................................................................216
The file Object Attributes............................................................................................................................217
The close() Method .....................................................................................................................................218
Reading and Writing Files............................................................................................................................219
The write() Method.....................................................................................................................................219
The read() Method......................................................................................................................................220
File Positions................................................................................................................................................220
Renaming and Deleting Files .......................................................................................................................221
The rename() Method .................................................................................................................................221
The remove() Method.................................................................................................................................222
Directories in Python...................................................................................................................................222
The mkdir() Method....................................................................................................................................222
The chdir() Method .....................................................................................................................................223
The getcwd() Method .................................................................................................................................223
The rmdir() Method ....................................................................................................................................224
File & Directory Related Methods...............................................................................................................224
File Methods................................................................................................................................................224
File close() Method......................................................................................................................................226
File flush() Method ......................................................................................................................................227
File fileno() Method.....................................................................................................................................228
File isatty() Method .....................................................................................................................................228
File next() Method.......................................................................................................................................229
File read() Method.......................................................................................................................................231
File readline() Method.................................................................................................................................232
File readlines() Method ...............................................................................................................................233
File seek() Method.......................................................................................................................................234
File tell() Method.........................................................................................................................................236
File truncate() Method ................................................................................................................................237
Python 3
viii
File write() Method......................................................................................................................................238
File writelines() Method ..............................................................................................................................240
OS File/Directory Methods..........................................................................................................................241
os.access() Method......................................................................................................................................248
os.chdir() Method........................................................................................................................................250
os.chflags() Method.....................................................................................................................................251
os.chmod() Method.....................................................................................................................................252
os.chown() Method .....................................................................................................................................254
os.chroot() Method .....................................................................................................................................255
Python os.close() Method ...........................................................................................................................255
os.closerange() Method ..............................................................................................................................256
os.dup() Method..........................................................................................................................................258
os.dup2() Method........................................................................................................................................259
os.fchdir() Method.......................................................................................................................................260
os.fchmod() Method....................................................................................................................................261
os.fchown() Method....................................................................................................................................263
os.fdatasync() Method ................................................................................................................................264
os.fdopen() Method ....................................................................................................................................266
os.fpathconf() Method ................................................................................................................................267
os.fstat() Method.........................................................................................................................................269
os.fstatvfs() Method ....................................................................................................................................270
os.fsync() Method........................................................................................................................................272
os.ftruncate() Method.................................................................................................................................273
os.getcwd() Method ....................................................................................................................................274
os.getcwdu() Method ..................................................................................................................................275
os.isatty() Method .......................................................................................................................................276
os.lchflags() Method....................................................................................................................................278
os.lchown() Method ....................................................................................................................................279
os.link() Method ..........................................................................................................................................280
os.listdir() Method.......................................................................................................................................281
os.lseek() Method........................................................................................................................................282
os.lstat() Method.........................................................................................................................................284
os.major() Method ......................................................................................................................................286
os.makedev() Method .................................................................................................................................286
os.makedirs() Method .................................................................................................................................288
os.minor() Method ......................................................................................................................................288
os.mkdir() Method.......................................................................................................................................289
os.mkfifo() Method .....................................................................................................................................290
os.mknod() Method.....................................................................................................................................291
os.open() Method........................................................................................................................................292
os.openpty() Method ..................................................................................................................................293
os.pathconf() Method .................................................................................................................................294
os.pipe() Method.........................................................................................................................................296
os.popen() Method......................................................................................................................................297
os.read() Method.........................................................................................................................................298
os.readlink() Method...................................................................................................................................299
os.remove() Method....................................................................................................................................300
os.removedirs() Method..............................................................................................................................301
os.rename() Method ...................................................................................................................................302
os.renames() Method..................................................................................................................................303
os.renames() Method..................................................................................................................................304
os.rmdir() Method.......................................................................................................................................305
Python 3
ix
os.stat() Method..........................................................................................................................................307
os.stat_float_times() Method .....................................................................................................................308
os.statvfs() Method .....................................................................................................................................309
os.symlink() Method....................................................................................................................................310
os.tcgetpgrp() Method ................................................................................................................................311
os.tcsetpgrp() Method.................................................................................................................................312
os.tempnam() Method ................................................................................................................................313
os.tmpfile() Method ....................................................................................................................................314
os.tmpnam() Method ..................................................................................................................................315
os.ttyname() Method ..................................................................................................................................315
os.unlink() Method ......................................................................................................................................317
os.utime() Method ......................................................................................................................................318
os.walk() Method ........................................................................................................................................319
os.write() Method .......................................................................................................................................321
18. Python 3 – Exceptions Handling ...........................................................................................................323
Standard Exceptions....................................................................................................................................323
Assertions in Python....................................................................................................................................325
What is Exception? ......................................................................................................................................326
Handling an Exception.................................................................................................................................326
The except Clause with No Exceptions.......................................................................................................328
The except Clause with Multiple Exceptions..............................................................................................328
The try-finally Clause ...................................................................................................................................329
Argument of an Exception...........................................................................................................................330
Raising an Exception....................................................................................................................................331
User-Defined Exceptions.............................................................................................................................332
PYTHON 3 – ADVANCED TUTORIAL ......................................................................................... 333
19. Python 3 – Object Oriented...................................................................................................................334
Overview of OOP Terminology ....................................................................................................................334
Creating Classes...........................................................................................................................................335
Creating Instance Objects............................................................................................................................336
Accessing Attributes....................................................................................................................................336
Built-In Class Attributes...............................................................................................................................337
Destroying Objects (Garbage Collection) ....................................................................................................339
Class Inheritance .........................................................................................................................................340
Overriding Methods ....................................................................................................................................342
Base Overloading Methods .........................................................................................................................342
Overloading Operators................................................................................................................................343
Data Hiding ..................................................................................................................................................344
20. Python 3 – Regular Expressions.............................................................................................................346
The match Function....................................................................................................................................347
The search Function ...................................................................................................................................348
Matching Versus Searching .........................................................................................................................349
Search and Replace .....................................................................................................................................350
Regular Expression Modifiers: Option Flags................................................................................................350
Regular Expression Patterns........................................................................................................................351
Regular Expression Examples......................................................................................................................353
Character classes.........................................................................................................................................354
Python 3
x
Special Character Classes ............................................................................................................................354
Repetition Cases..........................................................................................................................................355
Nongreedy Repetition .................................................................................................................................355
Grouping with Parentheses.........................................................................................................................355
Backreferences............................................................................................................................................356
Alternatives .................................................................................................................................................356
Anchors........................................................................................................................................................356
Special Syntax with Parentheses.................................................................................................................357
21. Python 3 – CGI Programming ................................................................................................................358
What is CGI? ................................................................................................................................................358
Web Browsing .............................................................................................................................................358
CGI Architecture Diagram............................................................................................................................359
Web Server Support and Configuration ......................................................................................................359
First CGI Program.........................................................................................................................................360
HTTP Header................................................................................................................................................361
CGI Environment Variables..........................................................................................................................361
GET and POST Methods...............................................................................................................................363
Passing Information using GET method ......................................................................................................363
Simple URL Example – Get Method.............................................................................................................363
Simple FORM Example – GET Method ........................................................................................................364
Passing Radio Button Data to CGI Program.................................................................................................367
Passing Text Area Data to CGI Program.......................................................................................................368
Passing Drop Down Box Data to CGI Program.............................................................................................369
Using Cookies in CGI ....................................................................................................................................370
How It Works? .............................................................................................................................................370
Setting up Cookies.......................................................................................................................................371
Retrieving Cookies.......................................................................................................................................371
File Upload Example ....................................................................................................................................372
How To Raise a "File Download" Dialog Box ?.............................................................................................374
22. Python 3 – MySQL Database Access......................................................................................................375
What is PyMySQL ?......................................................................................................................................375
How do I Install PyMySQL? ..........................................................................................................................376
Database Connection ..................................................................................................................................376
Creating Database Table..............................................................................................................................377
INSERT Operation ........................................................................................................................................378
READ Operation...........................................................................................................................................380
Update Operation........................................................................................................................................382
DELETE Operation........................................................................................................................................383
Performing Transactions .............................................................................................................................383
COMMIT Operation .....................................................................................................................................384
ROLLBACK Operation...................................................................................................................................384
Disconnecting Database ..............................................................................................................................384
Handling Errors............................................................................................................................................385
23. Python 3 – Network Programming .......................................................................................................387
What is Sockets?..........................................................................................................................................387
The socket Module......................................................................................................................................388
Server Socket Methods ...............................................................................................................................388
Client Socket Methods ................................................................................................................................388
General Socket Methods.............................................................................................................................389
Python 3
xi
A Simple Server............................................................................................................................................389
A Simple Client.............................................................................................................................................390
Python Internet Modules ............................................................................................................................391
Further Readings .........................................................................................................................................392
24. Python 3 – Sending Email using SMTP..................................................................................................393
Sending an HTML e-mail using Python........................................................................................................394
Sending Attachments as an E-mail ..............................................................................................................395
25. Python 3 – Multithreaded Programming..............................................................................................398
Starting a New Thread.................................................................................................................................398
The Threading Module................................................................................................................................400
Creating Thread Using Threading Module ..................................................................................................400
Synchronizing Threads.................................................................................................................................402
Multithreaded Priority Queue.....................................................................................................................404
26. Python 3 – XML Processing ...................................................................................................................407
What is XML?...............................................................................................................................................407
XML Parser Architectures and APIs .............................................................................................................407
Parsing XML with SAX APIs..........................................................................................................................408
Themake_parser Method............................................................................................................................409
The parse Method........................................................................................................................................409
The parseString Method ..............................................................................................................................409
Parsing XML with DOM APIs........................................................................................................................412
27. Python 3 – GUI Programming (Tkinter) .................................................................................................415
Tkinter Programming...................................................................................................................................415
Tkinter Widgets...........................................................................................................................................416
Tkinter Button .............................................................................................................................................418
Tkinter Canvas.............................................................................................................................................420
Tkinter Checkbutton....................................................................................................................................423
Tkinter Entry ................................................................................................................................................427
Tkinter Frame ..............................................................................................................................................431
Tkinter Label................................................................................................................................................433
Tkinter Listbox .............................................................................................................................................435
Tkinter Menubutton....................................................................................................................................439
Tkinter Menu...............................................................................................................................................442
Tkinter Message ..........................................................................................................................................446
Tkinter Radiobutton ....................................................................................................................................449
Tkinter Scale ................................................................................................................................................453
Tkinter Scrollbar ..........................................................................................................................................457
Tkinter Text..................................................................................................................................................460
Tkinter Toplevel...........................................................................................................................................464
Tkinter Spinbox............................................................................................................................................467
Tkinter PanedWindow.................................................................................................................................471
Tkinter LabelFrame......................................................................................................................................473
Tkinter tkMessageBox .................................................................................................................................475
Standard Attributes.....................................................................................................................................477
Tkinter Dimensions......................................................................................................................................477
Tkinter Colors ..............................................................................................................................................478
Tkinter Fonts................................................................................................................................................479
Tkinter Anchors ...........................................................................................................................................480
Python 3
xii
Tkinter Relief styles .....................................................................................................................................481
Tkinter Bitmaps ...........................................................................................................................................482
Tkinter Cursors ............................................................................................................................................484
Geometry Management..............................................................................................................................485
Tkinter pack() Method.................................................................................................................................486
Tkinter grid() Method ..................................................................................................................................487
Tkinter place() Method................................................................................................................................488
28. Python 3 – Extension Programming with C...........................................................................................490
Pre-Requisites for Writing Extensions.........................................................................................................490
First look at a Python Extension ..................................................................................................................490
The Header File Python.h ............................................................................................................................490
The C Functions ...........................................................................................................................................491
The Method Mapping Table ........................................................................................................................491
The Initialization Function ...........................................................................................................................492
Building and Installing Extensions...............................................................................................................494
Importing Extensions...................................................................................................................................494
Passing Function Parameters ......................................................................................................................495
The PyArg_ParseTuple Function..................................................................................................................496
Returning Values .........................................................................................................................................497
The Py_BuildValue Function ........................................................................................................................498
Python 3
1
Python 3 – Basic Tutorial
Python 3
2
The __future__ module
Python 3.x introduced some Python 2-incompatible keywords and features that can be
imported via the in-built __future__ module in Python 2. It is recommended to use
__future__ imports, if you are planning Python 3.x support for your code.
For example, if we want Python 3.x's integer division behavior in Python 2, add the
following import statement.
from __future__ import division
The print Function
Most notable and most widely known change in Python 3 is how the print function is used.
Use of parenthesis () with print function is now mandatory. It was optional in Python 2.
print "Hello World" #is acceptable in Python 2
print ("Hello World") # in Python 3, print must be followed by ()
The print() function inserts a new line at the end, by default. In Python 2, it can be
suppressed by putting ',' at the end. In Python 3, "end=' '" appends space instead of
newline.
print x, # Trailing comma suppresses newline in Python 2
print(x, end=" ") # Appends a space instead of a newline in Python 3
Reading Input from Keyboard
Python 2 has two versions of input functions, input() and raw_input(). The input()
function treats the received data as string if it is included in quotes '' or "", otherwise the
data is treated as number.
In Python 3, raw_input() function is deprecated. Further, the received data is always
treated as string.
In Python 2
>>> x=input('something:')
something:10 #entered data is treated as number
>>> x
10
>>> x=input('something:')
something:'10' #eentered data is treated as string
1. Python 3 – What is New? 
Python 3
3
>>> x
'10'
>>> x=raw_input("something:")
something:10 #entered data is treated as string even without ''
>>> x
'10'
>>> x=raw_input("something:")
something:'10' #entered data treated as string including ''
>>> x
"'10'"
In Python 3
>>> x=input("something:")
something:10
>>> x
'10'
>>> x=input("something:")
something:'10' #entered data treated as string with or without ''
>>> x
"'10'"
>>> x=raw_input("something:") # will result NameError
Traceback (most recent call last):
 File "", line 1, in

 x=raw_input("something:")
NameError: name 'raw_input' is not defined
Integer Division
In Python 2, the result of division of two integers is rounded to the nearest integer. As a
result, 3/2 will show 1. In order to obtain a floating-point division, numerator or
denominator must be explicitly used as float. Hence, either 3.0/2 or 3/2.0 or 3.0/2.0 will
result in 1.5
Python 3 evaluates 3 / 2 as 1.5 by default, which is more intuitive for new programmers.
Unicode Representation
Python 2 requires you to mark a string with a u if you want to store it as Unicode.
Python 3 stores strings as Unicode, by default. We have Unicode (utf-8) strings, and 2
byte classes: byte and byte arrays.
Python 3
4
xrange() Function Removed
In Python 2 range() returns a list, and xrange() returns an object that will only generate
the items in the range when needed, saving memory.
In Python 3, the range() function is removed, and xrange() has been renamed as range().
In addition, the range() object supports slicing in Python 3.2 and later .
raise exceprion
Python 2 accepts both notations, the 'old' and the 'new' syntax; Python 3 raises a
SyntaxError if we do not enclose the exception argument in parenthesis.
raise IOError, "file error" #This is accepted in Python 2
raise IOError("file error") #This is also accepted in Python 2
raise IOError, "file error" #syntax error is raised in Python 3
raise IOError("file error") #this is the recommended syntax in Python 3
Arguments in Exceptions
In Python 3, arguments to exception should be declared with 'as' keyword.
except Myerror, err: # In Python2
except Myerror as err: #In Python 3
next() Function and .next() Method
In Python 2, next() as a method of generator object, is allowed. In Python 2, the next()
function, to iterate over generator object, is also accepted. In Python 3, however, next(0
as a generator method is discontinued and raises AttributeError.
gen = (letter for letter in 'Hello World') # creates generator object
next(my_generator) #allowed in Python 2 and Python 3
my_generator.next() #allowed in Python 2. raises AttributeError in Python 3
2to3 Utility
Along with Python 3 interpreter, 2to3.py script is usually installed in tools/scripts folder.
It reads Python 2.x source code and applies a series of fixers to transform it into a valid
Python 3.x code.
Here is a sample Python 2 code (area.py):
def area(x,y=3.14):
 a=y*x*x
 print a
 return a
Python 3
5
a=area(10)
print "area",a
To convert into Python 3 version:
$2to3 -w area.py
Converted code :
def area(x,y=3.14): # formal parameters
 a=y*x*x
 print (a)
 return a
a=area(10)
print("area",a)
Python 3
6
Python is a high-level, interpreted, interactive and object-oriented scripting language.
Python is designed to be highly readable. It uses English keywords frequently whereas the
other languages use punctuations. It has fewer syntactical constructions than other
languages.
 Python is Interpreted: Python is processed at runtime by the interpreter. You do
not need to compile your program before executing it. This is similar to PERL and
PHP.
 Python is Interactive: You can actually sit at a Python prompt and interact with
the interpreter directly to write your programs.
 Python is Object-Oriented: Python supports Object-Oriented style or technique
of programming that encapsulates code within objects.
 Python is a Beginner's Language: Python is a great language for the beginnerlevel programmers and supports the development of a wide range of applications
from simple text processing to WWW browsers to games.
History of Python
Python was developed by Guido van Rossum in the late eighties and early nineties at the
National Research Institute for Mathematics and Computer Science in the Netherlands.
 Python is derived from many other languages, including ABC, Modula-3, C, C++,
Algol-68, SmallTalk, and Unix shell and other scripting languages.
 Python is copyrighted. Like Perl, Python source code is now available under the
GNU General Public License (GPL).
 Python is now maintained by a core development team at the institute, although
Guido van Rossum still holds a vital role in directing its progress.
 Python 1.0 was released in November 1994. In 2000, Python 2.0 was released.
Python 2.7.11 is the latest edition of Python 2.
 Meanwhile, Python 3.0 was released in 2008. Python 3 is not backward compatible
with Python 2. The emphasis in Python 3 had been on the removal of duplicate
programming constructs and modules so that "There should be one -- and
preferably only one -- obvious way to do it." Python 3.5.1 is the latest version of
Python 3.
2. Python 3 – Overview 
Python 3
7
Python Features
Python's features include-
 Easy-to-learn: Python has few keywords, simple structure, and a clearly defined
syntax. This allows a student to pick up the language quickly.
 Easy-to-read: Python code is more clearly defined and visible to the eyes.
 Easy-to-maintain: Python's source code is fairly easy-to-maintain.
 A broad standard library: Python's bulk of the library is very portable and crossplatform compatible on UNIX, Windows, and Macintosh.
 Interactive Mode: Python has support for an interactive mode, which allows
interactive testing and debugging of snippets of code.
 Portable: Python can run on a wide variety of hardware platforms and has the
same interface on all platforms.
 Extendable: You can add low-level modules to the Python interpreter. These
modules enable programmers to add to or customize their tools to be more
efficient.
 Databases: Python provides interfaces to all major commercial databases.
 GUI Programming: Python supports GUI applications that can be created and
ported to many system calls, libraries and windows systems, such as Windows MFC,
Macintosh, and the X Window system of Unix.
 Scalable: Python provides a better structure and support for large programs than
shell scripting.
Apart from the above-mentioned features, Python has a big list of good features. A few
are listed below-
 It supports functional and structured programming methods as well as OOP.
 It can be used as a scripting language or can be compiled to byte-code for building
large applications.
 It provides very high-level dynamic data types and supports dynamic type
checking.
 It supports automatic garbage collection.
 It can be easily integrated with C, C++, COM, ActiveX, CORBA, and Java.
Python 3
8
Try it Option Online
We have set up the Python Programming environment online, so that you can compile and
execute all the available examples online. It will give you the confidence in what you are
reading and will enable you to verify the programs with different options. Feel free to
modify any example and execute it online.
Try the following example using our online compiler available at CodingGround
#!/usr/bin/python3
print ("Hello, Python!")
For most of the examples given in this tutorial, you will find a Try it option on our website
code sections, at the top right corner that will take you to the online compiler. Just use it
and enjoy your learning.
Python 3 is available for Windows, Mac OS and most of the flavors of Linux operating
system. Even though Python 2 is available for many other OSs, Python 3 support either
has not been made available for them or has been dropped.
Local Environment Setup
Open a terminal window and type "python" to find out if it is already installed and which
version is installed.
Getting Python
Windows platform
Binaries of latest version of Python 3 (Python 3.5.1) are available on this download page
The following different installation options are available.
 Windows x86-64 embeddable zip file
 Windows x86-64 executable installer
 Windows x86-64 web-based installer
 Windows x86 embeddable zip file
 Windows x86 executable installer
 Windows x86 web-based installer
Note:In order to install Python 3.5.1, minimum OS requirements are Windows 7 with SP1.
For versions 3.0 to 3.4.x, Windows XP is acceptable.
3. Python 3 – Environment Setup 
Python 3
9
Linux platform
Different flavors of Linux use different package managers for installation of new packages.
On Ubuntu Linux, Python 3 is installed using the following command from the terminal.
$sudo apt-get install python3-minimal
Installation from source
Download Gzipped source tarball from Python's download URL:
https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz
Extract the tarball
tar xvfz Python-3.5.1.tgz
Configure and Install:
cd Python-3.5.1
./configure --prefix=/opt/python3.5.1
make
sudo make install
Mac OS
Download Mac OS installers from this URL:https://www.python.org/downloads/mac-osx/
 Mac OS X 64-bit/32-bit installer : python-3.5.1-macosx10.6.pkg
 Mac OS X 32-bit i386/PPC installer : python-3.5.1-macosx10.5.pkg
Double click this package file and follow the wizard instructions to install.
The most up-to-date and current source code, binaries, documentation, news, etc., is
available on the official website of Python:
Python Official Website : http://www.python.org/
You can download Python documentation from the following site. The documentation is
available in HTML, PDF and PostScript formats.
Python Documentation Website : www.python.org/doc/
Setting up PATH
Programs and other executable files can be in many directories. Hence, the operating
systems provide a search path that lists the directories that it searches for executables.
The important features are-
 The path is stored in an environment variable, which is a named string maintained
by the operating system. This variable contains information available to the
command shell and other programs.
Python 3
10
 The path variable is named as PATH in Unix or Path in Windows (Unix is casesensitive; Windows is not).
 In Mac OS, the installer handles the path details. To invoke the Python interpreter
from any particular directory, you must add the Python directory to your path.
Setting Path at Unix/Linux
To add the Python directory to the path for a particular session in Unix-
 In the csh shell: type setenv PATH "$PATH:/usr/local/bin/python3" and press
Enter.
 In the bash shell (Linux): type export PATH="$PATH:/usr/local/bin/python3"
and press Enter.
 In the sh or ksh shell: type PATH="$PATH:/usr/local/bin/python3" and press
Enter.
Note: /usr/local/bin/python3 is the path of the Python directory.
Setting Path at Windows
To add the Python directory to the path for a particular session in WindowsAt the command prompt : type
path %path%;C:\Python and press Enter.
Note: C:\Python is the path of the Python directory.
Python Environment Variables
Here are important environment variables, which are recognized by PythonVariable Description
PYTHONPATH
It has a role similar to PATH. This variable tells the Python
interpreter where to locate the module files imported into a
program. It should include the Python source library directory and
the directories containing Python source code. PYTHONPATH is
sometimes, preset by the Python installer.
PYTHONSTARTUP
It contains the path of an initialization file containing Python
source code. It is executed every time you start the interpreter. It
is named as .pythonrc.py in Unix and it contains commands that
load utilities or modify PYTHONPATH.
Python 3
11
PYTHONCASEOK
It is used in Windows to instruct Python to find the first caseinsensitive match in an import statement. Set this variable to any
value to activate it.
PYTHONHOME
It is an alternative module search path. It is usually embedded in
the PYTHONSTARTUP or PYTHONPATH directories to make
switching module libraries easy.
Running Python
There are three different ways to start Python-
(1) Interactive Interpreter
You can start Python from Unix, DOS, or any other system that provides you a commandline interpreter or shell window.
Enter python the command line.
Start coding right away in the interactive interpreter.
$python # Unix/Linux
or
python% # Unix/Linux
or
C:>python # Windows/DOS
Here is the list of all the available command line optionsOption Description
-d provide debug output
-O generate optimized bytecode (resulting in .pyo files)
-S do not run import site to look for Python paths on startup
-v verbose output (detailed trace on import statements)
-X
disable class-based built-in exceptions (just use strings); obsolete starting
with version 1.6
-c cmd run Python script sent in as cmd string
Python 3
12
file run Python script from given file
(2) Script from the Command-line
A Python script can be executed at the command line by invoking the interpreter on your
application, as shown in the following example.
$python script.py # Unix/Linux
or
python% script.py # Unix/Linux
or
C:>python script.py # Windows/DOS
Note: Be sure the file permission mode allows execution.
(3) Integrated Development Environment
You can run Python from a Graphical User Interface (GUI) environment as well, if you have
a GUI application on your system that supports Python.
 Unix: IDLE is the very first Unix IDE for Python.
 Windows: PythonWin is the first Windows interface for Python and is an IDE with
a GUI.
 Macintosh: The Macintosh version of Python along with the IDLE IDE is available
from the main website, downloadable as either MacBinary or BinHex'd files.
If you are not able to set up the environment properly, then you can take the help of your
system admin. Make sure the Python environment is properly set up and working perfectly
fine.
Note: All the examples given in subsequent chapters are executed with Python 3.4.1
version available on Windows 7 and Ubuntu Linux.
We have already set up Python Programming environment online, so that you can execute
all the available examples online while you are learning theory. Feel free to modify any
example and execute it online.
Python 3
13
The Python language has many similarities to Perl, C, and Java. However, there are some
definite differences between the languages.
First Python Program
Let us execute the programs in different modes of programming.
Interactive Mode Programming
Invoking the interpreter without passing a script file as a parameter brings up the following
prompt-
$ python
Python 3.3.2 (default, Dec 10 2013, 11:35:01)
[GCC 4.6.3] on Linux
Type "help", "copyright", "credits", or "license" for more information.
>>>
On Windows:
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 24 2015, 22:43:06) [MSC v.1600 32 bit (Intel)] on
win32
Type "copyright", "credits" or "license()" for more information.
>>>
Type the following text at the Python prompt and press Enter-
>>> print ("Hello, Python!")
If you are running the older version of Python (Python 2.x), use of parenthesis as
inprint function is optional. This produces the following resultHello, Python!
Script Mode Programming
Invoking the interpreter with a script parameter begins execution of the script and
continues until the script is finished. When the script is finished, the interpreter is no longer
active.
Let us write a simple Python program in a script. Python files have the extension.py. Type
the following source code in a test.py fileprint ("Hello, Python!")
4. Python 3 – Basic Syntax 
Python 3
14
We assume that you have the Python interpreter set in PATH variable. Now, try to run
this program as followsOn Linux
$ python test.py
This produces the following resultHello, Python!
On Windows
C:\Python34>Python test.py
This produces the following resultHello, Python!
Let us try another way to execute a Python script in Linux. Here is the modified test.py
file-
#!/usr/bin/python3
print ("Hello, Python!")
We assume that you have Python interpreter available in the /usr/bin directory. Now, try
to run this program as follows-
$ chmod +x test.py # This is to make file executable
$./test.py
This produces the following resultHello, Python!
Python Identifiers
A Python identifier is a name used to identify a variable, function, class, module or other
object. An identifier starts with a letter A to Z or a to z or an underscore (_) followed by
zero or more letters, underscores and digits (0 to 9).
Python does not allow punctuation characters such as @, $, and % within identifiers.
Python is a case sensitive programming language. Thus, Manpower and manpower are
two different identifiers in Python.
Here are naming conventions for Python identifiers-
 Class names start with an uppercase letter. All other identifiers start with a
lowercase letter.
 Starting an identifier with a single leading underscore indicates that the identifier
is private.
Python 3
15
 Starting an identifier with two leading underscores indicates a strong private
identifier.
 If the identifier also ends with two trailing underscores, the identifier is a languagedefined special name.
Reserved Words
The following list shows the Python keywords. These are reserved words and you cannot
use them as constants or variables or any other identifier names. All the Python keywords
contain lowercase letters only.
and exec Not
as finally or
assert for pass
break from print
class global raise
continue if return
def import try
del in while
elif is with
else lambda yield
except
Lines and Indentation
Python does not use braces({}) to indicate blocks of code for class and function definitions
or flow control. Blocks of code are denoted by line indentation, which is rigidly enforced.
The number of spaces in the indentation is variable, but all statements within the block
must be indented the same amount. For example-
Python 3
16
if True:
 print ("True")
else:
 print ("False")
However, the following block generates an errorif True:
 print ("Answer")
 print ("True")
else:
 print "(Answer")
 print ("False")
Thus, in Python all the continuous lines indented with the same number of spaces would
form a block. The following example has various statement blocksNote: Do not try to understand the logic at this point of time. Just make sure you
understood the various blocks even if they are without braces.
#!/usr/bin/python3
import sys
try:
 # open file stream
 file = open(file_name, "w")
except IOError:
 print ("There was an error writing to", file_name)
 sys.exit()
print ("Enter '", file_finish,)
print "' When finished"
while file_text != file_finish:
 file_text = raw_input("Enter text: ")
 if file_text == file_finish:
 # close the file
 file.close
 break
 file.write(file_text)
 file.write("\n")
file.close()
file_name = input("Enter filename: ")
if len(file_name) == 0:
 print ("Next time please enter something")
Python 3
17
 sys.exit()
try:
 file = open(file_name, "r")
except IOError:
 print ("There was an error reading file")
 sys.exit()
file_text = file.read()
file.close()
print (file_text)
Multi-Line Statements
Statements in Python typically end with a new line. Python, however, allows the use of
the line continuation character (\) to denote that the line should continue. For exampletotal = item_one + \
 item_two + \
 item_three
The statements contained within the [], {}, or () brackets do not need to use the line
continuation character. For exampledays = ['Monday', 'Tuesday', 'Wednesday',
 'Thursday', 'Friday']
Quotation in Python
Python accepts single ('), double (") and triple (''' or """) quotes to denote string literals,
as long as the same type of quote starts and ends the string.
The triple quotes are used to span the string across multiple lines. For example, all the
following are legalword = 'word'
sentence = "This is a sentence."
paragraph = """This is a paragraph. It is
made up of multiple lines and sentences."""
Comments in Python
A hash sign (#) that is not inside a string literal is the beginning of a comment. All
characters after the #, up to the end of the physical line, are part of the comment and the
Python interpreter ignores them.
#!/usr/bin/python3
Python 3
18
# First comment
print ("Hello, Python!") # second comment
This produces the following resultHello, Python!
You can type a comment on the same line after a statement or expressionname = "Madisetti" # This is again comment
Python does not have multiple-line commenting feature. You have to comment each line
individually as follows-
# This is a comment.
# This is a comment, too.
# This is a comment, too.
# I said that already.
Using Blank Lines
A line containing only whitespace, possibly with a comment, is known as a blank line and
Python totally ignores it.
In an interactive interpreter session, you must enter an empty physical line to terminate
a multiline statement.
Waiting for the User
The following line of the program displays the prompt and the statement saying “Press the
enter key to exit”, and then waits for the user to take action −
#!/usr/bin/python3
input("\n\nPress the enter key to exit.")
Here, "\n\n" is used to create two new lines before displaying the actual line. Once the
user presses the key, the program ends. This is a nice trick to keep a console window open
until the user is done with an application.
Multiple Statements on a Single Line
The semicolon ( ; ) allows multiple statements on a single line given that no statement
starts a new code block. Here is a sample snip using the semicolonimport sys; x = 'foo'; sys.stdout.write(x + '\n')
Python 3
19
Multiple Statement Groups as Suites
Groups of individual statements, which make a single code block are called suites in
Python. Compound or complex statements, such as if, while, def, and class require a
header line and a suite.
Header lines begin the statement (with the keyword) and terminate with a colon ( : ) and
are followed by one or more lines which make up the suite. For example −
if expression :
 suite
elif expression :
 suite
else :
 suite
Command Line Arguments
Many programs can be run to provide you with some basic information about how they
should be run. Python enables you to do this with -h:
$ python -h
usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...
Options and arguments (and corresponding environment variables):
-c cmd : program passed in as string (terminates option list)
-d : debug output from parser (also PYTHONDEBUG=x)
-E : ignore environment variables (such as PYTHONPATH)
-h : print this help message and exit
[ etc. ]
You can also program your script in such a way that it should accept various
options. Command Line Arguments is an advance topic. Let us understand it.
Command Line Arguments
Python provides a getopt module that helps you parse command-line options and
arguments.
$ python test.py arg1 arg2 arg3
The Python sys module provides access to any command-line arguments via
the sys.argv. This serves two purposes-
 sys.argv is the list of command-line arguments.
 len(sys.argv) is the number of command-line arguments.
Here sys.argv[0] is the program i.e. the script name.
Python 3
20
Example
Consider the following script test.py-
#!/usr/bin/python3
import sys
print ('Number of arguments:', len(sys.argv), 'arguments.')
print ('Argument List:', str(sys.argv))
Now run the above script as follows −
$ python test.py arg1 arg2 arg3
This produces the following resultNumber of arguments: 4 arguments.
Argument List: ['test.py', 'arg1', 'arg2', 'arg3']
NOTE: As mentioned above, the first argument is always the script name and it is also
being counted in number of arguments.
Parsing Command-Line Arguments
Python provided a getopt module that helps you parse command-line options and
arguments. This module provides two functions and an exception to enable command line
argument parsing.
getopt.getopt method
This method parses the command line options and parameter list. Following is a simple
syntax for this methodgetopt.getopt(args, options, [long_options])
Here is the detail of the parameters-
 args: This is the argument list to be parsed.
 options: This is the string of option letters that the script wants to recognize, with
options that require an argument should be followed by a colon (:).
 long_options: This is an optional parameter and if specified, must be a list of
strings with the names of the long options, which should be supported. Long
options, which require an argument should be followed by an equal sign ('='). To
accept only long options, options should be an empty string.
 This method returns a value consisting of two elements- the first is a list
of (option, value) pairs, the second is a list of program arguments left after the
option list was stripped.
Python 3
21
 Each option-and-value pair returned has the option as its first element, prefixed
with a hyphen for short options (e.g., '-x') or two hyphens for long options (e.g., '-
-long-option').
Exception getopt.GetoptError
This is raised when an unrecognized option is found in the argument list or when an option
requiring an argument is given none.
The argument to the exception is a string indicating the cause of the error. The
attributes msg and opt give the error message and related option.
Example
Suppose we want to pass two file names through command line and we also want to give
an option to check the usage of the script. Usage of the script is as followsusage: test.py -i <inputfile> -o <outputfile>
Here is the following script to test.py-
#!/usr/bin/python3
import sys, getopt
def main(argv):
 inputfile = ''
 outputfile = ''
 try:
 opts, args = getopt.getopt(argv,"hi:o:",["ifile=","ofile="])
 except getopt.GetoptError:
 print ('test.py -i <inputfile> -o <outputfile>')
 sys.exit(2)
 for opt, arg in opts:
 if opt == '-h':
 print ('test.py -i <inputfile> -o <outputfile>')
 sys.exit()
 elif opt in ("-i", "--ifile"):
 inputfile = arg
 elif opt in ("-o", "--ofile"):
 outputfile = arg
 print ('Input file is "', inputfile)
 print ('Output file is "', outputfile)
if __name__ == "__main__":
 main(sys.argv[1:])
Python 3
22
Now, run the above script as follows-
$ test.py -h
usage: test.py -i <inputfile> -o <outputfile>
$ test.py -i BMP -o
usage: test.py -i <inputfile> -o <outputfile>
$ test.py -i inputfile -o outputfile
Input file is " inputfile
Output file is " outputfile
Python 3
23
Variables are nothing but reserved memory locations to store values. It means that when
you create a variable, you reserve some space in the memory.
Based on the data type of a variable, the interpreter allocates memory and decides what
can be stored in the reserved memory. Therefore, by assigning different data types to the
variables, you can store integers, decimals or characters in these variables.
Assigning Values to Variables
Python variables do not need explicit declaration to reserve memory space. The declaration
happens automatically when you assign a value to a variable. The equal sign (=) is used
to assign values to variables.
The operand to the left of the = operator is the name of the variable and the operand to
the right of the = operator is the value stored in the variable. For example-
#!/usr/bin/python3
counter = 100 # An integer assignment
miles = 1000.0 # A floating point
name = "John" # A string
print (counter)
print (miles)
print (name)
Here, 100, 1000.0 and "John" are the values assigned to counter, miles, and
name variables, respectively. This produces the following result −
100
1000.0
John
Multiple Assignment
Python allows you to assign a single value to several variables simultaneously.
For examplea = b = c = 1
Here, an integer object is created with the value 1, and all the three variables are assigned
to the same memory location. You can also assign multiple objects to multiple variables.
5. Python 3 – Variable Types 
Python 3
24
For examplea, b, c = 1, 2, "john"
Here, two integer objects with values 1 and 2 are assigned to the variables a and b
respectively, and one string object with the value "john" is assigned to the variable c.
Standard Data Types
The data stored in memory can be of many types. For example, a person's age is stored
as a numeric value and his or her address is stored as alphanumeric characters. Python
has various standard data types that are used to define the operations possible on them
and the storage method for each of them.
Python has five standard data types-
 Numbers
 String
 List
 Tuple
 Dictionary
Python Numbers
Number data types store numeric values. Number objects are created when you assign a
value to them. For examplevar1 = 1
var2 = 10
You can also delete the reference to a number object by using the del statement. The
syntax of the del statement is −
del var1[,var2[,var3[....,varN]]]]
You can delete a single object or multiple objects by using the del statement.
For exampledel var
del var_a, var_b
Python supports three different numerical types −
 int (signed integers)
 float (floating point real values)
 complex (complex numbers)
Python 3
25
All integers in Python 3 are represented as long integers. Hence, there is no separate
number type as long.
Examples
Here are some examples of numbersint float complex
10 0.0 3.14j
100 15.20 45.j
-786 -21.9 9.322e-36j
080 32.3+e18 .876j
-0490 -90. -.6545+0J
-0x260 -32.54e100 3e+26J
0x69 70.2-E12 4.53e-7j
A complex number consists of an ordered pair of real floating-point numbers denoted by
x + yj, where x and y are real numbers and j is the imaginary unit.
Python Strings
Strings in Python are identified as a contiguous set of characters represented in the
quotation marks. Python allows either pair of single or double quotes. Subsets of strings
can be taken using the slice operator ([ ] and [:] ) with indexes starting at 0 in the
beginning of the string and working their way from -1 to the end.
The plus (+) sign is the string concatenation operator and the asterisk (*) is the repetition
operator. For example-
#!/usr/bin/python3
str = 'Hello World!'
print (str) # Prints complete string
print (str[0]) # Prints first character of the string
print (str[2:5]) # Prints characters starting from 3rd to 5th
print (str[2:]) # Prints string starting from 3rd character
print (str * 2) # Prints string two times
print (str + "TEST") # Prints concatenated string
Python 3
26
This will produce the following resultHello World!
H
llo
llo World!
Hello World!Hello World!
Hello World!TEST
Python Lists
Lists are the most versatile of Python's compound data types. A list contains items
separated by commas and enclosed within square brackets ([]). To some extent, lists are
similar to arrays in C. One of the differences between them is that all the items belonging
to a list can be of different data type.
The values stored in a list can be accessed using the slice operator ([ ] and [:]) with
indexes starting at 0 in the beginning of the list and working their way to end -1. The plus
(+) sign is the list concatenation operator, and the asterisk (*) is the repetition operator.
For example-
#!/usr/bin/python3
list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']
print (list) # Prints complete list
print (list[0]) # Prints first element of the list
print (list[1:3]) # Prints elements starting from 2nd till 3rd
print (list[2:]) # Prints elements starting from 3rd element
print (tinylist * 2) # Prints list two times
print (list + tinylist) # Prints concatenated lists
This produces the following result-
['abcd', 786, 2.23, 'john', 70.200000000000003]
abcd
[786, 2.23]
[2.23, 'john', 70.200000000000003]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.200000000000003, 123, 'john']
Python 3
27
Python Tuples
A tuple is another sequence data type that is similar to the list. A tuple consists of a
number of values separated by commas. Unlike lists, however, tuples are enclosed within
parenthesis.
The main difference between lists and tuples is- Lists are enclosed in brackets ( [ ] ) and
their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) )
and cannot be updated. Tuples can be thought of as read-only lists. For example-
#!/usr/bin/python3
tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )
tinytuple = (123, 'john')
print (tuple) # Prints complete tuple
print (tuple[0]) # Prints first element of the tuple
print (tuple[1:3]) # Prints elements starting from 2nd till 3rd
print (tuple[2:]) # Prints elements starting from 3rd element
print (tinytuple * 2) # Prints tuple two times
print (tuple + tinytuple) # Prints concatenated tuple
This produces the following result-
('abcd', 786, 2.23, 'john', 70.200000000000003)
abcd
(786, 2.23)
(2.23, 'john', 70.200000000000003)
(123, 'john', 123, 'john')
('abcd', 786, 2.23, 'john', 70.200000000000003, 123, 'john')
The following code is invalid with tuple, because we attempted to update a tuple, which is
not allowed. Similar case is possible with lists −
#!/usr/bin/python3
tuple = ( 'abcd', 786 , 2.23, 'john', 70.2 )
list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tuple[2] = 1000 # Invalid syntax with tuple
list[2] = 1000 # Valid syntax with list
Python Dictionary
Python's dictionaries are kind of hash-table type. They work like associative arrays or
hashes found in Perl and consist of key-value pairs. A dictionary key can be almost any
Python type, but are usually numbers or strings. Values, on the other hand, can be any
arbitrary Python object.
Python 3
28
Dictionaries are enclosed by curly braces ({ }) and values can be assigned and accessed
using square braces ([]). For example-
#!/usr/bin/python3
dict = {}
dict['one'] = "This is one"
dict[2] = "This is two"
tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
print (dict['one']) # Prints value for 'one' key
print (dict[2]) # Prints value for 2 key
print (tinydict) # Prints complete dictionary
print (tinydict.keys()) # Prints all the keys
print (tinydict.values()) # Prints all the values
This produces the following resultThis is one
This is two
{'dept': 'sales', 'code': 6734, 'name': 'john'}
['dept', 'code', 'name']
['sales', 6734, 'john']
Dictionaries have no concept of order among the elements. It is incorrect to say that the
elements are "out of order"; they are simply unordered.
Data Type Conversion
Sometimes, you may need to perform conversions between the built-in types. To convert
between types, you simply use the type-name as a function.
There are several built-in functions to perform conversion from one data type to another.
These functions return a new object representing the converted value.
Function Description
int(x [,base]) Converts x to an integer. The base specifies the base if x is a
string.
float(x) Converts x to a floating-point number.
complex(real
[,imag])
Creates a complex number.
Python 3
29
str(x) Converts object x to a string representation.
repr(x) Converts object x to an expression string.
eval(str) Evaluates a string and returns an object.
tuple(s) Converts s to a tuple.
list(s) Converts s to a list.
set(s) Converts s to a set.
dict(d) Creates a dictionary. d must be a sequence of (key,value) tuples.
frozenset(s) Converts s to a frozen set.
chr(x) Converts an integer to a character.
unichr(x) Converts an integer to a Unicode character.
ord(x) Converts a single character to its integer value.
hex(x) Converts an integer to a hexadecimal string.
oct(x) Converts an integer to an octal string.
Python 3
30
Operators are the constructs, which can manipulate the value of operands. Consider the
expression 4 + 5 = 9. Here, 4 and 5 are called operands and + is called the operator.
Types of Operator
Python language supports the following types of operators-
 Arithmetic Operators
 Comparison (Relational) Operators
 Assignment Operators
 Logical Operators
 Bitwise Operators
 Membership Operators
 Identity Operators
Let us have a look at all the operators one by one.
Python Arithmetic Operators
Assume variable a holds the value 10 and variable b holds the value 21, thenOperator Description Example
+ Addition Adds values on either side of the operator. a + b = 31
- Subtraction Subtracts right hand operand from left hand
operand.
a – b = -11
* Multiplication Multiplies values on either side of the operator a * b = 210
/ Division Divides left hand operand by right hand
operand
b / a = 2.1
% Modulus Divides left hand operand by right hand
operand and returns remainder
b % a = 1
** Exponent Performs exponential (power) calculation on
operators
a**b =10 to the
power 20
6. Python 3 – Basic Operators 
Python 3
31
// Floor Division - The division of operands where
the result is the quotient in which the digits
after the decimal point are removed.
9//2 = 4 and
9.0//2.0 = 4.0
Example
Assume variable a holds 10 and variable b holds 20, then-
#!/usr/bin/python3
a = 21
b = 10
c = 0
c = a + b
print ("Line 1 - Value of c is ", c)
c = a - b
print ("Line 2 - Value of c is ", c )
c = a * b
print ("Line 3 - Value of c is ", c)
c = a / b
print ("Line 4 - Value of c is ", c )
c = a % b
print ("Line 5 - Value of c is ", c)
a = 2
b = 3
c = a**b
print ("Line 6 - Value of c is ", c)
a = 10
b = 5
c = a//b
print ("Line 7 - Value of c is ", c)
When you execute the above program, it produces the following resultLine 1 - Value of c is 31
Line 2 - Value of c is 11
Python 3
32
Line 3 - Value of c is 210
Line 4 - Value of c is 2.1
Line 5 - Value of c is 1
Line 6 - Value of c is 8
Line 7 - Value of c is 2
Python Comparison Operators
These operators compare the values on either side of them and decide the relation among
them. They are also called Relational operators.
Assume variable a holds the value 10 and variable b holds the value 20, thenOperator Description Example
==
If the values of two operands are equal, then the condition
becomes true.
(a == b)
is not
true.
!= If values of two operands are not equal, then condition
becomes true.
(a!= b) is
true.
>
If the value of left operand is greater than the value of right
operand, then condition becomes true.
(a > b) is
not true.
<
If the value of left operand is less than the value of right
operand, then condition becomes true.
(a < b) is
true.
>=
If the value of left operand is greater than or equal to the
value of right operand, then condition becomes true.
(a >= b)
is not
true.
<=
If the value of left operand is less than or equal to the value
of right operand, then condition becomes true.
(a <= b)
is true.
Example
Assume variable a holds 10 and variable b holds 20, then-
#!/usr/bin/python3
a = 21
b = 10
if ( a == b ):
 print ("Line 1 - a is equal to b")
else:
Python 3
33
 print ("Line 1 - a is not equal to b")
if ( a != b ):
 print ("Line 2 - a is not equal to b")
else:
 print ("Line 2 - a is equal to b")
if ( a < b ):
 print ("Line 3 - a is less than b" )
else:
 print ("Line 3 - a is not less than b")
if ( a > b ):
 print ("Line 4 - a is greater than b")
else:
 print ("Line 4 - a is not greater than b")
a,b=b,a #values of a and b swapped. a becomes 10, b becomes 21
if ( a <= b ):
 print ("Line 5 - a is either less than or equal to b")
else:
 print ("Line 5 - a is neither less than nor equal to b")
if ( b >= a ):
 print ("Line 6 - b is either greater than or equal to b")
else:
 print ("Line 6 - b is neither greater than nor equal to b")
When you execute the above program, it produces the following resultLine 1 - a is not equal to b
Line 2 - a is not equal to b
Line 3 - a is not less than b
Line 4 - a is greater than b
Line 5 - a is either less than or equal to b
Line 6 - b is either greater than or equal to b
Python Assignment Operators
Assume variable a holds 10 and variable b holds 20, thenOperator Description Example
= Assigns values from right side operands to
left side operand
c = a + b assigns
value of a + b into c
+= Add AND It adds right operand to the left operand
and assign the result to left operand
c += a is equivalent
to c = c + a
Python 3
34
-= Subtract AND It subtracts right operand from the left
operand and assign the result to left
operand
c -= a is equivalent
to c = c - a
*= Multiply AND It multiplies right operand with the left
operand and assign the result to left
operand
c *= a is equivalent
to c = c * a
/= Divide AND It divides left operand with the right
operand and assign the result to left
operand
c /= a is equivalent
to c = c / ac /= a is
equivalent to c = c /
a
%= Modulus AND It takes modulus using two operands and
assign the result to left operand
c %= a is equivalent
to c = c % a
**= Exponent AND Performs exponential (power) calculation
on operators and assign value to the left
operand
c **= a is
equivalent to c = c
** a
//= Floor Division It performs floor division on operators and
assign value to the left operand
c //= a is equivalent
to c = c // a
Example
Assume variable a holds 10 and variable b holds 20, then-
#!/usr/bin/python3
a = 21
b = 10
c = 0
c = a + b
print ("Line 1 - Value of c is ", c)
c += a
print ("Line 2 - Value of c is ", c )
c *= a
print ("Line 3 - Value of c is ", c )
Python 3
35
c /= a
print ("Line 4 - Value of c is ", c )
c = 2
c %= a
print ("Line 5 - Value of c is ", c)
c **= a
print ("Line 6 - Value of c is ", c)
c //= a
print ("Line 7 - Value of c is ", c)
When you execute the above program, it produces the following resultLine 1 - Value of c is 31
Line 2 - Value of c is 52
Line 3 - Value of c is 1092
Line 4 - Value of c is 52.0
Line 5 - Value of c is 2
Line 6 - Value of c is 2097152
Line 7 - Value of c is 99864
Python Bitwise Operators
Bitwise operator works on bits and performs bit-by-bit operation. Assume if a = 60; and
b = 13; Now in binary format they will be as followsa = 0011 1100
b = 0000 1101
-----------------
a&b = 0000 1100
a|b = 0011 1101
a^b = 0011 0001
~a = 1100 0011
Pyhton's built-in function bin() can be used to obtain binary representation of an integer
number.
Python 3
36
The following Bitwise operators are supported by Python languageOperator Description Example
& Binary AND Operator copies a bit to the result, if it
exists in both operands
(a & b) (means 0000
1100)
| Binary OR It copies a bit, if it exists in either
operand.
(a | b) = 61 (means
0011 1101)
^ Binary XOR It copies the bit, if it is set in one operand
but not both.
(a ^ b) = 49 (means
0011 0001)
~ Binary Ones
Complement
It is unary and has the effect of 'flipping'
bits.
(~a ) = -61 (means
1100 0011 in 2's
complement form
due to a signed
binary number.
<< Binary Left Shift The left operand’s value is moved left by
the number of bits specified by the right
operand.
a << = 240 (means
1111 0000)
>> Binary Right Shift The left operand’s value is moved right
by the number of bits specified by the
right operand.
a >> = 15 (means
0000 1111)
Example
#!/usr/bin/python3
a = 60 # 60 = 0011 1100
b = 13 # 13 = 0000 1101
print ('a=',a,':',bin(a),'b=',b,':',bin(b))
c = 0
c = a & b; # 12 = 0000 1100
print ("result of AND is ", c,':',bin(c))
c = a | b; # 61 = 0011 1101
print ("result of OR is ", c,':',bin(c))
Python 3
37
c = a ^ b; # 49 = 0011 0001
print ("result of EXOR is ", c,':',bin(c))
c = ~a; # -61 = 1100 0011
print ("result of COMPLEMENT is ", c,':',bin(c))
c = a << 2; # 240 = 1111 0000
print ("result of LEFT SHIFT is ", c,':',bin(c))
c = a >> 2; # 15 = 0000 1111
print ("result of RIGHT SHIFT is ", c,':',bin(c))
When you execute the above program, it produces the following resulta= 60 : 0b111100 b= 13 : 0b1101
result of AND is 12 : 0b1100
result of OR is 61 : 0b111101
result of EXOR is 49 : 0b110001
result of COMPLEMENT is -61 : -0b111101
result of LEFT SHIFT is 240 : 0b11110000
result of RIGHT SHIFT is 15 : 0b111
Python Logical Operators
The following logical operators are supported by Python language. Assume variable a holds
True and variable b holds False thenOperator Description Example
and Logical
AND
If both the operands are true then condition
becomes true.
(a and b) is
False.
or Logical OR If any of the two operands are non-zero then
condition becomes true.
(a or b) is
True.
not Logical NOT Used to reverse the logical state of its operand. Not(a and b)
is True.
Python 3
38
Python Membership Operators
Python’s membership operators test for membership in a sequence, such as strings, lists,
or tuples. There are two membership operators as explained belowOperator Description Example
in Evaluates to true, if it finds a variable
in the specified sequence and false
otherwise.
x in y, here in results in
a 1 if x is a member of
sequence y.
not in Evaluates to true, if it does not find a
variable in the specified sequence and
false otherwise.
x not in y, here not in
results in a 1 if x is not
a member of sequence
y.
Example
#!/usr/bin/python3
a = 10
b = 20
list = [1, 2, 3, 4, 5 ]
if ( a in list ):
 print ("Line 1 - a is available in the given list")
else:
 print ("Line 1 - a is not available in the given list")
if ( b not in list ):
 print ("Line 2 - b is not available in the given list")
else:
 print ("Line 2 - b is available in the given list")
c=b/a
if ( c in list ):
 print ("Line 3 - a is available in the given list")
else:
print ("Line 3 - a is not available in the given list")
Python 3
39

When you execute the above program, it produces the following resultLine 1 - a is not available in the given list
Line 2 - b is not available in the given list
Line 3 - a is available in the given list
Python Identity Operators
Identity operators compare the memory locations of two objects. There are two Identity
operators as explained below:
Operator Description Example
is Evaluates to true if the variables on
either side of the operator point to the
same object and false otherwise.
x is y, here is results
in 1 if id(x) equals
id(y).
is not Evaluates to false if the variables on
either side of the operator point to the
same object and true otherwise.
x is not y, here is
not results in 1 if id(x)
is not equal to id(y).
Example
#!/usr/bin/python3
a = 20
b = 20
print ('Line 1','a=',a,':',id(a), 'b=',b,':',id(b))
if ( a is b ):
 print ("Line 2 - a and b have same identity")
else:
 print ("Line 2 - a and b do not have same identity")
if ( id(a) == id(b) ):
 print ("Line 3 - a and b have same identity")
else:
 print ("Line 3 - a and b do not have same identity")
Python 3
40
b = 30
print ('Line 4','a=',a,':',id(a), 'b=',b,':',id(b))
if ( a is not b ):
 print ("Line 5 - a and b do not have same identity")
else:
 print ("Line 5 - a and b have same identity")
When you execute the above program, it produces the following resultLine 1 a= 20 : 1594701888 b= 20 : 1594701888
Line 2 - a and b have same identity
Line 3 - a and b have same identity
Line 4 a= 20 : 1594701888 b= 30 : 1594702048
Line 5 - a and b do not have same identity
Python Operators Precedence
The following table lists all the operators from highest precedence to the lowest.
Operator Description
** Exponentiation (raise to the power)
~ + - Ccomplement, unary plus and minus (method names for
the last two are +@ and -@)
* / % // Multiply, divide, modulo and floor division
+ - Addition and subtraction
>> << Right and left bitwise shift
& Bitwise 'AND'
^ | Bitwise exclusive `OR' and regular `OR'
<= < > >= Comparison operators
<> == != Equality operators
Python 3
41
= %= /= //= -= += *=
**=
Assignment operators
is is not Identity operators
in not in Membership operators
not or and Logical operators
Operator precedence affects the evaluation of an an expression.
For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because the operator * has
higher precedence than +, so it first multiplies 3*2 and then is added to 7.
Here, the operators with the highest precedence appear at the top of the table, those with
the lowest appear at the bottom.
Example
#!/usr/bin/python3
a = 20
b = 10
c = 15
d = 5
print ("a:%d b:%d c:%d d:%d" % (a,b,c,d ))
e = (a + b) * c / d #( 30 * 15 ) / 5
print ("Value of (a + b) * c / d is ", e)
e = ((a + b) * c) / d # (30 * 15 ) / 5
print ("Value of ((a + b) * c) / d is ", e)
e = (a + b) * (c / d) # (30) * (15/5)
print ("Value of (a + b) * (c / d) is ", e)
e = a + (b * c) / d # 20 + (150/5)
print ("Value of a + (b * c) / d is ", e)
When you execute the above program, it produces the following resulta:20 b:10 c:15 d:5
Value of (a + b) * c / d is 90.0
Python 3
42
Value of ((a + b) * c) / d is 90.0
Value of (a + b) * (c / d) is 90.0
Value of a + (b * c) / d is 50.0
Python 3
43
Decision-making is the anticipation of conditions occurring during the execution of a
program and specified actions taken according to the conditions.
Decision structures evaluate multiple expressions, which produce TRUE or FALSE as the
outcome. You need to determine which action to take and which statements to execute if
the outcome is TRUE or FALSE otherwise.
Following is the general form of a typical decision making structure found in most of the
programming languagesPython programming language assumes any non-zero and non-null values as TRUE, and
any zero or null values as FALSE value.
Python programming language provides the following types of decision-making
statements.
Statement Description
if statements An if statement consists of a Boolean expression followed by
one or more statements.
if...else statements
An if statement can be followed by an optional else
statement, which executes when the boolean expression is
FALSE.
7. Python 3 – Decision Making 
Python 3
44
nested if statements You can use one if or else if statement inside
another if or else if statement(s).
Let us go through each decision-making statement quickly.
IF Statement
The IF statement is similar to that of other languages. The if statement contains a logical
expression using which the data is compared and a decision is made based on the result
of the comparison.
Syntax
if expression:
 statement(s)
If the boolean expression evaluates to TRUE, then the block of statement(s) inside the if
statement is executed. In Python, statements in a block are uniformly indented after the
: symbol. If boolean expression evaluates to FALSE, then the first set of code after the
end of block is executed.
Flow Diagram
Example
#!/usr/bin/python3
var1 = 100
if var1:
 print ("1 - Got a true expression value")
 print (var1)
Python 3
45
var2 = 0
if var2:
 print ("2 - Got a true expression value")
 print (var2)
print ("Good bye!")
When the above code is executed, it produces the following result −
1 - Got a true expression value
100
Good bye!
IF...ELIF...ELSE Statements
An else statement can be combined with an if statement. An else statement contains a
block of code that executes if the conditional expression in the if statement resolves to 0
or a FALSE value.
The else statement is an optional statement and there could be at the most only
one else statement following if.
Syntax
The syntax of the if...else statement isif expression:
 statement(s)
else:
 statement(s)
Python 3
46
Flow Diagram
Example
#!/usr/bin/python3
amount=int(input("Enter amount: "))
if amount<1000:
 discount=amount*0.05
 print ("Discount",discount)
else:
 discount=amount*0.10
 print ("Discount",discount)

print ("Net payable:",amount-discount)
In the above example, discount is calculated on the input amount. Rate of discount is 5%,
if the amount is less than 1000, and 10% if it is above 10000. When the above code is
executed, it produces the following resultEnter amount: 600
Discount 30.0
Net payable: 570.0
Enter amount: 1200
Discount 120.0
Python 3
47
Net payable: 1080.0
The elif Statement
The elif statement allows you to check multiple expressions for TRUE and execute a block
of code as soon as one of the conditions evaluates to TRUE.
Similar to the else, the elif statement is optional. However, unlike else, for which there
can be at the most one statement, there can be an arbitrary number of elif statements
following an if.
Syntax
if expression1:
 statement(s)
elif expression2:
 statement(s)
elif expression3:
 statement(s)
else:
 statement(s)
Core Python does not provide switch or case statements as in other languages, but we can
use if..elif...statements to simulate switch case as followsExample
#!/usr/bin/python3
amount=int(input("Enter amount: "))
if amount<1000:
 discount=amount*0.05
 print ("Discount",discount)
elif amount<5000:
 discount=amount*0.10
 print ("Discount",discount)
else:
 discount=amount*0.15
 print ("Discount",discount)
print ("Net payable:",amount-discount)
When the above code is executed, it produces the following result-
Python 3
48
Enter amount: 600
Discount 30.0
Net payable: 570.0
Enter amount: 3000
Discount 300.0
Net payable: 2700.0
Enter amount: 6000
Discount 900.0
Net payable: 5100.0
Nested IF Statements
There may be a situation when you want to check for another condition after a condition
resolves to true. In such a situation, you can use the nested if construct.
In a nested if construct, you can have an if...elif...else construct inside another
if...elif...else construct.
Syntax
The syntax of the nested if...elif...else construct may beif expression1:
 statement(s)
 if expression2:
 statement(s)
 elif expression3:
 statement(s)
 else
 statement(s)
elif expression4:
 statement(s)
else:
 statement(s)
Example
# !/usr/bin/python3
num=int(input("enter number"))
Python 3
49
if num%2==0:
 if num%3==0:
 print ("Divisible by 3 and 2")
 else:
 print ("divisible by 2 not divisible by 3")
else:
 if num%3==0:
 print ("divisible by 3 not divisible by 2")
 else:
 print ("not Divisible by 2 not divisible by 3")
When the above code is executed, it produces the following resultenter number8
divisible by 2 not divisible by 3
enter number15
divisible by 3 not divisible by 2
enter number12
Divisible by 3 and 2
enter number5
not Divisible by 2 not divisible by 3
Single Statement Suites
If the suite of an if clause consists only of a single line, it may go on the same line as the
header statement.
Here is an example of a one-line if clause-
#!/usr/bin/python3
var = 100
if ( var == 100 ) : print ("Value of expression is 100")
print ("Good bye!")
When the above code is executed, it produces the following resultValue of expression is 100
Good bye!
Python 3
50
Python 3
51
In general, statements are executed sequentially- The first statement in a function is
executed first, followed by the second, and so on. There may be a situation when you need
to execute a block of code several number of times.
Programming languages provide various control structures that allow more complicated
execution paths.
A loop statement allows us to execute a statement or group of statements multiple times.
The following diagram illustrates a loop statement.
Python programming language provides the following types of loops to handle looping
requirements.
Loop Type Description
while loop Repeats a statement or group of statements while a given
condition is TRUE. It tests the condition before executing the
loop body.
for loop Executes a sequence of statements multiple times and
abbreviates the code that manages the loop variable.
8. Python 3 – Loops 
Python 3
52
nested loops You can use one or more loop inside any another while, or
for loop.
while Loop Statements
A while loop statement in Python programming language repeatedly executes a target
statement as long as a given condition is true.
Syntax
The syntax of a while loop in Python programming language iswhile expression:
 statement(s)
Here, statement(s) may be a single statement or a block of statements with uniform
indent. The condition may be any expression, and true is any non-zero value. The loop
iterates while the condition is true.
When the condition becomes false, program control passes to the line immediately
following the loop.
In Python, all the statements indented by the same number of character spaces after a
programming construct are considered to be part of a single block of code. Python uses
indentation as its method of grouping statements.
Flow Diagram
Python 3
53
Here, a key point of the while loop is that the loop might not ever run. When the condition
is tested and the result is false, the loop body will be skipped and the first statement after
the while loop will be executed.
Example
#!/usr/bin/python3
count = 0
while (count < 9):
 print ('The count is:', count)
 count = count + 1
print ("Good bye!")
When the above code is executed, it produces the following resultThe count is: 0
The count is: 1
The count is: 2
The count is: 3
The count is: 4
Python 3
54
The count is: 5
The count is: 6
The count is: 7
The count is: 8
Good bye!
The block here, consisting of the print and increment statements, is executed repeatedly
until count is no longer less than 9. With each iteration, the current value of the index
count is displayed and then increased by 1.
The Infinite Loop
A loop becomes infinite loop if a condition never becomes FALSE. You must be cautious
when using while loops because of the possibility that this condition never resolves to a
FALSE value. This results in a loop that never ends. Such a loop is called an infinite loop.
An infinite loop might be useful in client/server programming where the server needs to
run continuously so that client programs can communicate with it as and when required.
#!/usr/bin/python3
var = 1
while var == 1 : # This constructs an infinite loop
 num = int(input("Enter a number :"))
 print ("You entered: ", num)
print ("Good bye!")
When the above code is executed, it produces the following resultEnter a number :20
You entered: 20
Enter a number :29
You entered: 29
Enter a number :3
You entered: 3
Enter a number :11
You entered: 11
Enter a number :22
You entered: 22
Enter a number :Traceback (most recent call last):
 File "examples\test.py", line 5, in
 num = int(input("Enter a number :"))
KeyboardInterrupt
Python 3
55
The above example goes in an infinite loop and you need to use CTRL+C to exit the
program.
Using else Statement with Loops
Python supports having an else statement associated with a loop statement.
 If the else statement is used with a for loop, the else statement is executed when
the loop has exhausted iterating the list.
 If the else statement is used with a while loop, the else statement is executed
when the condition becomes false.
The following example illustrates the combination of an else statement with a while
statement that prints a number as long as it is less than 5, otherwise the else statement
gets executed.
#!/usr/bin/python3
count = 0
while count < 5:
 print (count, " is less than 5")
 count = count + 1
else:
 print (count, " is not less than 5")
When the above code is executed, it produces the following result0 is less than 5
1 is less than 5
2 is less than 5
3 is less than 5
4 is less than 5
5 is not less than 5
Single Statement Suites
Similar to the if statement syntax, if your while clause consists only of a single statement,
it may be placed on the same line as the while header.
Here is the syntax and example of a one-line while clause-
#!/usr/bin/python3
flag = 1
while (flag): print ('Given flag is really true!')
print ("Good bye!")
The above example goes into an infinite loop and you need to press CTRL+C keys to exit.
Python 3
56
for Loop Statements
The for statement in Python has the ability to iterate over the items of any sequence, such
as a list or a string.
Syntax
for iterating_var in sequence:
 statements(s)
If a sequence contains an expression list, it is evaluated first. Then, the first item in the
sequence is assigned to the iterating variable iterating_var. Next, the statements block is
executed. Each item in the list is assigned to iterating_var, and the statement(s) block is
executed until the entire sequence is exhausted.
Flow Diagram
Python 3
57
The range() function
The built-in function range() is the right function to iterate over a sequence of numbers.
It generates an iterator of arithmetic progressions.
>>> range(5)
range(0, 5)
>>> list(range(5))
[0, 1, 2, 3, 4]
range() generates an iterator to progress integers starting with 0 upto n-1. To obtain a
list object of the sequence, it is typecasted to list(). Now this list can be iterated using the
for statement.
>>> for var in list(range(5)):
print (var)
This will produce the following output.
0
1
2
3
4
Example
#!/usr/bin/python3
for letter in 'Python': # traversal of a string sequence
 print ('Current Letter :', letter)
print()
fruits = ['banana', 'apple', 'mango']
for fruit in fruits: # traversal of List sequence
 print ('Current fruit :', fruit)
print ("Good bye!")
When the above code is executed, it produces the following result −
Current Letter : P
Current Letter : y
Python 3
58
Current Letter : t
Current Letter : h
Current Letter : o
Current Letter : n
Current fruit : banana
Current fruit : apple
Current fruit : mango
Good bye!
Iterating by Sequence Index
An alternative way of iterating through each item is by index offset into the sequence
itself. Following is a simple example-
#!/usr/bin/python3
fruits = ['banana', 'apple', 'mango']
for index in range(len(fruits)):
 print ('Current fruit :', fruits[index])
print ("Good bye!")
When the above code is executed, it produces the following resultCurrent fruit : banana
Current fruit : apple
Current fruit : mango
Good bye!
Here, we took the assistance of the len() built-in function, which provides the total number
of elements in the tuple as well as the range() built-in function to give us the actual
sequence to iterate over.
Using else Statement with Loops
Python supports having an else statement associated with a loop statement.
 If the else statement is used with a for loop, the else block is executed only if for
loops terminates normally (and not by encountering break statement).
 If the else statement is used with a while loop, the else statement is executed
when the condition becomes false.
Python 3
59
The following example illustrates the combination of an else statement with a for
statement that searches for even number in given list.
#!/usr/bin/python3
numbers=[11,33,55,39,55,75,37,21,23,41,13]
for num in numbers:
 if num%2==0:
 print ('the list contains an even number')
 break
else:
 print ('the list doesnot contain even number')
When the above code is executed, it produces the following resultthe list does not contain even number
Nested loops
Python programming language allows the use of one loop inside another loop. The
following section shows a few examples to illustrate the concept.
Syntax
for iterating_var in sequence:
 for iterating_var in sequence:
 statements(s)
 statements(s)
The syntax for a nested while loop statement in Python programming language is as
followswhile expression:
 while expression:
 statement(s)
 statement(s)
A final note on loop nesting is that you can put any type of loop inside any other type of
loop. For example a for loop can be inside a while loop or vice versa.
Example
The following program uses a nested-for loop to display multiplication tables from 1-10.
#!/usr/bin/python3
import sys
Python 3
60
for i in range(1,11):
 for j in range(1,11):
 k=i*j
 print (k, end=' ')
 print()
The print() function inner loop has end=' ' which appends a space instead of default
newline. Hence, the numbers will appear in one row.
Last print() will be executed at the end of inner for loop.
When the above code is executed, it produces the following result −
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
3 6 9 12 15 18 21 24 27 30
4 8 12 16 20 24 28 32 36 40
5 10 15 20 25 30 35 40 45 50
6 12 18 24 30 36 42 48 54 60
7 14 21 28 35 42 49 56 63 70
8 16 24 32 40 48 56 64 72 80
9 18 27 36 45 54 63 72 81 90
10 20 30 40 50 60 70 80 90 100
Loop Control Statements
The Loop control statements change the execution from its normal sequence. When the
execution leaves a scope, all automatic objects that were created in that scope are
destroyed.
Python supports the following control statements.
Control Statement Description
break statement Terminates the loop statement and transfers
execution to the statement immediately
following the loop.
continue statement Causes the loop to skip the remainder of its
body and immediately retest its condition prior
to reiterating.
Python 3
61
pass statement The pass statement in Python is used when a
statement is required syntactically but you do
not want any command or code to execute.
Let us go through the loop control statements briefly.
break statement
The break statement is used for premature termination of the current loop. After
abandoning the loop, execution at the next statement is resumed, just like the traditional
break statement in C.
The most common use of break is when some external condition is triggered requiring a
hasty exit from a loop. The break statement can be used in both while and for loops.
If you are using nested loops, the break statement stops the execution of the innermost
loop and starts executing the next line of the code after the block.
Syntax
The syntax for a break statement in Python is as followsbreak
Flow Diagram
Python 3
62
Example
#!/usr/bin/python3
for letter in 'Python': # First Example
 if letter == 'h':
 break
 print ('Current Letter :', letter)

var = 10 # Second Example
while var > 0:
 print ('Current variable value :', var)
 var = var -1
 if var == 5:
 break
print ("Good bye!")
When the above code is executed, it produces the following resultCurrent Letter : P
Current Letter : y
Current Letter : t
Python 3
63
Current variable value : 10
Current variable value : 9
Current variable value : 8
Current variable value : 7
Current variable value : 6
Good bye!
The following program demonstrates the use of break in a for loop iterating over a list.
User inputs a number, which is searched in the list. If it is found, then the loop terminates
with the 'found' message.
#!/usr/bin/python3
no=int(input('any number: '))
numbers=[11,33,55,39,55,75,37,21,23,41,13]
for num in numbers:
 if num==no:
 print ('number found in list')
 break
else:
 print ('number not found in list')
The above program will produce the following outputany number: 33
number found in list
any number: 5
number not found in list
continue Statement
The continue statement in Python returns the control to the beginning of the current loop.
When encountered, the loop starts next iteration without executing the remaining
statements in the current iteration.
The continue statement can be used in both while and for loops.
Syntax
continue
Python 3
64
Flow Diagram
Example
#!/usr/bin/python3
for letter in 'Python': # First Example
 if letter == 'h':
 continue
 print ('Current Letter :', letter)
var = 10 # Second Example
while var > 0:
 var = var -1
 if var == 5:
 continue
 print ('Current variable value :', var)
print ("Good bye!")
When the above code is executed, it produces the following resultCurrent Letter : P
Python 3
65
Current Letter : y
Current Letter : t
Current Letter : o
Current Letter : n
Current variable value : 9
Current variable value : 8
Current variable value : 7
Current variable value : 6
Current variable value : 4
Current variable value : 3
Current variable value : 2
Current variable value : 1
Current variable value : 0
Good bye!
pass Statement
It is used when a statement is required syntactically but you do not want any command
or code to execute.
The pass statement is a null operation; nothing happens when it executes. The
pass statement is also useful in places where your code will eventually go, but has not
been written yet i.e. in stubs).
Syntax
pass
Example
#!/usr/bin/python3
for letter in 'Python':
 if letter == 'h':
 pass
 print ('This is pass block')
 print ('Current Letter :', letter)
print ("Good bye!")
When the above code is executed, it produces the following result-
Python 3
66
Current Letter : P
Current Letter : y
Current Letter : t
This is pass block
Current Letter : h
Current Letter : o
Current Letter : n
Good bye!
Iterator and Generator
Iterator is an object, which allows a programmer to traverse through all the elements of
a collection, regardless of its specific implementation. In Python, an iterator object
implements two methods, iter() and next().
String, List or Tuple objects can be used to create an Iterator.
list=[1,2,3,4]
it = iter(list) # this builds an iterator object
print (next(it)) #prints next available element in iterator
Iterator object can be traversed using regular for statement
!usr/bin/python3
for x in it:
 print (x, end=" ")
or using next() function
while True:
 try:
 print (next(it))
 except StopIteration:
 sys.exit() #you have to import sys module for this
A generator is a function that produces or yields a sequence of values using yield method.
When a generator function is called, it returns a generator object without even beginning
execution of the function. When the next() method is called for the first time, the function
starts executing, until it reaches the yield statement, which returns the yielded value. The
yield keeps track i.e. remembers the last execution and the second next() call continues
from previous value.
The following example defines a generator, which generates an iterator for all the Fibonacci
numbers.
!usr/bin/python3
Python 3
67
import sys
def fibonacci(n): #generator function
 a, b, counter = 0, 1, 0
 while True:
 if (counter > n):
 return
 yield a
 a, b = b, a + b
 counter += 1
f = fibonacci(5) #f is iterator object
while True:
 try:
 print (next(f), end=" ")
 except StopIteration:
 sys.exit()
Python 3
68
Number data types store numeric values. They are immutable data types. This means,
changing the value of a number data type results in a newly allocated object.
Number objects are created when you assign a value to them. For examplevar1 = 1
var2 = 10
You can also delete the reference to a number object by using the del statement. The
syntax of the del statement is −
del var1[,var2[,var3[....,varN]]]]
You can delete a single object or multiple objects by using the del statement. For exampledel var
del var_a, var_b
Python supports different numerical types-
 int (signed integers): They are often called just integers or ints. They are
positive or negative whole numbers with no decimal point. Integers in Python 3 are
of unlimited size. Python 2 has two integer types - int and long. There is no 'long
integer' in Python 3 anymore.
 float (floating point real values) : Also called floats, they represent real
numbers and are written with a decimal point dividing the integer and the fractional
parts. Floats may also be in scientific notation, with E or e indicating the power of
10 (2.5e2 = 2.5 x 102 = 250).
 complex (complex numbers) : are of the form a + bJ, where a and b are floats
and J (or j) represents the square root of -1 (which is an imaginary number). The
real part of the number is a, and the imaginary part is b. Complex numbers are not
used much in Python programming.
It is possible to represent an integer in hexa-decimal or octal form.
>>> number = 0xA0F #Hexa-decimal
>>> number
2575
>>> number=0o37 #Octal
>>> number
9. Python 3 – Numbers 
Python 3
69
31
Examples
Here are some examples of numbers.
int float complex
10 0.0 3.14j
100 15.20 45.j
-786 -21.9 9.322e-36j
080 32.3+e18 .876j
-0490 -90. -.6545+0J
-0x260 -32.54e100 3e+26J
0x69 70.2-E12 4.53e-7j
A complex number consists of an ordered pair of real floating-point numbers denoted by
a + bj, where a is the real part and b is the imaginary part of the complex number.
Number Type Conversion
Python converts numbers internally in an expression containing mixed types to a common
type for evaluation. Sometimes, you need to coerce a number explicitly from one type to
another to satisfy the requirements of an operator or function parameter.
 Type int(x) to convert x to a plain integer.
 Type long(x) to convert x to a long integer.
 Type float(x) to convert x to a floating-point number.
 Type complex(x) to convert x to a complex number with real part x and imaginary
part zero.
 Type complex(x, y) to convert x and y to a complex number with real part x and
imaginary part y. x and y are numeric expressions.
Python 3
70
Mathematical Functions
Python includes the following functions that perform mathematical calculations.
Function Returns ( Description )
abs(x) The absolute value of x: the (positive) distance between x and
zero.
ceil(x) The ceiling of x: the smallest integer not less than x.
cmp(x, y) -1 if x < y, 0 if x == y, or 1 if x > y. Deprecated in Python 3;
Instead use return (x>y)-(x<y).
exp(x) The exponential of x: ex
fabs(x) The absolute value of x.
floor(x) The floor of x: the largest integer not greater than x.
log(x) The natural logarithm of x, for x> 0.
log10(x) The base-10 logarithm of x for x> 0.
max(x1, x2,...) The largest of its arguments: the value closest to positive infinity.
min(x1, x2,...) The smallest of its arguments: the value closest to negative
infinity.
modf(x) The fractional and integer parts of x in a two-item tuple. Both
parts have the same sign as x. The integer part is returned as a
float.
pow(x, y) The value of x**y.
round(x [,n]) x rounded to n digits from the decimal point. Python rounds away
from zero as a tie-breaker: round(0.5) is 1.0 and round(-0.5) is -
1.0.
sqrt(x) The square root of x for x > 0.
Let us learn about these functions in detail. 
Python 3
71
Number abs() Method
Description
The abs() method returns the absolute value of x i.e. the positive distance between x and
zero.
Syntax
Following is the syntax for abs() methodabs( x )
Parameters
x - This is a numeric expression.
Return Value
This method returns the absolute value of x.
Example
The following example shows the usage of the abs() method.
#!/usr/bin/python3
print ("abs(-45) : ", abs(-45))
print ("abs(100.12) : ", abs(100.12))
When we run the above program, it produces the following resultabs(-45) : 45
abs(100.12) : 100.12
Numberceil() Method
Description
The ceil() method returns the ceiling value of x i.e. the smallest integer not less than x.
Syntax
Following is the syntax for the ceil() methodimport math
math.ceil( x )
Note: This function is not accessible directly, so we need to import math module and then
we need to call this function using the math static object.
Python 3
72
Parameters
x - This is a numeric expression.
Return Value
This method returns the smallest integer not less than x.
Example
The following example shows the usage of the ceil() method.
#!/usr/bin/python3
import math # This will import math module
print ("math.ceil(-45.17) : ", math.ceil(-45.17))
print ("math.ceil(100.12) : ", math.ceil(100.12))
print ("math.ceil(100.72) : ", math.ceil(100.72))
print ("math.ceil(math.pi) : ", math.ceil(math.pi))
When we run the above program, it produces the following resultmath.ceil(-45.17) : -45
math.ceil(100.12) : 101
math.ceil(100.72) : 101
math.ceil(math.pi) : 4
Number exp() Method
Description
The exp() method returns exponential of x: ex
.
Syntax
Following is the syntax for the exp() methodimport math
math.exp( x )
Note: This function is not accessible directly. Therefore, we need to import the math
module and then we need to call this function using the math static object.
Parameters
X - This is a numeric expression.
Python 3
73
Return Value
This method returns exponential of x: ex.
Example
The following example shows the usage of exp() method.
#!/usr/bin/python3
import math # This will import math module
print ("math.exp(-45.17) : ", math.exp(-45.17))
print ("math.exp(100.12) : ", math.exp(100.12))
print ("math.exp(100.72) : ", math.exp(100.72))
print ("math.exp(math.pi) : ", math.exp(math.pi))
When we run the above program, it produces the following resultmath.exp(-45.17) : 2.4150062132629406e-20
math.exp(100.12) : 3.0308436140742566e+43
math.exp(100.72) : 5.522557130248187e+43
math.exp(math.pi) : 23.140692632779267
Number fabs() Method
Description
The fabs() method returns the absolute value of x. Although similar to the abs() function,
there are differences between the two functions. They are-
 abs() is a built in function whereas fabs() is defined in math module.
 fabs() function works only on float and integer whereas abs() works with complex
number also.
Syntax
Following is the syntax for the fabs() methodimport math
math.fabs( x )
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This is a numeric value.
Python 3
74
Return Value
This method returns the absolute value of x.
Example
The following example shows the usage of the fabs() method.
#!/usr/bin/python3
import math # This will import math module
print ("math.fabs(-45.17) : ", math.fabs(-45.17))
print ("math.fabs(100.12) : ", math.fabs(100.12))
print ("math.fabs(100.72) : ", math.fabs(100.72))
print ("math.fabs(math.pi) : ", math.fabs(math.pi))
When we run the above program, it produces following resultmath.fabs(-45.17) : 45.17
math.fabs(100) : 100.0
math.fabs(100.72) : 100.72
math.fabs(math.pi) : 3.141592653589793
Number floor() Method
Description
The floor() method returns the floor of x i.e. the largest integer not greater than x.
Syntax
Following is the syntax for the floor() methodimport math
math.floor( x )
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This is a numeric expression.
Return Value
This method returns the largest integer not greater than x.
Example
Python 3
75
The following example shows the usage of the floor() method.
#!/usr/bin/python3
import math # This will import math module
print ("math.floor(-45.17) : ", math.floor(-45.17))
print ("math.floor(100.12) : ", math.floor(100.12))
print ("math.floor(100.72) : ", math.floor(100.72))
print ("math.floor(math.pi) : ", math.floor(math.pi))
When we run the above program, it produces the following resultmath.floor(-45.17) : -46
math.floor(100.12) : 100
math.floor(100.72) : 100
math.floor(math.pi) : 3
Number log() Method
Description
The log() method returns the natural logarithm of x, for x > 0.
Syntax
Following is the syntax for the log() methodimport math
math.log( x )
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This is a numeric expression.
Return Value
This method returns natural logarithm of x, for x > 0.
Example
The following example shows the usage of the log() method.
Python 3
76
#!/usr/bin/python3
import math # This will import math module
print ("math.log(100.12) : ", math.log(100.12))
print ("math.log(100.72) : ", math.log(100.72))
print ("math.log(math.pi) : ", math.log(math.pi))
When we run the above program, it produces the following resultmath.log(100.12) : 4.6063694665635735
math.log(100.72) : 4.612344389736092
math.log(math.pi) : 1.1447298858494002
Number log10() Method
Description
The log10() method returns base-10 logarithm of x for x > 0.
Syntax
Following is the syntax for log10() methodimport math
math.log10( x )
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This is a numeric expression.
Return Value
This method returns the base-10 logarithm of x for x > 0.
Example
The following example shows the usage of the log10() method.
#!/usr/bin/python3
import math # This will import math module
print ("math.log10(100.12) : ", math.log10(100.12))
print ("math.log10(100.72) : ", math.log10(100.72))
print ("math.log10(119) : ", math.log10(119))
print ("math.log10(math.pi) : ", math.log10(math.pi))
Python 3
77
When we run the above program, it produces the following resultmath.log10(100.12) : 2.0005208409361854
math.log10(100.72) : 2.003115717099806
math.log10(119) : 2.0755469613925306
math.log10(math.pi) : 0.49714987269413385
Number max() Method
Description
The max() method returns the largest of its arguments i.e. the value closest to positive
infinity.
Syntax
Following is the syntax for max() methodmax( x, y, z, .... )
Parameters
 x - This is a numeric expression.
 y - This is also a numeric expression.
 z - This is also a numeric expression.
Return Value
This method returns the largest of its arguments.
Example
The following example shows the usage of the max() method.
#!/usr/bin/python3
print ("max(80, 100, 1000) : ", max(80, 100, 1000))
print ("max(-20, 100, 400) : ", max(-20, 100, 400))
print ("max(-80, -20, -10) : ", max(-80, -20, -10))
print ("max(0, 100, -400) : ", max(0, 100, -400))
When we run the above program, it produces the following resultmax(80, 100, 1000) : 1000
max(-20, 100, 400) : 400
max(-80, -20, -10) : -10
Python 3
78
max(0, 100, -400) : 100
Number min() Method
Description
The method min() returns the smallest of its arguments i.e. the value closest to negative
infinity.
Syntax
Following is the syntax for the min() methodmin( x, y, z, .... )
Parameters
 x - This is a numeric expression.
 y - This is also a numeric expression.
 z - This is also a numeric expression.
Return Value
This method returns the smallest of its arguments.
Example
The following example shows the usage of the min() method.
#!/usr/bin/python3
print ("min(80, 100, 1000) : ", min(80, 100, 1000))
print ("min(-20, 100, 400) : ", min(-20, 100, 400))
print ("min(-80, -20, -10) : ", min(-80, -20, -10))
print ("min(0, 100, -400) : ", min(0, 100, -400))
When we run the above program, it produces the following resultmin(80, 100, 1000) : 80
min(-20, 100, 400) : -20
min(-80, -20, -10) : -80
min(0, 100, -400) : -400
Python 3
79
Number modf() Method
Description
The modf() method returns the fractional and integer parts of x in a two-item tuple. Both
parts have the same sign as x. The integer part is returned as a float.
Syntax
Following is the syntax for the modf() methodimport math
math.modf( x )
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This is a numeric expression.
Return Value
This method returns the fractional and integer parts of x in a two-item tuple. Both the
parts have the same sign as x. The integer part is returned as a float.
Example
The following example shows the usage of the modf() method.
#!/usr/bin/python3
import math # This will import math module
print ("math.modf(100.12) : ", math.modf(100.12))
print ("math.modf(100.72) : ", math.modf(100.72))
print ("math.modf(119) : ", math.modf(119))
print ("math.modf(math.pi) : ", math.modf(math.pi))
When we run the above program, it produces the following resultmath.modf(100.12) : (0.12000000000000455, 100.0)
math.modf(100.72) : (0.7199999999999989, 100.0)
math.modf(119) : (0.0, 119.0)
math.modf(math.pi) : (0.14159265358979312, 3.0)
Python 3
80
Number pow() Method
Return Value
This method returns the value of xy
.
Example
The following example shows the usage of the pow() method.
#!/usr/bin/python3
import math # This will import math module
print ("math.pow(100, 2) : ", math.pow(100, 2))
print ("math.pow(100, -2) : ", math.pow(100, -2))
print ("math.pow(2, 4) : ", math.pow(2, 4))
print ("math.pow(3, 0) : ", math.pow(3, 0))
When we run the above program, it produces the following resultmath.pow(100, 2) : 10000.0
math.pow(100, -2) : 0.0001
math.pow(2, 4) : 16.0
math.pow(3, 0) : 1.0
Number round() Method
Description
round() is a built-in function in Python. It returns x rounded to n digits from the decimal
point.
Syntax
Following is the syntax for the round() methodround( x [, n] )
Parameters
 x - This is a numeric expression.
 n - Represents number of digits from decimal point up to which x is to be rounded.
Default is 0.
Return Value
This method returns x rounded to n digits from the decimal point.
Python 3
81
Example
The following example shows the usage of round() method.
#!/usr/bin/python3
print ("round(70.23456) : ", round(70.23456))
print ("round(56.659,1) : ", round(56.659,1))
print ("round(80.264, 2) : ", round(80.264, 2))
print ("round(100.000056, 3) : ", round(100.000056, 3))
print ("round(-100.000056, 3) : ", round(-100.000056, 3))
When we run the above program, it produces the following resultround(70.23456) : 70
round(56.659,1) : 56.7
round(80.264, 2) : 80.26
round(100.000056, 3) : 100.0
round(-100.000056, 3) : -100.0
Number sqrt() Method
Description
The sqrt() method returns the square root of x for x > 0.
Syntax
Following is the syntax for sqrt() methodimport math
math.sqrt( x )
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This is a numeric expression.
Return Value
This method returns square root of x for x > 0.
Example
The following example shows the usage of sqrt() method.
Python 3
82
#!/usr/bin/python3
import math # This will import math module
print ("math.sqrt(100) : ", math.sqrt(100))
print ("math.sqrt(7) : ", math.sqrt(7))
print ("math.sqrt(math.pi) : ", math.sqrt(math.pi))
When we run the above program, it produces the following resultmath.sqrt(100) : 10.0
math.sqrt(7) : 2.6457513110645907
math.sqrt(math.pi) : 1.7724538509055159
Random Number Functions
Random numbers are used for games, simulations, testing, security, and privacy
applications. Python includes the following functions that are commonly used.
Function Description
choice(seq) A random item from a list, tuple, or string.
randrange ([start,] stop [,step]) A randomly selected element from range(start,
stop, step).
random() A random float r, such that 0 is less than or equal
to r and r is less than 1.
seed([x]) Sets the integer starting value used in
generating random numbers. Call this function
before calling any other random module
function. Returns None.
shuffle(lst) Randomizes the items of a list in place. Returns
None.
uniform(x, y) A random float r, such that x is less than or equal
to r and r is less than y.
Number choice() Method
Description
Python 3
83
The choice() method returns a random item from a list, tuple, or string.
Syntax
Following is the syntax for choice() methodchoice( seq )
Note: This function is not accessible directly, so we need to import the random module
and then we need to call this function using the random static object.
Parameters
seq - This could be a list, tuple, or string...
Return Value
This method returns a random item.
Example
The following example shows the usage of the choice() method.
#!/usr/bin/python3
import random
print ("returns a random number from range(100) : ",random.choice(range(100)))
print ("returns random element from list [1, 2, 3, 5, 9]) : ", random.choice([1,
2, 3, 5, 9]))
print ("returns random character from string 'Hello World' : ",
random.choice('Hello World'))
When we run the above program, it produces a result similar to the followingreturns a random number from range(100) : 19
returns random element from list [1, 2, 3, 5, 9]) : 9
returns random character from string 'Hello World' : r
Number randrange() Method
Description
The randrange() method returns a randomly selected element from range(start, stop,
step).
Syntax
Following is the syntax for the randrange() method-
Python 3
84
randrange ([start,] stop [,step])
Note: This function is not accessible directly, so we need to import the random module
and then we need to call this function using the random static object.
Parameters
 start - Start point of the range. This would be included in the range. Default is 0.
 stop - Stop point of the range. This would be excluded from the range.
 step - Value with which number is incremented. Default is 1.
Return Value
This method returns a random item from the given range.
Example
The following example shows the usage of the randrange() method.
#!/usr/bin/python3
import random
# randomly select an odd number between 1-100
print ("randrange(1,100, 2) : ", random.randrange(1, 100, 2))
# randomly select a number between 0-99
print ("randrange(100) : ", random.randrange(100))
When we run the above program, it produces the following resultrandrange(1,100, 2) : 83
randrange(100) : 93
Number random() Method
Description
The random() method returns a random floating point number in the range [0.0, 1.0].
Syntax
Following is the syntax for the random() methodrandom ( )
Note: This function is not accessible directly, so we need to import the random module
and then we need to call this function using the random static object.
Parameters
Python 3
85
NA
Return Value
This method returns a random float r, such that 0.0 <= r <= 1.0
Example
The following example shows the usage of the random() method.
#!/usr/bin/python3
import random
# First random number
print ("random() : ", random.random())
# Second random number
print ("random() : ", random.random())
When we run the above program, it produces the following resultrandom() : 0.281954791393
random() : 0.309090465205
Number seed() Method
Description
The seed() method initializes the basic random number generator. Call this function
before calling any other random module function.
Syntax
Following is the syntax for the seed() methodseed ([x], [y])
Note: This function initializes the basic random number generator.
Parameters
 x - This is the seed for the next random number. If omitted, then it takes system
time to generate the next random number. If x is an int, it is used directly.
 Y - This is version number (default is 2). str, byte or byte array object gets
converted in int. Version 1 used hash() of x.
Return Value
This method does not return any value.
Python 3
86
Example
The following example shows the usage of the seed() method.
#!/usr/bin/python3
import random
random.seed()
print ("random number with default seed", random.random())
random.seed(10)
print ("random number with int seed", random.random())
random.seed("hello",2)
print ("random number with string seed", random.random())
When we run above program, it produces following resultrandom number with default seed 0.2524977842762465
random number with int seed 0.5714025946899135
random number with string seed 0.3537754404730722
Number shuffle() Method
Description
The shuffle() method randomizes the items of a list in place.
Syntax
Following is the syntax for the shuffle() methodshuffle (lst,[random])
Note: This function is not accessible directly, so we need to import the shuffle module and
then we need to call this function using the random static object.
Parameters
 lst - This could be a list or tuple.
 random - This is an optional 0 argument function returning float between 0.0 -
1.0. Default is None.
Return Value
This method returns reshuffled list.
Example
Python 3
87
The following example shows the usage of the shuffle() method.
#!/usr/bin/python3
import random
list = [20, 16, 10, 5];
random.shuffle(list)
print ("Reshuffled list : ", list)
random.shuffle(list)
print ("Reshuffled list : ", list)
When we run the above program, it produces the following resultReshuffled list : [16, 5, 10, 20]
reshuffled list : [20, 5, 10, 16]
Number uniform() Method
Description
The uniform() method returns a random float r, such that x is less than or equal to r and
r is less than y.
Syntax
Following is the syntax for the uniform() methoduniform(x, y)
Note: This function is not accessible directly, so we need to import the uniform module
and then we need to call this function using the random static object.
Parameters
 x - Sets the lower limit of the random float.
 y - Sets the upper limit of the random float.
Return Value
This method returns a floating point number r such that x <=r < y.
Example
The following example shows the usage of the uniform() method.
#!/usr/bin/python3
import random
Python 3
88
print ("Random Float uniform(5, 10) : ", random.uniform(5, 10))
print ("Random Float uniform(7, 14) : ", random.uniform(7, 14))
Let us run the above program. This will produce the following resultRandom Float uniform(5, 10) : 5.52615217015
Random Float uniform(7, 14) : 12.5326369199
Trigonometric Functions
Python includes the following functions that perform trigonometric calculations.
Function Description
acos(x) Return the arc cosine of x, in radians.
asin(x) Return the arc sine of x, in radians.
atan(x) Return the arc tangent of x, in radians.
atan2(y, x) Return atan(y / x), in radians.
cos(x) Return the cosine of x radians.
hypot(x, y) Return the Euclidean norm, sqrt(x*x + y*y).
sin(x) Return the sine of x radians.
tan(x) Return the tangent of x radians.
degrees(x) Converts angle x from radians to degrees.
radians(x) Converts angle x from degrees to radians.
Number acos() Method
Description
The acos() method returns the arc cosine of x in radians.
Syntax
Python 3
89
Following is the syntax for acos() methodacos(x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This must be a numeric value in the range -1 to 1. If x is greater than 1 then it will
generate 'math domain error'.
Return Value
This method returns arc cosine of x, in radians.
Example
The following example shows the usage of the acos() method.
#!/usr/bin/python3
import math
print ("acos(0.64) : ", math.acos(0.64))
print ("acos(0) : ", math.acos(0))
print ("acos(-1) : ", math.acos(-1))
print ("acos(1) : ", math.acos(1))
When we run the above program, it produces the following resultacos(0.64) : 0.876298061168
acos(0) : 1.57079632679
acos(-1) : 3.14159265359
acos(1) : 0.0
Number asin() Method
Description
The asin() method returns the arc sine of x (in radians).
Syntax
Following is the syntax for the asin() methodasin(x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function usingthe math static object.
Python 3
90
Parameters
x - This must be a numeric value in the range -1 to 1. If x is greater than 1 then it will
generate 'math domain error'.
Return Value
This method returns arc sine of x, in radians.
Example
The following example shows the usage of the asin() method.
#!/usr/bin/python3
import math
print ("asin(0.64) : ", math.asin(0.64))
print ("asin(0) : ", math.asin(0))
print ("asin(-1) : ", math.asin(-1))
print ("asin(1) : ", math.asin(1))
When we run the above program, it produces the following resultasin(0.64) : 0.694498265627
asin(0) : 0.0
asin(-1) : -1.57079632679
asin(1) : 1.5707963267
Number atan() Method
Description
The atan() method returns the arc tangent of x, in radians.
Syntax
Following is the syntax for atan() methodatan(x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This must be a numeric value.
Return Value
Python 3
91
This method returns arc tangent of x, in radians.
Example
The following example shows the usage of the atan() method.
#!/usr/bin/python3
import math
print ("atan(0.64) : ", math.atan(0.64))
print ("atan(0) : ", math.atan(0))
print ("atan(10) : ", math.atan(10))
print ("atan(-1) : ", math.atan(-1))
print ("atan(1) : ", math.atan(1))
When we run the above program, it produces the following resultatan(0.64) : 0.569313191101
atan(0) : 0.0
atan(10) : 1.4711276743
atan(-1) : -0.785398163397
atan(1) : 0.785398163397
Number atan2() Method
Description
The atan2() method returns atan(y / x), in radians.
Syntax
Following is the syntax for atan2() methodatan2(y, x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
 y - This must be a numeric value.
 x - This must be a numeric value.
Return Value
Python 3
92
This method returns atan(y / x), in radians.
Example
The following example shows the usage of atan2() method.
#!/usr/bin/python3
import math
print ("atan2(-0.50,-0.50) : ", math.atan2(-0.50,-0.50))
print ("atan2(0.50,0.50) : ", math.atan2(0.50,0.50))
print ("atan2(5,5) : ", math.atan2(5,5))
print ("atan2(-10,10) : ", math.atan2(-10,10))
print ("atan2(10,20) : ", math.atan2(10,20))
When we run the above program, it produces the following resultatan2(-0.50,-0.50) : -2.35619449019
atan2(0.50,0.50) : 0.785398163397
atan2(5,5) : 0.785398163397
atan2(-10,10) : -0.785398163397
atan2(10,20) : 0.463647609001
Number cos() Method
Description
The cos() method returns the cosine of x radians.
Syntax
Following is the syntax for cos() methodcos(x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This must be a numeric value.
Return Value
This method returns a numeric value between -1 and 1, which represents the cosine of
the angle.
Example
Python 3
93
The following example shows the usage of cos() method.
#!/usr/bin/python3
import math
print ("cos(3) : ", math.cos(3))
print ("cos(-3) : ", math.cos(-3))
print ("cos(0) : ", math.cos(0))
print ("cos(math.pi) : ", math.cos(math.pi))
print ("cos(2*math.pi) : ", math.cos(2*math.pi))
When we run the above program, it produces the following resultcos(3) : -0.9899924966
cos(-3) : -0.9899924966
cos(0) : 1.0
cos(math.pi) : -1.0
cos(2*math.pi) : 1.0
Number hypot() Method
Description
The method hypot() return the Euclidean norm, sqrt(x*x + y*y). This is length of vector
from origin to point (x,y)
Syntax
Following is the syntax for hypot() methodhypot(x, y)
Note: This function is not accessible directly, so we need to import math module and then
we need to call this function using math static object.
Parameters
 x - This must be a numeric value.
 y - This must be a numeric value.
Return Value
This method returns Euclidean norm, sqrt(x*x + y*y).
Example
Python 3
94
The following example shows the usage of hypot() method.
#!/usr/bin/python3
import math
print ("hypot(3, 2) : ", math.hypot(3, 2))
print ("hypot(-3, 3) : ", math.hypot(-3, 3))
print ("hypot(0, 2) : ", math.hypot(0, 2))
When we run the above program, it produces the following resulthypot(3, 2) : 3.60555127546
hypot(-3, 3) : 4.24264068712
hypot(0, 2) : 2.0
Number sin() Method
Description
The sin() method returns the sine of x, in radians.
Syntax
Following is the syntax for sin() methodsin(x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This must be a numeric value.
Return Value
This method returns a numeric value between -1 and 1, which represents the sine of the
parameter x.
Example
The following example shows the usage of sin() method.
#!/usr/bin/python3
import math
print ("sin(3) : ", math.sin(3))
print ("sin(-3) : ", math.sin(-3))
print ("sin(0) : ", math.sin(0))
Python 3
95
print ("sin(math.pi) : ", math.sin(math.pi))
print ("sin(math.pi/2) : ", math.sin(math.pi/2))
When we run the above program, it produces the following resultsin(3) : 0.14112000806
sin(-3) : -0.14112000806
sin(0) : 0.0
sin(math.pi) : 1.22460635382e-16
sin(math.pi/2) : 1
Number tan() Method
Description
The tan() method returns the tangent of x radians.
Syntax
Following is the syntax for tan() method.
tan(x)
Note: This function is not accessible directly, so we need to import math module and then
we need to call this function using math static object.
Parameters
x - This must be a numeric value.
Return Value
This method returns a numeric value between -1 and 1, which represents the tangent of
the parameter x.
Example
The following example shows the usage of tan() method.
#!/usr/bin/python3
import math
print ("(tan(3) : ", math.tan(3))
print ("tan(-3) : ", math.tan(-3))
print ("tan(0) : ", math.tan(0))
print ("tan(math.pi) : ", math.tan(math.pi))
print ("tan(math.pi/2) : ", math.tan(math.pi/2))
Python 3
96
print ("tan(math.pi/4) : ", math.tan(math.pi/4))
When we run the above program, it produces the following resultprint ("(tan(3) : ", math.tan(3))
print ("tan(-3) : ", math.tan(-3))
print ("tan(0) : ", math.tan(0))
print ("tan(math.pi) : ", math.tan(math.pi))
print ("tan(math.pi/2) : ", math.tan(math.pi/2))
print ("tan(math.pi/4) : ", math.tan(math.pi/4))
Number degrees() Method
Description
The degrees() method converts angle x from radians to degrees..
Syntax
Following is the syntax for degrees() methoddegrees(x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This must be a numeric value.
Return Value
This method returns the degree value of an angle.
Example
The following example shows the usage of degrees() method.
#!/usr/bin/python3
import math
print ("degrees(3) : ", math.degrees(3))
print ("degrees(-3) : ", math.degrees(-3))
print ("degrees(0) : ", math.degrees(0))
print ("degrees(math.pi) : ", math.degrees(math.pi))
print ("degrees(math.pi/2) : ", math.degrees(math.pi/2))
Python 3
97
print ("degrees(math.pi/4) : ", math.degrees(math.pi/4))
When we run the above program, it produces the following resultdegrees(3) : 171.88733853924697
degrees(-3) : -171.88733853924697
degrees(0) : 0.0
degrees(math.pi) : 180.0
degrees(math.pi/2) : 90.0
degrees(math.pi/4) : 45.0
Number radians() Method
Description
The radians() method converts angle x from degrees to radians.
Syntax
Following is the syntax for radians() methodradians(x)
Note: This function is not accessible directly, so we need to import the math module and
then we need to call this function using the math static object.
Parameters
x - This must be a numeric value.
Return Value
This method returns radian value of an angle.
Example
The following example shows the usage of radians() method.
#!/usr/bin/python3
import math
print ("radians(3) : ", math.radians(3))
print ("radians(-3) : ", math.radians(-3))
print ("radians(0) : ", math.radians(0))
print ("radians(math.pi) : ", math.radians(math.pi))
print ("radians(math.pi/2) : ", math.radians(math.pi/2))
Python 3
98
print ("radians(math.pi/4) : ", math.radians(math.pi/4))
When we run the above program, it produces the following resultradians(3) : 0.0523598775598
radians(-3) : -0.0523598775598
radians(0) : 0.0
radians(math.pi) : 0.0548311355616
radians(math.pi/2) : 0.0274155677808
radians(math.pi/4) : 0.0137077838904
Mathematical Constants
The module also defines two mathematical constantsConstants Description
pi The mathematical constant pi.
e The mathematical constant e.
Python 3
99
Strings are amongst the most popular types in Python. We can create them simply by
enclosing characters in quotes. Python treats single quotes the same as double quotes.
Creating strings is as simple as assigning a value to a variable. For examplevar1 = 'Hello World!'
var2 = "Python Programming"
Accessing Values in Strings
Python does not support a character type; these are treated as strings of length one, thus
also considered a substring.
To access substrings, use the square brackets for slicing along with the index or indices to
obtain your substring. For example-
#!/usr/bin/python3
var1 = 'Hello World!'
var2 = "Python Programming"
print ("var1[0]: ", var1[0])
print ("var2[1:5]: ", var2[1:5])
When the above code is executed, it produces the following resultvar1[0]: H
var2[1:5]: ytho
Updating Strings
You can "update" an existing string by (re)assigning a variable to another string. The new
value can be related to its previous value or to a completely different string altogether.
For example-
#!/usr/bin/python3
var1 = 'Hello World!'
print ("Updated String :- ", var1[:6] + 'Python')
When the above code is executed, it produces the following resultUpdated String :- Hello Python
10.Python 3 – Strings 
Python 3
100
Escape Characters
Following table is a list of escape or non-printable characters that can be represented with
backslash notation.
An escape character gets interpreted; in a single quoted as well as double quoted strings.
Backslash
notation
Hexadecimal
character Description
a 0x07 Bell or alert
b 0x08 Backspace
\cx Control-x
\C-x Control-x
\e 0x1b Escape
\f 0x0c Formfeed
\M-\C-x Meta-Control-x
\n 0x0a Newline
\nnn Octal notation, where n is in the range
0.7
\r 0x0d Carriage return
\s 0x20 Space
\t 0x09 Tab
Python 3
101
\v 0x0b Vertical tab
\x Character x
\xnn Hexadecimal notation, where n is in the
range 0.9, a.f, or A.F
String Special Operators
Assume string variable a holds 'Hello' and variable b holds 'Python', thenOperator Description Example
+ Concatenation - Adds values on either side of the
operator
a + b will give
HelloPython
* Repetition - Creates new strings, concatenating
multiple copies of the same string
a*2 will give -
HelloHello
[] Slice - Gives the character from the given index a[1] will give e
[ : ] Range Slice - Gives the characters from the given
range
a[1:4] will give ell
in Membership - Returns true if a character exists in
the given string
H in a will give 1
not in Membership - Returns true if a character does not
exist in the given string
M not in a will give
1
r/R Raw String - Suppresses actual meaning of Escape
characters. The syntax for raw strings is exactly the
same as for normal strings with the exception of the
raw string operator, the letter "r," which precedes
the quotation marks. The "r" can be lowercase (r) or
uppercase (R) and must be placed immediately
preceding the first quote mark.
print r'\n' prints \n
and print
R'\n'prints \n
Python 3
102
% Format - Performs String formatting See next section
String Formatting Operator
One of Python's coolest features is the string format operator %. This operator is unique
to strings and makes up for the pack of having functions from C's printf() family. Following
is a simple example −
#!/usr/bin/python3
print ("My name is %s and weight is %d kg!" % ('Zara', 21))
When the above code is executed, it produces the following result −
My name is Zara and weight is 21 kg!
Here is the list of complete set of symbols which can be used along with %-
Format Symbol Conversion
%c character
%s string conversion via str() prior to formatting
%i signed decimal integer
%d signed decimal integer
%u unsigned decimal integer
%o octal integer
%x hexadecimal integer (lowercase letters)
%X hexadecimal integer (UPPERcase letters)
%e exponential notation (with lowercase 'e')
Python 3
103
%E exponential notation (with UPPERcase 'E')
%f floating point real number
%g the shorter of %f and %e
%G the shorter of %f and %E
Other supported symbols and functionality are listed in the following tableSymbol Functionality
* argument specifies width or precision
- left justification
+ display the sign
<sp> leave a blank space before a positive number
# add the octal leading zero ( '0' ) or hexadecimal leading '0x'
or '0X', depending on whether 'x' or 'X' were used.
0 pad from left with zeros (instead of spaces)
% '%%' leaves you with a single literal '%'
(var) mapping variable (dictionary arguments)
m.n. m is the minimum total width and n is the number of digits
to display after the decimal point (if appl.)
Python 3
104
Triple Quotes
Python's triple quotes comes to the rescue by allowing strings to span multiple lines,
including verbatim NEWLINEs, TABs, and any other special characters.
The syntax for triple quotes consists of three consecutive single or double quotes.
#!/usr/bin/python3
para_str = """this is a long string that is made up of
several lines and non-printable characters such as
TAB ( \t ) and they will show up that way when displayed.
NEWLINEs within the string, whether explicitly given like
this within the brackets [ \n ], or just a NEWLINE within
the variable assignment will also show up.
"""
print (para_str)
When the above code is executed, it produces the following result. Note how every single
special character has been converted to its printed form, right down to the last NEWLINE
at the end of the string between the "up." and closing triple quotes. Also note that
NEWLINEs occur either with an explicit carriage return at the end of a line or its escape
code (\n) −
this is a long string that is made up of
several lines and non-printable characters such as
TAB ( ) and they will show up that way when displayed.
NEWLINEs within the string, whether explicitly given like
this within the brackets [
], or just a NEWLINE within
the variable assignment will also show up.
Raw strings do not treat the backslash as a special character at all. Every character you
put into a raw string stays the way you wrote it-
#!/usr/bin/python3
print ('C:\\nowhere')
When the above code is executed, it produces the following resultC:\nowhere
Now let us make use of raw string. We would put expression in r'expression' as follows-
#!/usr/bin/python3
Python 3
105
print (r'C:\\nowhere')
When the above code is executed, it produces the following resultC:\\nowhere
Unicode String
In Python 3, all strings are represented in Unicode. In Python 2 are stored internally as 8-
bit ASCII, hence it is required to attach 'u' to make it Unicode. It is no longer necessary
now.
Built-in String Methods
Python includes the following built-in methods to manipulate stringsS. No. Methods with Description
1
capitalize()
Capitalizes first letter of string
2
center(width, fillchar)
Returns a string padded with fillchar with the original string centered to a total
of width columns.
3
count(str, beg= 0,end=len(string))
Counts how many times str occurs in string or in a substring of string if starting
index beg and ending index end are given.
4
decode(encoding='UTF-8',errors='strict')
Decodes the string using the codec registered for encoding. encoding defaults
to the default string encoding.
5
encode(encoding='UTF-8',errors='strict')
Returns encoded string version of string; on error, default is to raise a
ValueError unless errors is given with 'ignore' or 'replace'.
6 endswith(suffix, beg=0, end=len(string))
Python 3
106
Determines if string or a substring of string (if starting index beg and ending
index end are given) ends with suffix; returns true if so and false otherwise.
7
expandtabs(tabsize=8)
Expands tabs in string to multiple spaces; defaults to 8 spaces per tab if tabsize
not provided.
8
find(str, beg=0 end=len(string))
Determine if str occurs in string or in a substring of string if starting index beg
and ending index end are given returns index if found and -1 otherwise.
9
index(str, beg=0, end=len(string))
Same as find(), but raises an exception if str not found.
10
isalnum()
Returns true if string has at least 1 character and all characters are
alphanumeric and false otherwise.
11
isalpha()
Returns true if string has at least 1 character and all characters are alphabetic
and false otherwise.
12
isdigit()
Returns true if the string contains only digits and false otherwise.
13
islower()
Returns true if string has at least 1 cased character and all cased characters
are in lowercase and false otherwise.
14
isnumeric()
Returns true if a unicode string contains only numeric characters and false
otherwise.
Python 3
107
15
isspace()
Returns true if string contains only whitespace characters and false otherwise.
16
istitle()
Returns true if string is properly "titlecased" and false otherwise.
17
isupper()
Returns true if string has at least one cased character and all cased characters
are in uppercase and false otherwise.
18
join(seq)
Merges (concatenates) the string representations of elements in sequence seq
into a string, with separator string.
19
len(string)
Returns the length of the string
20
ljust(width[, fillchar])
Returns a space-padded string with the original string left-justified to a total
of width columns.
21
lower()
Converts all uppercase letters in string to lowercase.
22
lstrip()
Removes all leading whitespace in string.
23
maketrans()
Returns a translation table to be used in translate function.
Python 3
108
24
max(str)
Returns the max alphabetical character from the string str.
25
min(str)
Returns the min alphabetical character from the string str.
26
replace(old, new [, max])
Replaces all occurrences of old in string with new or at most max occurrences
if max given.
27
rfind(str, beg=0,end=len(string))
Same as find(), but search backwards in string.
28
rindex( str, beg=0, end=len(string))
Same as index(), but search backwards in string.
29
rjust(width,[, fillchar])
Returns a space-padded string with the original string right-justified to a total
of width columns.
30
rstrip()
Removes all trailing whitespace of string.
31
split(str="", num=string.count(str))
Splits string according to delimiter str (space if not provided) and returns list
of substrings; split into at most num substrings if given.
32
splitlines( num=string.count('\n'))
Splits string at all (or num) NEWLINEs and returns a list of each line with
NEWLINEs removed.
Python 3
109
33
startswith(str, beg=0,end=len(string))
Determines if string or a substring of string (if starting index beg and ending
index end are given) starts with substring str; returns true if so and false
otherwise.
34
strip([chars])
Performs both lstrip() and rstrip() on string
35
swapcase()
Inverts case for all letters in string.
36
title()
Returns "titlecased" version of string, that is, all words begin with uppercase
and the rest are lowercase.
37
translate(table, deletechars="")
Translates string according to translation table str(256 chars), removing those
in the del string.
38
upper()
Converts lowercase letters in string to uppercase.
39
zfill (width)
Returns original string leftpadded with zeros to a total of width characters;
intended for numbers, zfill() retains any sign given (less one zero).
40
isdecimal()
Returns true if a unicode string contains only decimal characters and false
otherwise.
String capitalize() Method
It returns a copy of the string with only its first character capitalized.
Python 3
110
Syntax
str.capitalize()
Parameters
NA
Return Value
string
Example
#!/usr/bin/python3
str = "this is string example....wow!!!"
print ("str.capitalize() : ", str.capitalize())
Result
str.capitalize() : This is string example....wow!!!
String center() Method
The method center() returns centered in a string of length width. Padding is done using
the specified fillchar. Default filler is a space.
Syntax
str.center(width[, fillchar])
Parameters
 width - This is the total width of the string.
 fillchar - This is the filler character.
Return Value
This method returns a string that is at least width characters wide, created by padding the
string with the character fillchar (default is a space).
Example
The following example shows the usage of the center() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
Python 3
111
print ("str.center(40, 'a') : ", str.center(40, 'a'))
Result
str.center(40, 'a') : aaaathis is string example....wow!!!aaaa
String count() Method
Description
The count() method returns the number of occurrences of substring sub in the range
[start, end]. Optional arguments start and end are interpreted as in slice notation.
Syntax
str.count(sub, start= 0,end=len(string))
Parameters
 sub - This is the substring to be searched.
 start - Search starts from this index. First character starts from 0 index. By default
search starts from 0 index.
 end - Search ends from this index. First character starts from 0 index. By default
search ends at the last index.
Return Value
Centered in a string of length width.
Example
#!/usr/bin/python3
str="this is string example....wow!!!"
sub='i'
print ("str.count('i') : ", str.count(sub))
sub='exam'
print ("str.count('exam', 10, 40) : ", str.count(sub,10,40))
Result
str.count('i') : 3
str.count('exam', 4, 40) : 
Python 3
112
String decode() Method
Description
The decode() method decodes the string using the codec registered for encoding. It
defaults to the default string encoding.
Syntax
Str.decode(encoding='UTF-8',errors='strict')
Parameters
 encoding - This is the encodings to be used. For a list of all encoding schemes
please visit: Standard Encodings.
 errors - This may be given to set a different error handling scheme. The default
for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other
possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and
any other name registered via codecs.register_error()..
Return Value
Decoded string.
Example
#!/usr/bin/python3
Str = "this is string example....wow!!!";
Str = Str.encode('base64','strict');
print "Encoded String: " + Str
print "Decoded String: " + Str.decode('base64','strict')
Result
Encoded String: b'dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE='
Decoded String: this is string example....wow!!!
String encode() Method
Description
The encode() method returns an encoded version of the string. Default encoding is the
current default string encoding. The errors may be given to set a different error handling
scheme.
Python 3
113
Syntax
str.encode(encoding='UTF-8',errors='strict')
Parameters
 encoding - This is the encodings to be used. For a list of all encoding schemes
please visit: Standard Encodings.
 errors - This may be given to set a different error handling scheme. The default
for errors is 'strict', meaning that encoding errors raise a UnicodeError. Other
possible values are 'ignore', 'replace', 'xmlcharrefreplace', 'backslashreplace' and
any other name registered via codecs.register_error().
Return Value
Decoded string.
Example
#!/usr/bin/python3
import base64
Str = "this is string example....wow!!!"
Str=base64.b64encode(Str.encode('utf-8',errors='strict'))
print ("Encoded String: " , Str)
Result
Encoded String: b'dGhpcyBpcyBzdHJpbmcgZXhhbXBsZS4uLi53b3chISE='
String endswith() Method
Description
It returns True if the string ends with the specified suffix, otherwise return False optionally
restricting the matching with the given indices start and end.
Syntax
str.endswith(suffix[, start[, end]])
Parameters
 suffix - This could be a string or could also be a tuple of suffixes to look for.
 start - The slice begins from here.
Python 3
114
 end - The slice ends here.
Return Value
TRUE if the string ends with the specified suffix, otherwise FALSE.
Example
#!/usr/bin/python3
Str='this is string example....wow!!!'
suffix='!!'
print (Str.endswith(suffix))
print (Str.endswith(suffix,20))
suffix='exam'
print (Str.endswith(suffix))
print (Str.endswith(suffix, 0, 19))
Result
True
True
False
True
String expandtabs() Method
Description
The expandtabs() method returns a copy of the string in which the tab characters ie. '\t'
are expanded using spaces, optionally using the given tabsize (default 8)..
Syntax
str.expandtabs(tabsize=8)
Parameters
tabsize - This specifies the number of characters to be replaced for a tab character '\t'.
Return Value
This method returns a copy of the string in which tab characters i.e., '\t' have been
expanded using spaces.
Example
Python 3
115
#!/usr/bin/python3
str = "this is\tstring example....wow!!!"
print ("Original string: " + str)
print ("Defualt exapanded tab: " + str.expandtabs())
print ("Double exapanded tab: " + str.expandtabs(16))
Result
Original string: this is string example....wow!!!
Defualt exapanded tab: this is string example....wow!!!
Double exapanded tab: this is string example....wow!!!
String find() Method
Description
The find() method determines if the string str occurs in string, or in a substring of string
if the starting index beg and ending index end are given.
Syntax
str.find(str, beg=0 end=len(string))
Parameters
 str - This specifies the string to be searched.
 beg - This is the starting index, by default its 0.
 end - This is the ending index, by default its equal to the lenght of the string.
Return Value
Index if found and -1 otherwise.
Example
#!/usr/bin/python3
str1 = "this is string example....wow!!!"
str2 = "exam";
print (str1.find(str2))
print (str1.find(str2, 10))
print (str1.find(str2, 40))
Python 3
116
Result
15
15
-1
String index() Method
Description
The index() method determines if the string str occurs in string or in a substring of string,
if the starting index beg and ending index end are given. This method is same as find(),
but raises an exception if sub is not found.
Syntax
str.index(str, beg=0 end=len(string))
Parameters
 str - This specifies the string to be searched.
 beg - This is the starting index, by default its 0.
 end - This is the ending index, by default its equal to the length of the string.
Return Value
Index if found otherwise raises an exception if str is not found.
Example
#!/usr/bin/python3
str1 = "this is string example....wow!!!"
str2 = "exam";
print (str1.index(str2))
print (str1.index(str2, 10))
print (str1.index(str2, 40))
Result
15
Python 3
117
15
Traceback (most recent call last):
 File "test.py", line 7, in
 print (str1.index(str2, 40))
ValueError: substring not found
shell returned 1
String isalnum() Method
Description
The isalnum() method checks whether the string consists of alphanumeric characters.
Syntax
Following is the syntax for isalnum() methodstr.isa1num()
Parameters
NA
Return Value
This method returns true if all the characters in the string are alphanumeric and there is
at least one character, false otherwise.
Example
The following example shows the usage of isalnum() method.
#!/usr/bin/python3
str = "this2016" # No space in this string
print (str.isalnum())
str = "this is string example....wow!!!"
print (str.isalnum())
When we run the above program, it produces the following resultTrue
False
Python 3
118
String isalpha() Method
Description
The isalpha() method checks whether the string consists of alphabetic characters only.
Syntax
Following is the syntax for islpha() methodstr.isalpha()
Parameters
NA
Return Value
This method returns true if all the characters in the string are alphabetic and there is at
least one character, false otherwise.
Example
The following example shows the usage of isalpha() method.
#!/usr/bin/python3
str = "this"; # No space & digit in this string
print (str.isalpha())
str = "this is string example....wow!!!"
print (str.isalpha())
Result
True
False
Stringisdigit() Method
Description
The method isdigit() checks whether the string consists of digits only.
Syntax
Following is the syntax for isdigit() methodstr.isdigit()
Python 3
119
Parameters
NA
Return Value
This method returns true if all characters in the string are digits and there is at least one
character, false otherwise.
Example
The following example shows the usage of isdigit() method.
#!/usr/bin/python3
str = "123456"; # Only digit in this string
print (str.isdigit())
str = "this is string example....wow!!!"
print (str.isdigit())
Result
True
False
String islower() Method
Description
The islower() method checks whether all the case-based characters (letters) of the string
are lowercase.
Syntax
Following is the syntax for islower() methodstr.islower()
Parameters
NA
Return Value
This method returns true if all cased characters in the string are lowercase and there is at
least one cased character, false otherwise.
Example
Python 3
120
The following example shows the usage of islower() method.
#!/usr/bin/python3
str = "THIS is string example....wow!!!"
print (str.islower())
str = "this is string example....wow!!!"
print (str.islower())
Result
False
True
String isnumeric() Method
Description
The isnumeric() method checks whether the string consists of only numeric characters.
This method is present only on unicode objects.
Note: Unlike Python 2, all strings are represented in Unicode in Python 3. Given below is
an example illustrating it.
Syntax
Following is the syntax for isnumeric() methodstr.isnumeric()
Parameters
NA
Return Value
This method returns true if all characters in the string are numeric, false otherwise.
Example
The following example shows the usage of isnumeric() method.
#!/usr/bin/python3
str = "this2016"
print (str.isnumeric())
str = "23443434"
Python 3
121
print (str.isnumeric())
Result
False
True
String isspace() Method
Description
The isspace() method checks whether the string consists of whitespace..
Syntax
Following is the syntax for isspace() methodstr.isspace()
Parameters
NA
Return Value
This method returns true if there are only whitespace characters in the string and there is
at least one character, false otherwise.
Example
The following example shows the usage of isspace() method.
#!/usr/bin/python3
str = " "
print (str.isspace())
str = "This is string example....wow!!!"
print (str.isspace())
Result
True
False
Python 3
122
String istitle() Method
Description
The istitle() method checks whether all the case-based characters in the string following
non-casebased letters are uppercase and all other case-based characters are lowercase.
Syntax
Following is the syntax for istitle() methodstr.istitle()
Parameters
NA
Return Value
This method returns true if the string is a titlecased string and there is at least one
character, for example uppercase characters may only follow uncased characters and
lowercase characters only cased ones. It returns false otherwise.
Example
The following example shows the usage of istitle() method.
#!/usr/bin/python3
str = "This Is String Example...Wow!!!"
print (str.istitle())
str = "This is string example....wow!!!"
print (str.istitle())
Result
True
False
String isupper() Method
Description
Python 3
123
The isupper() method checks whether all the case-based characters (letters) of the string
are uppercase.
Syntax
Following is the syntax for isupper() methodstr.isupper()
Parameters
NA
Return Value
This method returns true if all the cased characters in the string are uppercase and there
is at least one cased character, false otherwise.
Example
The following example shows the usage of isupper() method.
#!/usr/bin/python3
str = "THIS IS STRING EXAMPLE....WOW!!!"
print (str.isupper())
str = "THIS is string example....wow!!!"
print (str.isupper())
Result
True
False
String join() Method
Description
The join() method returns a string in which the string elements of sequence have been
joined by str separator.
Syntax
Following is the syntax for join() methodstr.join(sequence)
Parameters
Python 3
124
sequence - This is a sequence of the elements to be joined.
Return Value
This method returns a string, which is the concatenation of the strings in the sequence
seq. The separator between elements is the string providing this method.
Example
The following example shows the usage of join() method.
#!/usr/bin/python3
s = "-"
seq = ("a", "b", "c") # This is sequence of strings.
print (s.join( seq ))
Result
a-b-c
String len() Method
Description
The len() method returns the length of the string.
Syntax
Following is the syntax for len() method −
len( str )
Parameters
NA
Return Value
This method returns the length of the string.
Example
The following example shows the usage of len() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print ("Length of the string: ", len(str))
Python 3
125
Result
Length of the string: 32
String ljust() Method
Description
The method ljust() returns the string left justified in a string of length width. Padding is
done using the specified fillchar (default is a space). The original string is returned if width
is less than len(s).
Syntax
Following is the syntax for ljust() method −
str.ljust(width[, fillchar])
Parameters
 width - This is string length in total after padding.
 fillchar - This is filler character, default is a space.
Return Value
This method returns the string left justified in a string of length width. Padding is done
using the specified fillchar (default is a space). The original string is returned if width is
less than len(s).
Example
The following example shows the usage of ljust() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print str.ljust(50, '*')
Result
this is string example....wow!!!******************
String lower() Method
Description
The method lower() returns a copy of the string in which all case-based characters have
been lowercased.
Python 3
126
Syntax
Following is the syntax for lower() method −
str.lower()
Parameters
NA
Return Value
This method returns a copy of the string in which all case-based characters have been
lowercased.
Example
The following example shows the usage of lower() method.
#!/usr/bin/python3
str = "THIS IS STRING EXAMPLE....WOW!!!"
print (str.lower())
Result
this is string example....wow!!!
String lstrip() Method
Description
The lstrip() method returns a copy of the string in which all chars have been stripped
from the beginning of the string (default whitespace characters).
Syntax
Following is the syntax for lstrip() methodstr.lstrip([chars])
Parameters
chars - You can supply what chars have to be trimmed.
Return Value
This method returns a copy of the string in which all chars have been stripped from the
beginning of the string (default whitespace characters).
Python 3
127
Example
The following example shows the usage of lstrip() method.
#!/usr/bin/python3
str = " this is string example....wow!!!"
print (str.lstrip())
str = "*****this is string example....wow!!!*****"
print (str.lstrip('*'))
Result
this is string example....wow!!!
this is string example....wow!!!*****
String maketrans() Method
Description
The maketrans() method returns a translation table that maps each character in the
intabstring into the character at the same position in the outtab string. Then this table is
passed to the translate() function.
Note: Both intab and outtab must have the same length.
Syntax
Following is the syntax for maketrans() methodstr.maketrans(intab, outtab]);
Parameters
 intab - This is the string having actual characters.
 outtab - This is the string having corresponding mapping character.
Return Value
This method returns a translate table to be used translate() function.
Example
The following example shows the usage of maketrans() method. Under this, every vowel
in a string is replaced by its vowel position −
#!/usr/bin/python3
intab = "aeiou"
Python 3
128
outtab = "12345"
trantab = str.maketrans(intab, outtab)
str = "this is string example....wow!!!"
print (str.translate(trantab))
Result
th3s 3s str3ng 2x1mpl2....w4w!!!
String max() Method
Description
The max() method returns the max alphabetical character from the string str.
Syntax
Following is the syntax for max() methodmax(str)
Parameters
str - This is the string from which max alphabetical character needs to be returned.
Return Value
This method returns the max alphabetical character from the string str.
Example
The following example shows the usage of max() method.
#!/usr/bin/python3
str = "this is a string example....really!!!"
print ("Max character: " + max(str))
str = "this is a string example....wow!!!"
print ("Max character: " + max(str))
Result
Max character: y
Max character: x
Python 3
129
String min() Method
Description
The min() method returns the min alphabetical character from the string str.
Syntax
Following is the syntax for min() methodmin(str)
Parameters
str - This is the string from which min alphabetical character needs to be returned.
Return Value
This method returns the max alphabetical character from the string str.
Example
The following example shows the usage of min() method.
#!/usr/bin/python3
str = "www.tutorialspoint.com"
print ("Min character: " + min(str))
str = "TUTORIALSPOINT"
print ("Min character: " + min(str))
Result
Min character: .
Min character: A
String replace() Method
Description
The replace() method returns a copy of the string in which the occurrences of old have
been replaced with new, optionally restricting the number of replacements to max.
Syntax
Following is the syntax for replace() methodstr.replace(old, new[, max])
Python 3
130
Parameters
 old - This is old substring to be replaced.
 new - This is new substring, which would replace old substring.
 max - If this optional argument max is given, only the first count occurrences are
replaced.
Return Value
This method returns a copy of the string with all occurrences of substring old replaced by
new. If the optional argument max is given, only the first count occurrences are replaced.
Example
The following example shows the usage of replace() method.
#!/usr/bin/python3
str = "this is string example....wow!!! this is really string"
print (str.replace("is", "was"))
print (str.replace("is", "was", 3))
Result
thwas was string example....wow!!! thwas was really string
thwas was string example....wow!!! thwas is really string
String rfind() Method
Description
The rfind() method returns the last index where the substring str is found, or -1 if no
such index exists, optionally restricting the search to string[beg:end].
Syntax
Following is the syntax for rfind() methodstr.rfind(str, beg=0 end=len(string))
Parameters
 str - This specifies the string to be searched.
 beg - This is the starting index, by default its 0.
 end - This is the ending index, by default its equal to the length of the string.
Python 3
131
Return Value
This method returns last index if found and -1 otherwise.
Example
The following example shows the usage of rfind() method.
#!/usr/bin/python3
str1 = "this is really a string example....wow!!!"
str2 = "is"
print (str1.rfind(str2))
print (str1.rfind(str2, 0, 10))
print (str1.rfind(str2, 10, 0))
print (str1.find(str2))
print (str1.find(str2, 0, 10))
print (str1.find(str2, 10, 0))
Result
5
5
-1
2
2
-1
String rindex() Method
Description
The rindex() method returns the last index where the substring str is found, or raises an
exception if no such index exists, optionally restricting the search to string[beg:end].
Syntax
Following is the syntax for rindex() methodstr.rindex(str, beg=0 end=len(string))
Parameters
 str - This specifies the string to be searched.
Python 3
132
 beg - This is the starting index, by default its 0.
 len - This is ending index, by default its equal to the length of the string.
Return Value
This method returns last index if found otherwise raises an exception if str is not found.
Example
The following example shows the usage of rindex() method.
#!/usr/bin/python3
str1 = "this is really a string example....wow!!!"
str2 = "is"
print (str1.rindex(str2))
print (str1.rindex(str2,10))
Result
5
Traceback (most recent call last):
 File "test.py", line 5, in
 print (str1.rindex(str2,10))
ValueError: substring not found
String rjust() Method
Description
The rjust() method returns the string right justified in a string of length width. Padding
is done using the specified fillchar (default is a space). The original string is returned if
width is less than len(s).
Syntax
Following is the syntax for rjust() methodstr.rjust(width[, fillchar])
Parameters
 width - This is the string length in total after padding.
 fillchar - This is the filler character, default is a space.
Python 3
133
Return Value
This method returns the string right justified in a string of length width. Padding is done
using the specified fillchar (default is a space). The original string is returned if the width
is less than len(s).
Example
The following example shows the usage of rjust() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print (str.rjust(50, '*'))
Result
******************this is string example....wow!!!
String rstrip() Method
Description
The rstrip() method returns a copy of the string in which all chars have been stripped
from the end of the string (default whitespace characters).
Syntax
Following is the syntax for rstrip() methodstr.rstrip([chars])
Parameters
chars - You can supply what chars have to be trimmed.
Return Value
This method returns a copy of the string in which all chars have been stripped from the
end of the string (default whitespace characters).
Example
The following example shows the usage of rstrip() method.
#!/usr/bin/python3
str = " this is string example....wow!!! "
print (str.rstrip())
str = "*****this is string example....wow!!!*****"
Python 3
134
print (str.rstrip('*'))
Result
 this is string example....wow!!!
*****this is string example....wow!!!
String split() Method
Description
The split() method returns a list of all the words in the string, using str as the separator
(splits on all whitespace if left unspecified), optionally limiting the number of splits to num.
Syntax
Following is the syntax for split() methodstr.split(str="", num=string.count(str)).
Parameters
 str - This is any delimeter, by default it is space.
 num - this is number of lines to be made
Return Value
This method returns a list of lines.
Example
The following example shows the usage of split() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print (str.split( ))
print (str.split('i',1))
print (str.split('w'))
Result
['this', 'is', 'string', 'example....wow!!!']
['th', 's is string example....wow!!!']
['this is string example....', 'o', '!!!']
Python 3
135
String splitlines() Method
Description
The splitlines() method returns a list with all the lines in string, optionally including the
line breaks (if num is supplied and is true).
Syntax
Following is the syntax for splitlines() methodstr.splitlines( num=string.count('\n'))
Parameters
num - This is any number, if present then it would be assumed that the line breaks need
to be included in the lines.
Return Value
This method returns true if found matching with the string otherwise false.
Example
The following example shows the usage of splitlines() method.
#!/usr/bin/python3
str = "this is \nstring example....\nwow!!!"
print (str.splitlines( ))
Result
['this is ', 'string example....', 'wow!!!']
String startswith() Method
Description
The startswith() method checks whether the string starts with str, optionally restricting
the matching with the given indices start and end.
Syntax
Following is the syntax for startswith() methodstr.startswith(str, beg=0,end=len(string));
Python 3
136
Parameters
 str - This is the string to be checked.
 beg - This is the optional parameter to set start index of the matching boundary.
 end - This is the optional parameter to set start index of the matching boundary.
Return Value
This method returns true if found matching with the string otherwise false.
Example
The following example shows the usage of startswith() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print (str.startswith( 'this' ))
print (str.startswith( 'string', 8 ))
print (str.startswith( 'this', 2, 4 ))
Result
True
True
False
String strip() Method
Description
The strip() method returns a copy of the string in which all chars have been stripped from
the beginning and the end of the string (default whitespace characters).
Syntax
Following is the syntax for strip() method −
str.strip([chars]);
Parameters
chars - The characters to be removed from beginning or end of the string.
Return Value
Python 3
137
This method returns a copy of the string in which all the chars have been stripped from
the beginning and the end of the string.
Example
The following example shows the usage of strip() method.
#!/usr/bin/python3
str = "*****this is string example....wow!!!*****"
print (str.strip( '*' ))
Result
this is string example....wow!!!
String swapcase() Method
Description
The swapcase() method returns a copy of the string in which all the case-based
characters have had their case swapped.
Syntax
Following is the syntax for swapcase() methodstr.swapcase();
Parameters
NA
Return Value
This method returns a copy of the string in which all the case-based characters have had
their case swapped.
Example
The following example shows the usage of swapcase() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print (str.swapcase())
str = "This Is String Example....WOW!!!"
print (str.swapcase())
Python 3
138
Result
THIS IS STRING EXAMPLE....WOW!!!
tHIS iS sTRING eXAMPLE....wow!!!
String title() Method
Description
The title() method returns a copy of the string in which first characters of all the words
are capitalized.
Syntax
Following is the syntax for title() methodstr.title();
Parameters
NA
Return Value
This method returns a copy of the string in which first characters of all the words are
capitalized.
Example
The following example shows the usage of title() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print (str.title())
Result
This Is String Example....Wow!!!
String translate() Method
Description
The method translate() returns a copy of the string in which all the characters have been
translated using table (constructed with the maketrans() function in the string module),
optionally deleting all characters found in the string deletechars.
Python 3
139
Syntax
Following is the syntax for translate() methodstr.translate(table[, deletechars]);
Parameters
 table - You can use the maketrans() helper function in the string module to create
a translation table.
 deletechars - The list of characters to be removed from the source string.
Return Value
This method returns a translated copy of the string.
Example
The following example shows the usage of translate() method. Under this, every vowel in
a string is replaced by its vowel position.
#!/usr/bin/python3
from string import maketrans # Required to call maketrans function.
intab = "aeiou"
outtab = "12345"
trantab = maketrans(intab, outtab)
str = "this is string example....wow!!!";
print (str.translate(trantab))
Result
th3s 3s str3ng 2x1mpl2....w4w!!!
Following is the example to delete 'x' and 'm' characters from the string-
#!/usr/bin/python3
from string import maketrans # Required to call maketrans function.
intab = "aeiouxm"
outtab = "1234512"
trantab = maketrans(intab, outtab)
str = "this is string example....wow!!!";
print (str.translate(trantab))
Python 3
140
Result
th3s 3s str3ng 21pl2....w4w!!!
String upper() Method
Description
The upper() method returns a copy of the string in which all case-based characters have
been uppercased.
Syntax
Following is the syntax for upper() method −
str.upper()
Parameters
NA
Return Value
This method returns a copy of the string in which all case-based characters have been
uppercased.
Example
The following example shows the usage of upper() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print ("str.upper : ",str.upper())
Result
str.upper : THIS IS STRING EXAMPLE....WOW!!!
String zfill() Method
Description
The zfill() method pads string on the left with zeros to fill width.
Syntax
Python 3
141
Following is the syntax for zfill() methodstr.zfill(width)
Parameters
width - This is final width of the string. This is the width which we would get after filling
zeros.
Return Value
This method returns padded string.
Example
The following example shows the usage of zfill() method.
#!/usr/bin/python3
str = "this is string example....wow!!!"
print ("str.zfill : ",str.zfill(40))
print ("str.zfill : ",str.zfill(50))
Result
str.zfill : 00000000this is string example....wow!!!
str.zfill : 000000000000000000this is string example....wow!!!
String isdecimal() Method
Description
The isdecimal() method checks whether the string consists of only decimal characters.
This method are present only on unicode objects.
Note: Unlike in Python 2, all strings are represented as Unicode in Python 3. Given Below
is an example illustrating it.
Syntax
Following is the syntax for isdecimal() methodstr.isdecimal()
Parameters
NA
Return Value
Python 3
142
This method returns true if all the characters in the string are decimal, false otherwise.
Example
The following example shows the usage of isdecimal() method.
#!/usr/bin/python3
str = "this2016"
print (str.isdecimal())
str = "23443434"
print (str.isdecimal())
Result
False
True
Python 3
143
The most basic data structure in Python is the sequence. Each element of a sequence is
assigned a number - its position or index. The first index is zero, the second index is one,
and so forth.
Python has six built-in types of sequences, but the most common ones are lists and tuples,
which we would see in this tutorial.
There are certain things you can do with all the sequence types. These operations include
indexing, slicing, adding, multiplying, and checking for membership. In addition, Python
has built-in functions for finding the length of a sequence and for finding its largest and
smallest elements.
Python Lists
The list is the most versatile datatype available in Python, which can be written as a list
of comma-separated values (items) between square brackets. Important thing about a list
is that the items in a list need not be of the same type.
Creating a list is as simple as putting different comma-separated values between square
brackets. For examplelist1 = ['physics', 'chemistry', 1997, 2000];
list2 = [1, 2, 3, 4, 5 ];
list3 = ["a", "b", "c", "d"];
Similar to string indices, list indices start at 0, and lists can be sliced, concatenated and
so on.
Accessing Values in Lists
To access values in lists, use the square brackets for slicing along with the index or indices
to obtain value available at that index. For example-
#!/usr/bin/python3
list1 = ['physics', 'chemistry', 1997, 2000]
list2 = [1, 2, 3, 4, 5, 6, 7 ]
print ("list1[0]: ", list1[0])
print ("list2[1:5]: ", list2[1:5])
When the above code is executed, it produces the following result −
list1[0]: physics
list2[1:5]: [2, 3, 4, 5]
11.Python 3 – Lists 
Python 3
144
Updating Lists
You can update single or multiple elements of lists by giving the slice on the left-hand side
of the assignment operator, and you can add to elements in a list with the append()
method. For example-
#!/usr/bin/python3
list = ['physics', 'chemistry', 1997, 2000]
print ("Value available at index 2 : ", list[2])
list[2] = 2001
print ("New value available at index 2 : ", list[2])
Note: The append() method is discussed in the subsequent section.
When the above code is executed, it produces the following result −
Value available at index 2 :
1997
New value available at index 2 :
2001
Delete List Elements
To remove a list element, you can use either the del statement if you know exactly which
element(s) you are deleting. You can use the remove() method if you do not know exactly
which items to delete. For example-
#!/usr/bin/python3
list = ['physics', 'chemistry', 1997, 2000]
print (list)
del list[2]
print ("After deleting value at index 2 : ", list)
When the above code is executed, it produces the following result-
['physics', 'chemistry', 1997, 2000]
After deleting value at index 2 : ['physics', 'chemistry', 2000]
Note: remove() method is discussed in subsequent section.
Basic List Operations
Lists respond to the + and * operators much like strings; they mean concatenation and
repetition here too, except that the result is a new list, not a string.
In fact, lists respond to all of the general sequence operations we used on strings in the
prior chapter.
Python 3
145
Python Expression Results Description
len([1, 2, 3]) 3 Length
[1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] Concatenation
['Hi!'] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] Repetition
3 in [1, 2, 3] True Membership
for x in [1,2,3] : print (x,end='
')
1 2 3 Iteration
Indexing, Slicingand Matrixes
Since lists are sequences, indexing and slicing work the same way for lists as they do for
strings.
Assuming the following inputL=['C++'', 'Java', 'Python']
Python Expression Results Description
L[2] 'Python' Offsets start at zero
L[-2] 'Java' Negative: count from the
right
L[1:] ['Java', 'Python'] Slicing fetches sections
Built-in List Functions & Methods
Python includes the following list functionsSN Function with Description
1 cmp(list1, list2)
No longer available in Python 3.
Python 3
146
2 len(list)
Gives the total length of the list.
3 max(list)
Returns item from the list with max value.
4 min(list)
Returns item from the list with min value.
5 list(seq)
Converts a tuple into list.
Let us understand the use of these functions.
List len() Method
Description
The len() method returns the number of elements in the list.
Syntax
Following is the syntax for len() methodlen(list)
Parameters
list - This is a list for which, number of elements are to be counted.
Return Value
This method returns the number of elements in the list.
Example
The following example shows the usage of len() method.
#!/usr/bin/python3
list1 = ['physics', 'chemistry', 'maths']
print (len(list1))
list2=list(range(5)) #creates list of numbers between 0-4
print (len(list2))
Python 3
147
When we run above program, it produces following result3
5
List max() Method
Description
The max() method returns the elements from the list with maximum value.
Syntax
Following is the syntax for max() methodmax(list)
Parameters
list - This is a list from which max valued element are to be returned.
Return Value
This method returns the elements from the list with maximum value.
Example
The following example shows the usage of max() method.
#!/usr/bin/python3
list1, list2 = ['C++','Java', 'Python'], [456, 700, 200]
print ("Max value element : ", max(list1))
print ("Max value element : ", max(list2))
When we run above program, it produces following resultMax value element : Python
Max value element : 700
List min() Method
Description
The method min() returns the elements from the list with minimum value.
Python 3
148
Syntax
Following is the syntax for min() methodmin(list)
Parameters
list - This is a list from which min valued element is to be returned.
Return Value
This method returns the elements from the list with minimum value.
Example
The following example shows the usage of min() method.
#!/usr/bin/python3
list1, list2 = ['C++','Java', 'Python'], [456, 700, 200]
print ("min value element : ", min(list1))
print ("min value element : ", min(list2))
When we run above program, it produces following resultmin value element : C++
min value element : 200
List list() Method
Description
The list() method takes sequence types and converts them to lists. This is used to convert
a given tuple into list.
Note: Tuple are very similar to lists with only difference that element values of a tuple
can not be changed and tuple elements are put between parentheses instead of square
bracket. This function also converts characters in a string into a list.
Syntax
Following is the syntax for list() methodlist( seq )
Parameters
seq - This is a tuple or string to be converted into list.
Python 3
149
Return Value
This method returns the list.
Example
The following example shows the usage of list() method.
#!/usr/bin/python3
aTuple = (123, 'C++', 'Java', 'Python')
list1 = list(aTuple)
print ("List elements : ", list1)
str="Hello World"
list2=list(str)
print ("List elements : ", list2)
When we run above program, it produces following resultList elements : [123, 'C++', 'Java', 'Python']
List elements : ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']
Python includes the following list methodsSN Methods with Description
1 list.append(obj)
Appends object obj to list
2 list.count(obj)
Returns count of how many times obj occurs in list
3 list.extend(seq)
Appends the contents of seq to list
4 list.index(obj)
Returns the lowest index in list that obj appears
5 list.insert(index, obj)
Inserts object obj into list at offset index
Python 3
150
6 list.pop(obj=list[-1])
Removes and returns last object or obj from list
7 list.remove(obj)
Removes object obj from list
8 list.reverse()
Reverses objects of list in place
9 list.sort([func])
Sorts objects of list, use compare func if given
List append() Method
Description
The append() method appends a passed obj into the existing list.
Syntax
Following is the syntax for append() methodlist.append(obj)
Parameters
obj - This is the object to be appended in the list.
Return Value
This method does not return any value but updates existing list.
Example
The following example shows the usage of append() method.
#!/usr/bin/python3
list1 = ['C++', 'Java', 'Python']
list1.append('C#')
print ("updated list : ", list1)
When we run the above program, it produces the following resultupdated list : ['C++', 'Java', 'Python', 'C#']
Python 3
151
List count() Method
Description
The count() method returns count of how many times obj occurs in list.
Syntax
Following is the syntax for count() methodlist.count(obj)
Parameters
obj - This is the object to be counted in the list.
Return Value
This method returns count of how many times obj occurs in list.
Example
The following example shows the usage of count() method.
#!/usr/bin/python3
aList = [123, 'xyz', 'zara', 'abc', 123];
print ("Count for 123 : ", aList.count(123))
print ("Count for zara : ", aList.count('zara'))
When we run the above program, it produces the following resultCount for 123 : 2
Count for zara : 1
List extend() Method
Description
The extend() method appends the contents of seq to list.
Syntax
Following is the syntax for extend() method-
Python 3
152
list.extend(seq)
Parameters
seq - This is the list of elements
Return Value
This method does not return any value but adds the content to an existing list.
Example
The following example shows the usage of extend() method.
#!/usr/bin/python3
list1 = ['physics', 'chemistry', 'maths']
list2=list(range(5)) #creates list of numbers between 0-4
list1.extend('Extended List :', list2)
print (list1)
When we run the above program, it produces the following resultExtended List : ['physics', 'chemistry', 'maths', 0, 1, 2, 3, 4]
List index() Method
Description
The index() method returns the lowest index in list that obj appears.
Syntax
Following is the syntax for index() methodlist.index(obj)
Parameters
obj - This is the object to be find out.
Return Value
This method returns index of the found object otherwise raises an exception indicating
that the value is not found.
Example
The following example shows the usage of index() method.
Python 3
153
#!/usr/bin/python3
list1 = ['physics', 'chemistry', 'maths']
print ('Index of chemistry', list1.index('chemistry'))
print ('Index of C#', list1.index('C#'))
When we run the above program, it produces the following resultIndex of chemistry 1
Traceback (most recent call last):
 File "test.py", line 3, in
 print ('Index of C#', list1.index('C#'))
ValueError: 'C#' is not in list
List insert() Method
Description
The insert() method inserts object obj into list at offset index.
Syntax
Following is the syntax for insert() methodlist.insert(index, obj)
Parameters
 index - This is the Index where the object obj need to be inserted.
 obj - This is the Object to be inserted into the given list.
Return Value
This method does not return any value but it inserts the given element at the given index.
Example
The following example shows the usage of insert() method.
#!/usr/bin/python3
list1 = ['physics', 'chemistry', 'maths']
list1.insert(1, 'Biology')
print ('Final list : ', list1)
When we run the above program, it produces the following result-
Python 3
154
Final list : ['physics', 'Biology', 'chemistry', 'maths']
List pop() Method
Description
The pop() method removes and returns last object or obj from the list.
Syntax
Following is the syntax for pop() methodlist.pop(obj=list[-1])
Parameters
obj - This is an optional parameter, index of the object to be removed from the list.
Return Value
This method returns the removed object from the list.
Example
The following example shows the usage of pop() method.
#!/usr/bin/python3
list1 = ['physics', 'Biology', 'chemistry', 'maths']
list1.pop()
print ("list now : ", list1)
list1.pop(1)
print ("list now : ", list1)
When we run the above program, it produces the following resultlist now : ['physics', 'Biology', 'chemistry']
list now : ['physics', 'chemistry']
List remove() Method
Parameters
obj - This is the object to be removed from the list.
Return Value
This method does not return any value but removes the given object from the list.
Python 3
155
Example
The following example shows the usage of remove() method.
#!/usr/bin/python3
list1 = ['physics', 'Biology', 'chemistry', 'maths']
list1.remove('Biology')
print ("list now : ", list1)
list1.remove('maths')
print ("list now : ", list1)
When we run the above program, it produces the following resultlist now : ['physics', 'chemistry', 'maths']
list now : ['physics', 'chemistry']
List reverse() Method
Description
The reverse() method reverses objects of list in place.
Syntax
Following is the syntax for reverse() methodlist.reverse()
Parameters
NA
Return Value
This method does not return any value but reverse the given object from the list.
Example
The following example shows the usage of reverse() method.
#!/usr/bin/python3
list1 = ['physics', 'Biology', 'chemistry', 'maths']
list1.reverse()
print ("list now : ", list1)
When we run above program, it produces following result-
Python 3
156
list now : ['maths', 'chemistry', 'Biology', 'physics']
List sort() Method
Description
The sort() method sorts objects of list, use compare function if given.
Syntax
Following is the syntax for sort() methodlist.sort([func])
Parameters
NA
Return Value
This method does not return any value but reverses the given object from the list.
Example
The following example shows the usage of sort() method.
#!/usr/bin/python3
list1 = ['physics', 'Biology', 'chemistry', 'maths']
list1.sort()
print ("list now : ", list1)
When we run the above program, it produces the following resultlist now : ['Biology', 'chemistry', 'maths', 'physics']
Python 3
157
A tuple is a sequence of immutable Python objects. Tuples are sequences, just like lists.
The main difference between the tuples and the lists is that the tuples cannot be changed
unlike lists. Tuples use parentheses, whereas lists use square brackets.
Creating a tuple is as simple as putting different comma-separated values. Optionally, you
can put these comma-separated values between parentheses also. For exampletup1 = ('physics', 'chemistry', 1997, 2000)
tup2 = (1, 2, 3, 4, 5 )
tup3 = "a", "b", "c", "d"
The empty tuple is written as two parentheses containing nothing.
tup1 = ();
To write a tuple containing a single value you have to include a comma, even though there
is only one value.
tup1 = (50,)
Like string indices, tuple indices start at 0, and they can be sliced, concatenated, and so
on.
Accessing Values in Tuples
To access values in tuple, use the square brackets for slicing along with the index or indices
to obtain the value available at that index. For example-
#!/usr/bin/python3
tup1 = ('physics', 'chemistry', 1997, 2000)
tup2 = (1, 2, 3, 4, 5, 6, 7 )
print ("tup1[0]: ", tup1[0])
print ("tup2[1:5]: ", tup2[1:5])
When the above code is executed, it produces the following resulttup1[0]: physics
tup2[1:5]: [2, 3, 4, 5]
12.Python 3 – Tuples 
Python 3
158
Updating Tuples
Tuples are immutable, which means you cannot update or change the values of tuple
elements. You are able to take portions of the existing tuples to create new tuples as the
following example demonstrates.
#!/usr/bin/python3
tup1 = (12, 34.56)
tup2 = ('abc', 'xyz')
# Following action is not valid for tuples
# tup1[0] = 100;
# So let's create a new tuple as follows
tup3 = tup1 + tup2
print (tup3)
When the above code is executed, it produces the following result-
(12, 34.56, 'abc', 'xyz')
Delete Tuple Elements
Removing individual tuple elements is not possible. There is, of course, nothing wrong with
putting together another tuple with the undesired elements discarded.
To explicitly remove an entire tuple, just use the del statement. For example-
#!/usr/bin/python3
tup = ('physics', 'chemistry', 1997, 2000);
print (tup)
del tup;
print "After deleting tup : "
print tup
This produces the following result.
Note: An exception is raised. This is because after del tup, tuple does not exist any more.
('physics', 'chemistry', 1997, 2000)
After deleting tup :
Traceback (most recent call last):
 File "test.py", line 9, in <module>
 print tup;
Python 3
159
NameError: name 'tup' is not defined
Basic Tuples Operations
Tuples respond to the + and * operators much like strings; they mean concatenation and
repetition here too, except that the result is a new tuple, not a string.
In fact, tuples respond to all of the general sequence operations we used on strings in the
previous chapter.
Python Expression Results Description
len((1, 2, 3)) 3 Length
(1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) Concatenation
('Hi!',) * 4 ('Hi!', 'Hi!', 'Hi!', 'Hi!') Repetition
3 in (1, 2, 3) True Membership
for x in (1,2,3) : print (x, end='
')
1 2 3 Iteration
Indexing, Slicing, and Matrixes
Since tuples are sequences, indexing and slicing work the same way for tuples as they do
for strings, assuming the following inputT=('C++', 'Java', 'Python')
Python Expression Results Description
T[2] 'Python' Offsets start at zero
T[-2] 'Java' Negative: count from the right
T[1:] ('Java', 'Python') Slicing fetches sections
Python 3
160
No Enclosing Delimiters
No enclosing Delimiters is any set of multiple objects, comma-separated, written without
identifying symbols, i.e., brackets for lists, parentheses for tuples, etc., default to tuples,
as indicated in these short examples.
Built-in Tuple Functions
Python includes the following tuple functionsSN Function with Description
1 cmp(tuple1, tuple2)
No longer available in Python 3.
2 len(tuple)
Gives the total length of the tuple.
3 max(tuple)
Returns item from the tuple with max value.
4 min(tuple)
Returns item from the tuple with min value.
5 tuple(seq)
Converts a list into tuple.
Tuple len() Method
Description
The len() method returns the number of elements in the tuple.
Syntax
Following is the syntax for len() methodlen(tuple)
Parameters
tuple - This is a tuple for which number of elements to be counted.
Python 3
161
Return Value
This method returns the number of elements in the tuple.
Example
The following example shows the usage of len() method.
#!/usr/bin/python3
tuple1, tuple2 = (123, 'xyz', 'zara'), (456, 'abc')
print ("First tuple length : ", len(tuple1))
print ("Second tuple length : ", len(tuple2))
When we run above program, it produces following resultFirst tuple length : 3
Second tuple length : 2
Tuple max() Method
Description
The max() method returns the elements from the tuple with maximum value.
Syntax
Following is the syntax for max() methodmax(tuple)
Parameters
tuple - This is a tuple from which max valued element to be returned.
Return Value
This method returns the elements from the tuple with maximum value.
Example
The following example shows the usage of max() method.
#!/usr/bin/python3
tuple1, tuple2 = ('maths', 'che', 'phy', 'bio'), (456, 700, 200)
print ("Max value element : ", max(tuple1))
print ("Max value element : ", max(tuple2))
Python 3
162
When we run the above program, it produces the following resultMax value element : phy
Max value element : 700
Tuple min() Method
Description
The min() method returns the elements from the tuple with minimum value.
Syntax
Following is the syntax for min() methodmin(tuple)
Parameters
tuple - This is a tuple from which min valued element is to be returned.
Return Value
This method returns the elements from the tuple with minimum value.
Example
The following example shows the usage of min() method.
#!/usr/bin/python3
tuple1, tuple2 = ('maths', 'che', 'phy', 'bio'), (456, 700, 200)
print ("min value element : ", min(tuple1))
print ("min value element : ", min(tuple2))
When we run the above program, it produces the following resultmin value element : bio
min value element : 200
Tuple tuple() Method
Description
The tuple() method converts a list of items into tuples.
Syntax
Python 3
163
Following is the syntax for tuple() methodtuple( seq )
Parameters
seq - This is a tuple to be converted into tuple.
Return Value
This method returns the tuple.
Example
The following example shows the usage of tuple() method.
#!/usr/bin/python3
list1= ['maths', 'che', 'phy', 'bio']
tuple1=tuple(list1)
print ("tuple elements : ", tuple1)
When we run the above program, it produces the following resulttuple elements : ('maths', 'che', 'phy', 'bio')
Python 3
164
Each key is separated from its value by a colon (:), the items are separated by commas,
and the whole thing is enclosed in curly braces. An empty dictionary without any items is
written with just two curly braces, like this: {}.
Keys are unique within a dictionary while values may not be. The values of a dictionary
can be of any type, but the keys must be of an immutable data type such as strings,
numbers, or tuples.
Accessing Values in Dictionary
To access dictionary elements, you can use the familiar square brackets along with the
key to obtain its value. Following is a simple example.
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
print ("dict['Name']: ", dict['Name'])
print ("dict['Age']: ", dict['Age'])
When the above code is executed, it produces the following resultdict['Name']: Zara
dict['Age']: 7
If we attempt to access a data item with a key, which is not a part of the dictionary, we
get an error as follows-
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'};
print "dict['Alice']: ", dict['Alice']
When the above code is executed, it produces the following resultdict['Zara']:
Traceback (most recent call last):
 File "test.py", line 4, in <module>
 print "dict['Alice']: ", dict['Alice'];
KeyError: 'Alice'
13.Python 3 – Dictionary 
Python 3
165
Updating Dictionary
You can update a dictionary by adding a new entry or a key-value pair, modifying an
existing entry, or deleting an existing entry as shown in a simple example given below.
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
dict['Age'] = 8; # update existing entry
dict['School'] = "DPS School" # Add new entry
print ("dict['Age']: ", dict['Age'])
print ("dict['School']: ", dict['School'])
When the above code is executed, it produces the following resultdict['Age']: 8
dict['School']: DPS School
Delete Dictionary Elements
You can either remove individual dictionary elements or clear the entire contents of a
dictionary. You can also delete entire dictionary in a single operation.
To explicitly remove an entire dictionary, just use the del statement. Following is a simple
example-
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'}
del dict['Name'] # remove entry with key 'Name'
dict.clear() # remove all entries in dict
del dict # delete entire dictionary
print ("dict['Age']: ", dict['Age'])
print ("dict['School']: ", dict['School'])
This produces the following result.
Note: An exception is raised because after del dict, the dictionary does not exist
anymore.
dict['Age']:
Traceback (most recent call last):
 File "test.py", line 8, in <module>
Python 3
166
 print "dict['Age']: ", dict['Age'];
TypeError: 'type' object is unsubscriptable
Note: The del() method is discussed in subsequent section.
Properties of Dictionary Keys
Dictionary values have no restrictions. They can be any arbitrary Python object, either
standard objects or user-defined objects. However, same is not true for the keys.
There are two important points to remember about dictionary keys-
(a) More than one entry per key is not allowed. This means no duplicate key is allowed.
When duplicate keys are encountered during assignment, the last assignment wins. For
example-
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7, 'Name': 'Manni'}
print ("dict['Name']: ", dict['Name'])
When the above code is executed, it produces the following resultdict['Name']: Manni
(b) Keys must be immutable. This means you can use strings, numbers or tuples as
dictionary keys but something like ['key'] is not allowed. Following is a simple example-
#!/usr/bin/python3
dict = {['Name']: 'Zara', 'Age': 7}
print ("dict['Name']: ", dict['Name'])
When the above code is executed, it produces the following resultTraceback (most recent call last):
 File "test.py", line 3, in <module>
 dict = {['Name']: 'Zara', 'Age': 7}
TypeError: list objects are unhashable
Python 3
167
Built-in Dictionary Functions & Methods
Python includes the following dictionary functionsSN Functions with Description
1 cmp(dict1, dict2)
No longer available in Python 3.
2 len(dict)
Gives the total length of the dictionary. This would be equal to the number of items
in the dictionary.
3 str(dict)
Produces a printable string representation of a dictionary.
4 type(variable)
Returns the type of the passed variable. If passed variable is dictionary, then it
would return a dictionary type.
Dictionary len() Method
DescriptionThe method len() gives the total length of the dictionary. This
would be equal to the number of items in the dictionary.
Syntax
Following is the syntax for len() methodlen(dict)
Parameters
dict - This is the dictionary, whose length needs to be calculated.
Return Value
This method returns the length.
Example
The following example shows the usage of len() method.
#!/usr/bin/python3
Python 3
168
dict = {'Name': 'Manni', 'Age': 7, 'Class': 'First'}
print ("Length : %d" % len (dict))
When we run the above program, it produces the following resultLength : 3
Dictionary str() Method
Description
The method str() produces a printable string representation of a dictionary.
Syntax
Following is the syntax for str() method −
str(dict)
Parameters
dict - This is the dictionary.
Return Value
This method returns string representation.
Example
The following example shows the usage of str() method.
#!/usr/bin/python3
dict = {'Name': 'Manni', 'Age': 7, 'Class': 'First'}
print ("Equivalent String : %s" % str (dict))
When we run the above program, it produces the following resultEquivalent String : {'Name': 'Manni', 'Age': 7, 'Class': 'First'}
Dictionary type() Method
Description
The method type() returns the type of the passed variable. If passed variable is dictionary
then it would return a dictionary type.
Python 3
169
Syntax
Following is the syntax for type() methodtype(dict)
Parameters
dict - This is the dictionary.
Return Value
This method returns the type of the passed variable.
Example
The following example shows the usage of type() method.
#!/usr/bin/python3
dict = {'Name': 'Manni', 'Age': 7, 'Class': 'First'}
print ("Variable Type : %s" % type (dict))
When we run the above program, it produces the following resultVariable Type : <type 'dict'>
Python includes the following dictionary methodsSN Methods with Description
1 dict.clear()
Removes all elements of dictionary dict.
2 dict.copy()
Returns a shallow copy of dictionary dict.
3 dict.fromkeys()
Create a new dictionary with keys from seq and values set to value.
4 dict.get(key, default=None)
For key key, returns value or default if key not in dictionary.
Python 3
170
5 dict.has_key(key)
Removed, use the in operation instead.
6 dict.items()
Returns a list of dict's (key, value) tuple pairs.
7 dict.keys()
Returns list of dictionary dict's keys.
8 dict.setdefault(key, default=None)
Similar to get(), but will set dict[key]=default if key is not already in dict.
9 dict.update(dict2)
Adds dictionary dict2's key-values pairs to dict.
10 dict.values()
Returns list of dictionary dict's values.
Dictionary clear() Method
Description
The method clear() removes all items from the dictionary.
Syntax
Following is the syntax for clear() methoddict.clear()
Parameters
NA
Return Value
This method does not return any value.
Example
The following example shows the usage of clear() method.
#!/usr/bin/python3
Python 3
171
dict = {'Name': 'Zara', 'Age': 7}
print ("Start Len : %d" % len(dict))
dict.clear()
print ("End Len : %d" % len(dict))
When we run the above program, it produces the following resultStart Len : 2
End Len : 0
Dictionary copy() Method
Description
The method copy() returns a shallow copy of the dictionary.
Syntax
Following is the syntax for copy() methoddict.copy()
Parameters
NA
Return Value
This method returns a shallow copy of the dictionary.
Example
The following example shows the usage of copy() method.
#!/usr/bin/python3
dict1 = {'Name': 'Manni', 'Age': 7, 'Class': 'First'}
dict2 = dict1.copy()
print ("New Dictionary : ",dict2)
When we run the above program, it produces following resultNew dictionary : {'Name': 'Manni', 'Age': 7, 'Class': 'First'}
Python 3
172
Dictionary fromkeys() Method
Description
The method fromkeys() creates a new dictionary with keys from seq and values set to
value.
Syntax
Following is the syntax for fromkeys() methoddict.fromkeys(seq[, value]))
Parameters
 seq - This is the list of values which would be used for dictionary keys preparation.
 value - This is optional, if provided then value would be set to this value
Return Value
This method returns the list.
Example
The following example shows the usage of fromkeys() method.
#!/usr/bin/python3
seq = ('name', 'age', 'sex')
dict = dict.fromkeys(seq)
print ("New Dictionary : %s" % str(dict))
dict = dict.fromkeys(seq, 10)
print ("New Dictionary : %s" % str(dict))
When we run the above program, it produces the following resultNew Dictionary : {'age': None, 'name': None, 'sex': None}
New Dictionary : {'age': 10, 'name': 10, 'sex': 10}
Dictionary get() Method
Description
The method get() returns a value for the given key. If the key is not available then returns
default value None.
Syntax
Python 3
173
Following is the syntax for get() methoddict.get(key, default=None)
Parameters
 key - This is the Key to be searched in the dictionary.
 default - This is the Value to be returned in case key does not exist.
Return Value
This method returns a value for the given key. If the key is not available, then returns
default value as None.
Example
The following example shows the usage of get() method.
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 27}
print ("Value : %s" % dict.get('Age'))
print ("Value : %s" % dict.get('Sex', "NA"))
When we run the above program, it produces the following resultValue : 27
Value : NA
Dictionary items() Method
Description
The method items() returns a list of dict's (key, value) tuple pairs.
Syntax
Following is the syntax for items() methoddict.items()
Parameters
NA
Return Value
This method returns a list of tuple pairs.
Python 3
174
Example
The following example shows the usage of items() method.
#!/usr/bin/python
dict = {'Name': 'Zara', 'Age': 7}
print ("Value : %s" % dict.items())
When we run the above program, it produces the following resultValue : [('Age', 7), ('Name', 'Zara')]
Dictionary keys() Method
Description
The method keys() returns a list of all the available keys in the dictionary.
Syntax
Following is the syntax for keys() methoddict.keys()
Parameters
NA
Return Value
This method returns a list of all the available keys in the dictionary.
Example
The following example shows the usage of keys() method.
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7}
print ("Value : %s" % dict.keys())
When we run the above program, it produces the following resultValue : ['Age', 'Name']
Dictionary setdefault() Method
Description
Python 3
175
The method setdefault() is similar to get(), but will set dict[key]=default if the key is not
already in dict.
Syntax
Following is the syntax for setdefault() methoddict.setdefault(key, default=None)
Parameters
 key - This is the key to be searched.
 default - This is the Value to be returned in case key is not found.
Return Value
This method returns the key value available in the dictionary and if given key is not
available then it will return provided default value.
Example
The following example shows the usage of setdefault() method.
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7}
print ("Value : %s" % dict.setdefault('Age', None))
print ("Value : %s" % dict.setdefault('Sex', None))
print (dict)
When we run the above program, it produces the following resultValue : 7
Value : None
{'Name': 'Zara', 'Sex': None, 'Age': 7}
Dictionary update() Method
Description
The method update() adds dictionary dict2's key-values pairs in to dict. This function
does not return anything.
Syntax
Following is the syntax for update() methoddict.update(dict2)
Python 3
176
Parameters
dict2 - This is the dictionary to be added into dict.
Return Value
This method does not return any value.
Example
The following example shows the usage of update() method.
#!/usr/bin/python3
dict = {'Name': 'Zara', 'Age': 7}
dict2 = {'Sex': 'female' }
dict.update(dict2)
print ("updated dict : ", dict)
When we run the above program, it produces the following resultupdated dict : {'Sex': 'female', 'Age': 7, 'Name': 'Zara'}
Dictionary values() Method
Description
The method values() returns a list of all the values available in a given dictionary.
Syntax
Following is the syntax for values() methoddict.values()
Parameters
NA
Return Value
This method returns a list of all the values available in a given dictionary.
Example
The following example shows the usage of values() method.
#!/usr/bin/python3
dict = {'Sex': 'female', 'Age': 7, 'Name': 'Zara'}
Python 3
177
print ("Values : ", list(dict.values()))
When we run above program, it produces following resultValues : ['female', 7, 'Zara']
Python 3
178
A Python program can handle date and time in several ways. Converting between date
formats is a common chore for computers. Python's time and calendar modules help track
dates and times.
What is Tick?
Time intervals are floating-point numbers in units of seconds. Particular instants in time
are expressed in seconds since 12:00am, January 1, 1970(epoch).
There is a popular time module available in Python, which provides functions for working
with times, and for converting between representations. The function time.time() returns
the current system time in ticks since 12:00am, January 1, 1970(epoch).
Example
#!/usr/bin/python3
import time; # This is required to include time module.
ticks = time.time()
print ("Number of ticks since 12:00am, January 1, 1970:", ticks)
This would produce a result something as followsNumber of ticks since 12:00am, January 1, 1970: 1455508609.34375
Date arithmetic is easy to do with ticks. However, dates before the epoch cannot be
represented in this form. Dates in the far future also cannot be represented this way - the
cutoff point is sometime in 2038 for UNIX and Windows.
What is TimeTuple?
Many of the Python's time functions handle time as a tuple of 9 numbers, as shown belowIndex Field Values
0 4-digit year 2016
1 Month 1 to 12
2 Day 1 to 31
14.Python 3 – Date & Time 
Python 3
179
3 Hour 0 to 23
4 Minute 0 to 59
5 Second 0 to 61 (60 or 61 are leap-seconds)
6 Day of Week 0 to 6 (0 is Monday)
7 Day of year 1 to 366 (Julian day)
8 Daylight savings -1, 0, 1, -1 means library determines DST
For Example-
>>>import time
>>> print (time.localtime())
This would produce a result as followstime.struct_time(tm_year=2016, tm_mon=2, tm_mday=15, tm_hour=9, tm_min=29,
tm_sec=2, tm_wday=0, tm_yday=46, tm_isdst=0)
The above tuple is equivalent to struct_time structure. This structure has the following
attributesIndex Attributes Values
0 tm_year 2016
1 tm_mon 1 to 12
2 tm_mday 1 to 31
3 tm_hour 0 to 23
4 tm_min 0 to 59
5 tm_sec 0 to 61 (60 or 61 are leap-seconds)
6 tm_wday 0 to 6 (0 is Monday)
Python 3
180
7 tm_yday 1 to 366 (Julian day)
8 tm_isdst -1, 0, 1, -1 means library determines DST
Getting current time
To translate a time instant from seconds since the epoch floating-point value into a timetuple, pass the floating-point value to a function (e.g., localtime) that returns a time-tuple
with all valid nine items.
#!/usr/bin/python3
import time
localtime = time.localtime(time.time())
print ("Local current time :", localtime)
This would produce the following result, which could be formatted in any other presentable
formLocal current time : time.struct_time(tm_year=2016, tm_mon=2, tm_mday=15,
tm_hour=9, tm_min=29, tm_sec=2, tm_wday=0, tm_yday=46, tm_isdst=0)
Getting formatted time
You can format any time as per your requirement, but a simple method to get time in a
readable format is asctime() −
#!/usr/bin/python3
import time
localtime = time.asctime( time.localtime(time.time()) )
print ("Local current time :", localtime)
This would produce the following resultLocal current time : Mon Feb 15 09:34:03 2016
Getting calendar for a month
The calendar module gives a wide range of methods to play with yearly and monthly
calendars. Here, we print a calendar for a given month ( Jan 2008 ).
#!/usr/bin/python3
import calendar
Python 3
181
cal = calendar.month(2016, 2)
print ("Here is the calendar:")
print (cal)
This would produce the following resultHere is the calendar:
 February 2016
Mo Tu We Th Fr Sa Su
1 2 3 4 5 6 7
8 9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29
The time Module
There is a popular time module available in Python, which provides functions for working
with times and for converting between representations. Here is the list of all available
methods.
SN Function with Description
1 time.altzone
The offset of the local DST timezone, in seconds west of UTC, if one is defined.
This is negative if the local DST timezone is east of UTC (as in Western Europe,
including the UK). Use this if the daylight is nonzero.
2 time.asctime([tupletime])
Accepts a time-tuple and returns a readable 24-character string such as 'Tue Dec
11 18:07:14 2008'.
3 time.clock( )
Returns the current CPU time as a floating-point number of seconds. To measure
computational costs of different approaches, the value of time.clock is more useful
than that of time.time().
4 time.ctime([secs])
Like asctime(localtime(secs)) and without arguments is like asctime( )
Python 3
182
5 time.gmtime([secs])
Accepts an instant expressed in seconds since the epoch and returns a time-tuple
t with the UTC time. Note : t.tm_isdst is always 0
6 time.localtime([secs])
Accepts an instant expressed in seconds since the epoch and returns a time-tuple
t with the local time (t.tm_isdst is 0 or 1, depending on whether DST applies to
instant secs by local rules).
7 time.mktime(tupletime)
Accepts an instant expressed as a time-tuple in local time and returns a floatingpoint value with the instant expressed in seconds since the epoch.
8 time.sleep(secs)
Suspends the calling thread for secs seconds.
9 time.strftime(fmt[,tupletime])
Accepts an instant expressed as a time-tuple in local time and returns a string
representing the instant as specified by string fmt.
10 time.strptime(str,fmt='%a %b %d %H:%M:%S %Y')
Parses str according to format string fmt and returns the instant in time-tuple
format.
11 time.time( )
Returns the current time instant, a floating-point number of seconds since the
epoch.
12 time.tzset()
Resets the time conversion rules used by the library routines. The environment
variable TZ specifies how this is done.
Let us go through the functions brieflyTime altzone() Method
Description
The method altzone() is the attribute of the time module. This returns the offset of the
local DST timezone, in seconds west of UTC, if one is defined. This is negative if the local 
Python 3
183
DST timezone is east of UTC (as in Western Europe, including the UK). Only use this if
daylight is nonzero.
Syntax
Following is the syntax for altzone() methodtime.altzone
Parameters
NA
Return Value
This method returns the offset of the local DST timezone, in seconds west of UTC, if one
is defined.
Example
The following example shows the usage of altzone() method.
#!/usr/bin/python3
import time
print ("time.altzone : ", time.altzone)
When we run the above program, it produces the following resulttime.altzone : -23400
Time asctime() Method
Description
The method asctime() converts a tuple or struct_time representing a time as returned by
gmtime() or localtime() to a 24-character string of the following form: 'Tue Feb 17
23:21:05 2009'.
Syntax
Following is the syntax for asctime() methodtime.asctime([t]))
Parameters
t - This is a tuple of 9 elements or struct_time representing a time as returned by gmtime()
or localtime() function.
Python 3
184
Return Value
This method returns 24-character string of the following form: 'Tue Feb 17 23:21:05
2009'.
Example
The following example shows the usage of asctime() method.
#!/usr/bin/python3
import time
t = time.localtime()
print ("asctime : ",time.asctime(t))
When we run the above program, it produces the following resultasctime : Mon Feb 15 09:46:24 2016
Time clock() Method
Description
The method clock() returns the current processor time as a floating point number
expressed in seconds on Unix. The precision depends on that of the C function of the same
name, but in any case, this is the function to use for benchmarking Python or timing
algorithms.
On Windows, this function returns wall-clock seconds elapsed since the first call to this
function, as a floating point number, based on the Win32 function
QueryPerformanceCounter.
Syntax
Following is the syntax for clock() methodtime.clock()
Parameters
NA
Return Value
This method returns the current processor time as a floating point number expressed in
seconds on Unix and in Windows it returns wall-clock seconds elapsed since the first call
to this function, as a floating point number.
Example
The following example shows the usage of clock() method.
Python 3
185
#!/usr/bin/python3
import time
def procedure():
 time.sleep(2.5)
# measure process time
t0 = time.clock()
procedure()
print (time.clock() - t0, "seconds process time")
# measure wall time
t0 = time.time()
procedure()
print (time.time() - t0, "seconds wall time")
When we run the above program, it produces the following result2.4993855364299096 seconds process time
2.5 seconds wall time
Note: Not all systems can measure the true process time. On such systems (including
Windows), clock usually measures the wall time since the program was started.
Time ctime() Method
Description
The method ctime() converts a time expressed in seconds since the epoch to a string
representing local time. If secs is not provided or None, the current time as returned by
time() is used. This function is equivalent to asctime(localtime(secs)). Locale information
is not used by ctime().
Syntax
Following is the syntax for ctime() methodtime.ctime([ sec ])
Parameters
sec - These are the number of seconds to be converted into string representation.
Return Value
This method does not return any value.
Python 3
186
Example
The following example shows the usage of ctime() method.
#!/usr/bin/python3
import time
print ("ctime : ", time.ctime())
When we run the above program, it produces the following resultctime : Mon Feb 15 09:55:34 2016
Time gmtime() Method
Description
The method gmtime() converts a time expressed in seconds since the epoch to a
struct_time in UTC in which the dst flag is always zero. If secs is not provided or None,
the current time as returned by time() is used.
Syntax
Following is the syntax for gmtime() methodtime.gmtime([ sec ])
Parameters
sec - These are the number of seconds to be converted into structure struct_time
representation.
Return Value
This method does not return any value.
Example
The following example shows the usage of gmtime() method.
#!/usr/bin/python3
import time
print ("gmtime :", time.gmtime(1455508609.34375))
When we run the above program, it produces the following result-
Python 3
187
gmtime : time.struct_time(tm_year=2016, tm_mon=2, tm_mday=15, tm_hour=3,
tm_min=56, tm_sec=49, tm_wday=0, tm_yday=46, tm_isdst=0)
Time localtime() Method
Description
The method localtime() is similar to gmtime() but it converts number of seconds to local
time. If secs is not provided or None, the current time as returned by time() is used. The
dst flag is set to 1 when DST applies to the given time.
Syntax
Following is the syntax for localtime() methodtime.localtime([ sec ])
Parameters
sec - These are the number of seconds to be converted into structure struct_time
representation.
Return Value
This method does not return any value.
Example
The following example shows the usage of localtime() method.
#!/usr/bin/python3
import time
print ("time.localtime() : %s" , time.localtime())
When we run the above program, it produces the following resulttime.localtime() : time.struct_time(tm_year=2016, tm_mon=2, tm_mday=15,
tm_hour=10, tm_min=13, tm_sec=50, tm_wday=0, tm_yday=46, tm_isdst=0)
Timemktime() Method
Description
The method mktime() is the inverse function of localtime(). Its argument is the struct_time
or full 9-tuple and it returns a floating point number, for compatibility with time().
Python 3
188
If the input value cannot be represented as a valid time, either OverflowError or ValueError
will be raised.
Syntax
Following is the syntax for mktime() methodtime.mktime(t)
Parameters
t - This is the struct_time or full 9-tuple.
Return Value
This method returns a floating point number, for compatibility with time().
Example
The following example shows the usage of mktime() method.
#!/usr/bin/python3
import time
t = (2016, 2, 15, 10, 13, 38, 1, 48, 0)
d=time.mktime(t)
print ("time.mktime(t) : %f" % d)
print ("asctime(localtime(secs)): %s" % time.asctime(time.localtime(d)))
When we run the above program, it produces the following resulttime.mktime(t) : 1455511418.000000
asctime(localtime(secs)): Mon Feb 15 10:13:38 2016
Time sleep() Method
Description
The method sleep() suspends execution for the given number of seconds. The argument
may be a floating point number to indicate a more precise sleep time.
The actual suspension time may be less than that requested because any caught signal
will terminate the sleep() following execution of that signal's catching routine.
Syntax
Following is the syntax for sleep() method-
Python 3
189
time.sleep(t)
Parameters
t - This is the number of seconds for which the execution is to be suspended.
Return Value
This method does not return any value.
Example
The following example shows the usage of sleep() method.
#!/usr/bin/python3
import time
print ("Start : %s" % time.ctime())
time.sleep( 5 )
print ("End : %s" % time.ctime())
When we run the above program, it produces the following resultStart : Mon Feb 15 12:08:42 2016
End : Mon Feb 15 12:08:47 2016
Time strftime() Method
Description
The method strftime() converts a tuple or struct_time representing a time as returned
by gmtime() or localtime() to a string as specified by the format argument.
If t is not provided, the current time as returned by localtime() is used. The format must
be a string. An exception ValueError is raised if any field in t is outside of the allowed
range.
Syntax
Following is the syntax for strftime() methodtime.strftime(format[, t])
Parameters
 t - This is the time in number of seconds to be formatted.
Python 3
190
 format - This is the directive which would be used to format given time.
The following directives can be embedded in the format stringDirective
 %a - abbreviated weekday name
 %A - full weekday name
 %b - abbreviated month name
 %B - full month name
 %c - preferred date and time representation
 %C - century number (the year divided by 100, range 00 to 99)
 %d - day of the month (01 to 31)
 %D - same as %m/%d/%y
 %e - day of the month (1 to 31)
 %g - like %G, but without the century
 %G - 4-digit year corresponding to the ISO week number (see %V).
 %h - same as %b
 %H - hour, using a 24-hour clock (00 to 23)
 %I - hour, using a 12-hour clock (01 to 12)
 %j - day of the year (001 to 366)
 %m - month (01 to 12)
 %M - minute
 %n - newline character
 %p - either am or pm according to the given time value
 %r - time in a.m. and p.m. notation
 %R - time in 24 hour notation
 %S - second
 %t - tab character
 %T - current time, equal to %H:%M:%S
 %u - weekday as a number (1 to 7), Monday=1. Warning: In Sun Solaris Sunday=1
 %U - week number of the current year, starting with the first Sunday as the first
day of the first week
Python 3
191
 %V - The ISO 8601 week number of the current year (01 to 53), where week 1 is
the first week that has at least 4 days in the current year, and with Monday as the
first day of the week
 %W - week number of the current year, starting with the first Monday as the first
day of the first week
 %w - day of the week as a decimal, Sunday=0
 %x - preferred date representation without the time
 %X - preferred time representation without the date
 %y - year without a century (range 00 to 99)
 %Y - year including the century
 %Z or %z - time zone or name or abbreviation
 %% - a literal % character
Return Value
This method does not return any value.
Example
The following example shows the usage of strftime() method.
#!/usr/bin/python3
import time
t = (2015, 12, 31, 10, 39, 45, 1, 48, 0)
t = time.mktime(t)
print (time.strftime("%b %d %Y %H:%M:%S", time.localtime(t)))
When we run the above program, it produces the following resultDec 31 2015 10:39:45
Time strptime() Method
Description
The method strptime() parses a string representing a time according to a format. The
return value is a struct_time as returned by gmtime() or localtime().
The format parameter uses the same directives as those used by strftime(); it defaults to
"%a %b %d %H:%M:%S %Y" which matches the formatting returned by ctime().
If string cannot be parsed according to format, or if it has excess data after parsing,
ValueError is raised.
Syntax
Python 3
192
Following is the syntax for strptime() methodtime.strptime(string[, format])
Parameters
 string - This is the time in string format which would be parsed based on the given
format.
 format - This is the directive which would be used to parse the given string.
Directive
The following directives can be embedded in the format string-
 %a - abbreviated weekday name
 %A - full weekday name
 %b - abbreviated month name
 %B - full month name
 %c - preferred date and time representation
 %C - century number (the year divided by 100, range 00 to 99)
 %d - day of the month (01 to 31)
 %D - same as %m/%d/%y
 %e - day of the month (1 to 31)
 %g - like %G, but without the century
 %G - 4-digit year corresponding to the ISO week number (see %V).
 %h - same as %b
 %H - hour, using a 24-hour clock (00 to 23)
 %I - hour, using a 12-hour clock (01 to 12)
 %j - day of the year (001 to 366)
 %m - month (01 to 12)
 %M - minute
 %n - newline character
 %p - either am or pm according to the given time value
 %r - time in a.m. and p.m. notation
 %R - time in 24 hour notation
 %S - second
 %t - tab character
 %T - current time, equal to %H:%M:%S
 %u - weekday as a number (1 to 7), Monday=1. Warning: In Sun Solaris Sunday=1
 %U - week number of the current year, starting with the first Sunday as the first
day of the first week
Python 3
193
 %V - The ISO 8601 week number of the current year (01 to 53), where week 1 is
the first week that has at least 4 days in the current year, and with Monday as the
first day of the week
 %W - week number of the current year, starting with the first Monday as the first
day of the first week
 %w - day of the week as a decimal, Sunday=0
 %x - preferred date representation without the time
 %X - preferred time representation without the date
 %y - year without a century (range 00 to 99)
 %Y - year including the century
 %Z or %z - time zone or name or abbreviation
 %% - a literal % character
Return Value
This return value is struct_time as returned by gmtime() or localtime().
Example
The following example shows the usage of strptime() method.
#!/usr/bin/python3
import time
struct_time = time.strptime("30 12 2015", "%d %m %Y")
print ("tuple : ", struct_time)
When we run the above program, it produces the following resulttuple : time.struct_time(tm_year=2015, tm_mon=12, tm_mday=30, tm_hour=0,
tm_min=0, tm_sec=0, tm_wday=2, tm_yday=364, tm_isdst=-1)
Time time() Method
Description
The method time() returns the time as a floating point number expressed in seconds since
the epoch, in UTC.
Note: Even though the time is always returned as a floating point number, not all systems
provide time with a better precision than 1 second. While this function normally returns
non-decreasing values, it can return a lower value than a previous call if the system clock
has been set back between the two calls.
Syntax
Python 3
194
Following is the syntax for time() methodtime.time()
Parameters
NA
Return Value
This method returns the time as a floating point number expressed in seconds since the
epoch, in UTC.
Example
The following example shows the usage of time() method.
#!/usr/bin/python3
import time
print ("time.time(): %f " % time.time())
print (time.localtime( time.time() ))
print (time.asctime( time.localtime(time.time()) ))
When we run the above program, it produces the following resulttime.time(): 1455519806.011433
time.struct_time(tm_year=2016, tm_mon=2, tm_mday=15, tm_hour=12, tm_min=33,
tm_sec=26, tm_wday=0, tm_yday=46, tm_isdst=0)
Mon Feb 15 12:33:26 2016
Time tzset() Method
Description
The method tzset() resets the time conversion rules used by the library routines. The
environment variable TZ specifies how this is done.
The standard format of the TZ environment variable is (whitespace added for clarity)-
std offset [dst [offset [,start[/time], end[/time]]]]
 std and dst: Three or more alphanumerics giving the timezone abbreviations. These
will be propagated into time.tzname.
 offset: The offset has the form: .hh[:mm[:ss]]. This indicates the value added the
local time to arrive at UTC. If preceded by a '-', the timezone is east of the Prime
Meridian; otherwise, it is west. If no offset follows dst, summer time is assumed to
be one hour ahead of standard time.
Python 3
195
 start[/time], end[/time]: Indicates when to change to and back from DST. The
format of the start and end dates are one of the following:
o Jn: The Julian day n (1 <= n <= 365). Leap days are not counted, so in all years
February 28 is day 59 and March 1 is day 60.
o n: The zero-based Julian day (0 <= n <= 365). Leap days are counted, and it is
possible to refer to February 29.
o Mm.n.d: The d'th day (0 <= d <= 6) or week n of month m of the year (1 <= n
<= 5, 1 <= m <= 12, where week 5 means 'the last d day in month m' which
may occur in either the fourth or the fifth week). Week 1 is the first week in which
the d'th day occurs. Day zero is Sunday.
o time: This has the same format as offset except that no leading sign ('-' or '+')
is allowed. The default, if time is not given, is 02:00:00.
Syntax
Following is the syntax for tzset() methodtime.tzset()
Parameters
NA
Return Value
This method does not return any value.
Example
The following example shows the usage of tzset() method.
#!/usr/bin/python3
import time
import os
os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
time.tzset()
print time.strftime('%X %x %Z')
os.environ['TZ'] = 'AEST-10AEDT-11,M10.5.0,M3.5.0'
time.tzset()
print time.strftime('%X %x %Z')
Python 3
196
When we run the above program, it produces the following result13:00:40 02/17/09 EST
05:00:40 02/18/09 AEDT
There are two important attributes available with time module. They areSN Attribute with Description
1 time.timezone
Attribute time.timezone is the offset in seconds of the local time zone (without
DST) from UTC (>0 in the Americas; <=0 in most of Europe, Asia, Africa).
2 time.tzname
Attribute time.tzname is a pair of locale-dependent strings, which are the names
of the local time zone without and with DST, respectively.
The calendar Module
The calendar module supplies calendar-related functions, including functions to print a text
calendar for a given month or year.
By default, calendar takes Monday as the first day of the week and Sunday as the last
one. To change this, call the calendar.setfirstweekday() function.
Here is a list of functions available with the calendar moduleSN Function with Description
1 calendar.calendar(year,w=2,l=1,c=6)
Returns a multiline string with a calendar for year year formatted into three
columns separated by c spaces. w is the width in characters of each date; each
line has length 21*w+18+2*c. l is the number of lines for each week.
Python 3
197
2 calendar.firstweekday( )
Returns the current setting for the weekday that starts each week. By default,
when calendar is first imported, this is 0, meaning Monday.
3 calendar.isleap(year)
Returns True if year is a leap year; otherwise, False.
4 calendar.leapdays(y1,y2)
Returns the total number of leap days in the years within range(y1,y2).
5 calendar.month(year,month,w=2,l=1)
Returns a multiline string with a calendar for month month of year year, one line
per week plus two header lines. w is the width in characters of each date; each
line has length 7*w+6. l is the number of lines for each week.
6 calendar.monthcalendar(year,month)
Returns a list of lists of ints. Each sublist denotes a week. Days outside month
month of year year are set to 0; days within the month are set to their day-ofmonth, 1 and up.
7 calendar.monthrange(year,month)
Returns two integers. The first one is the code of the weekday for the first day of
the month month in year year; the second one is the number of days in the month.
Weekday codes are 0 (Monday) to 6 (Sunday); month numbers are 1 to 12.
8 calendar.prcal(year,w=2,l=1,c=6)
Like print calendar.calendar(year,w,l,c).
9 calendar.prmonth(year,month,w=2,l=1)
Like print calendar.month(year,month,w,l).
10 calendar.setfirstweekday(weekday)
Sets the first day of each week to weekday code weekday. Weekday codes are 0
(Monday) to 6 (Sunday).
11 calendar.timegm(tupletime)
The inverse of time.gmtime: accepts a time instant in time-tuple form and returns
the same instant as a floating-point number of seconds since the epoch.
Python 3
198
12 calendar.weekday(year,month,day)
Returns the weekday code for the given date. Weekday codes are 0 (Monday) to
6 (Sunday); month numbers are 1 (January) to 12 (December).
Other Modules & Functions
If you are interested, then here you would find a list of other important modules and
functions to play with date & time in Python-
 The datetime Module
 The pytz Module
 The dateutil Module
Python 3
199
A function is a block of organized, reusable code that is used to perform a single, related
action. Functions provide better modularity for your application and a high degree of code
reusing.
As you already know, Python gives you many built-in functions like print(), etc. but you
can also create your own functions. These functions are called user-defined functions.
Defining a Function
You can define functions to provide the required functionality. Here are simple rules to
define a function in Python.
 Function blocks begin with the keyword def followed by the function name and
parentheses ( ( ) ).
 Any input parameters or arguments should be placed within these parentheses.
You can also define parameters inside these parentheses.
 The first statement of a function can be an optional statement - the documentation
string of the function or docstring.
 The code block within every function starts with a colon (:) and is indented.
 The statement return [expression] exits a function, optionally passing back an
expression to the caller. A return statement with no arguments is the same as
return None.
Syntax
def functionname( parameters ):
 "function_docstring"
 function_suite
 return [expression]
By default, parameters have a positional behavior and you need to inform them in the
same order that they were defined.
Example
The following function takes a string as input parameter and prints it on the standard
screen.
def printme( str ):
 "This prints a passed string into this function"
 print (str)
15.Python 3 – Functions 
Python 3
200
 return
Calling a Function
Defining a function gives it a name, specifies the parameters that are to be included in the
function and structures the blocks of code.
Once the basic structure of a function is finalized, you can execute it by calling it from
another function or directly from the Python prompt. Following is an example to call the
printme() function-
#!/usr/bin/python3
# Function definition is here
def printme( str ):
 "This prints a passed string into this function"
 print (str)
 return
# Now you can call printme function
printme("This is first call to the user defined function!")
printme("Again second call to the same function")
When the above code is executed, it produces the following resultThis is first call to the user defined function!
Again second call to the same function
Pass by Reference vs Value
All parameters (arguments) in the Python language are passed by reference. It means if
you change what a parameter refers to within a function, the change also reflects back in
the calling function. For example-
#!/usr/bin/python3
# Function definition is here
def changeme( mylist ):
 "This changes a passed list into this function"
 print ("Values inside the function before change: ", mylist)
 mylist[2]=50
 print ("Values inside the function after change: ", mylist)
Python 3
201
 return
# Now you can call changeme function
mylist = [10,20,30]
changeme( mylist )
print ("Values outside the function: ", mylist)
Here, we are maintaining reference of the passed object and appending values in the same
object. Therefore, this would produce the following resultValues inside the function before change: [10, 20, 30]
Values inside the function after change: [10, 20, 50]
Values outside the function: [10, 20, 50]
There is one more example where argument is being passed by reference and the
reference is being overwritten inside the called function.
#!/usr/bin/python3
# Function definition is here
def changeme( mylist ):
 "This changes a passed list into this function"
 mylist = [1,2,3,4] # This would assi new reference in mylist
 print ("Values inside the function: ", mylist)
 return
# Now you can call changeme function
mylist = [10,20,30]
changeme( mylist )
print ("Values outside the function: ", mylist)
The parameter mylist is local to the function changeme. Changing mylist within the
function does not affect mylist. The function accomplishes nothing and finally this would
produce the following resultValues inside the function: [1, 2, 3, 4]
Values outside the function: [10, 20, 30]
Python 3
202
Function Arguments
You can call a function by using the following types of formal arguments-
 Required arguments
 Keyword arguments
 Default arguments
 Variable-length arguments
Required Arguments
Required arguments are the arguments passed to a function in correct positional order.
Here, the number of arguments in the function call should match exactly with the function
definition.
To call the function printme(), you definitely need to pass one argument, otherwise it gives
a syntax error as follows-
#!/usr/bin/python3
# Function definition is here
def printme( str ):
 "This prints a passed string into this function"
 print (str)
 return
# Now you can call printme function
printme()
When the above code is executed, it produces the following resultTraceback (most recent call last):
 File "test.py", line 11, in <module>
 printme()
TypeError: printme() missing 1 required positional argument: 'str'
Keyword Arguments
Keyword arguments are related to the function calls. When you use keyword arguments
in a function call, the caller identifies the arguments by the parameter name.
This allows you to skip arguments or place them out of order because the Python
interpreter is able to use the keywords provided to match the values with parameters. You
can also make keyword calls to the printme() function in the following ways-
#!/usr/bin/python3
# Function definition is here
Python 3
203
def printme( str ):
 "This prints a passed string into this function"
 print (str)
 return
# Now you can call printme function
printme( str = "My string")
When the above code is executed, it produces the following resultMy string
The following example gives a clearer picture. Note that the order of parameters does not
matter.
#!/usr/bin/python3
# Function definition is here
def printinfo( name, age ):
 "This prints a passed info into this function"
 print ("Name: ", name)
 print ("Age ", age)
 return
# Now you can call printinfo function
printinfo( age=50, name="miki" )
When the above code is executed, it produces the following resultName: miki
Age 50
Default Arguments
A default argument is an argument that assumes a default value if a value is not provided
in the function call for that argument. The following example gives an idea on default
arguments, it prints default age if it is not passed.
#!/usr/bin/python3
# Function definition is here
def printinfo( name, age = 35 ):
 "This prints a passed info into this function"
 print ("Name: ", name)
Python 3
204
 print ("Age ", age)
 return
# Now you can call printinfo function
printinfo( age=50, name="miki" )
printinfo( name="miki" )
When the above code is executed, it produces the following resultName: miki
Age 50
Name: miki
Age 35
Variable-length Arguments
You may need to process a function for more arguments than you specified while defining
the function. These arguments are called variable-length arguments and are not named in
the function definition, unlike required and default arguments.
Syntax for a function with non-keyword variable arguments is given belowdef functionname([formal_args,] *var_args_tuple ):
 "function_docstring"
 function_suite
 return [expression]
An asterisk (*) is placed before the variable name that holds the values of all nonkeyword
variable arguments. This tuple remains empty if no additional arguments are specified
during the function call. Following is a simple example-
#!/usr/bin/python3
# Function definition is here
def printinfo( arg1, *vartuple ):
 "This prints a variable passed arguments"
 print ("Output is: ")
 print (arg1)
 for var in vartuple:
 print (var)
 return
# Now you can call printinfo function
printinfo( 10 )
printinfo( 70, 60, 50 )
Python 3
205
When the above code is executed, it produces the following resultOutput is:
10
Output is:
70
60
50
TheAnonymousFunctions
These functions are called anonymous because they are not declared in the standard
manner by using the def keyword. You can use the lambda keyword to create small
anonymous functions.
 Lambda forms can take any number of arguments but return just one value in the
form of an expression. They cannot contain commands or multiple expressions.
 An anonymous function cannot be a direct call to print because lambda requires an
expression.
 Lambda functions have their own local namespace and cannot access variables
other than those in their parameter list and those in the global namespace.
 Although it appears that lambdas are a one-line version of a function, they are not
equivalent to inline statements in C or C++, whose purpose is to stack allocation
by passing function, during invocation for performance reasons.
Syntax
The syntax of lambda function contains only a single statement, which is as followslambda [arg1 [,arg2,.....argn]]:expression
Following is an example to show how lambda form of function works-
#!/usr/bin/python3
# Function definition is here
sum = lambda arg1, arg2: arg1 + arg2
# Now you can call sum as a function
print ("Value of total : ", sum( 10, 20 ))
print ("Value of total : ", sum( 20, 20 ))
When the above code is executed, it produces the following result-
Python 3
206
Value of total : 30
Value of total : 40
ThereturnStatement
The statement return [expression] exits a function, optionally passing back an expression
to the caller. A return statement with no arguments is the same as return None.
All the examples given above are not returning any value. You can return a value from a
function as follows-
#!/usr/bin/python3
# Function definition is here
def sum( arg1, arg2 ):
 # Add both the parameters and return them."
 total = arg1 + arg2
 print ("Inside the function : ", total)
 return total
# Now you can call sum function
total = sum( 10, 20 )
print ("Outside the function : ", total )
When the above code is executed, it produces the following resultInside the function : 30
Outside the function : 30
Scope of Variables
All variables in a program may not be accessible at all locations in that program. This
depends on where you have declared a variable.
The scope of a variable determines the portion of the program where you can access a
particular identifier. There are two basic scopes of variables in Python-
 Global variables
 Local variables
Global vs. Local variables
Variables that are defined inside a function body have a local scope, and those defined
outside have a global scope.
Python 3
207
This means that local variables can be accessed only inside the function in which they are
declared, whereas global variables can be accessed throughout the program body by all
functions. When you call a function, the variables declared inside it are brought into scope.
Following is a simple example-
#!/usr/bin/python3
total = 0 # This is global variable.
# Function definition is here
def sum( arg1, arg2 ):
 # Add both the parameters and return them."
 total = arg1 + arg2; # Here total is local variable.
 print ("Inside the function local total : ", total)
 return total
# Now you can call sum function
sum( 10, 20 )
print ("Outside the function global total : ", total )
When the above code is executed, it produces the following resultInside the function local total : 30
Outside the function global total : 0
Python 3
208
A module allows you to logically organize your Python code. Grouping related code into a
module makes the code easier to understand and use. A module is a Python object with
arbitrarily named attributes that you can bind and reference.
Simply, a module is a file consisting of Python code. A module can define functions, classes
and variables. A module can also include runnable code.
Example
The Python code for a module named aname normally resides in a file namedaname.py.
Here is an example of a simple module, support.pydef print_func( par ):
 print "Hello : ", par
 return
The import Statement
You can use any Python source file as a module by executing an import statement in some
other Python source file. The import has the following syntaximport module1[, module2[,... moduleN]
When the interpreter encounters an import statement, it imports the module if the module
is present in the search path. A search path is a list of directories that the interpreter
searches before importing a module. For example, to import the module hello.py, you
need to put the following command at the top of the script-
#!/usr/bin/python3
# Import module support
import support
# Now you can call defined function that module as follows
support.print_func("Zara")
When the above code is executed, it produces the following resultHello : Zara
A module is loaded only once, regardless of the number of times it is imported. This
prevents the module execution from happening repeatedly, if multiple imports occur.
16.Python 3 – Modules 
Python 3
209
The from...import Statement
Python's from statement lets you import specific attributes from a module into the current
namespace. The from...import has the following syntaxfrom modname import name1[, name2[, ... nameN]]
For example, to import the function fibonacci from the module fib, use the following
statement-
#!/usr/bin/python3
# Fibonacci numbers module
def fib(n): # return Fibonacci series up to n
 result = []
 a, b = 0, 1
 while b < n:
 result.append(b)
 a, b = b, a+b
 return result
>>> from fib import fib
>>> fib(100)
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
This statement does not import the entire module fib into the current namespace; it just
introduces the item fibonacci from the module fib into the global symbol table of the
importing module.
The from...import * Statement:
It is also possible to import all the names from a module into the current namespace by
using the following import statementfrom modname import *
This provides an easy way to import all the items from a module into the current
namespace; however, this statement should be used sparingly.
Executing Modules as Scripts
Within a module, the module’s name (as a string) is available as the value of the global
variable __name__. The code in the module will be executed, just as if you imported it,
but with the __name__ set to "__main__". 
Python 3
210
Add this code at the end of your module-
#!/usr/bin/python3
# Fibonacci numbers module
def fib(n): # return Fibonacci series up to n
 result = []
 a, b = 0, 1
 while b < n:
 result.append(b)
 a, b = b, a+b
 return result
if __name__ == "__main__":
 f=fib(100)
 print(f)
When you run the above code, the following output will be displayed.
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
Locating Modules
When you import a module, the Python interpreter searches for the module in the following
sequences-
 The current directory.
 If the module is not found, Python then searches each directory in the shell variable
PYTHONPATH.
 If all else fails, Python checks the default path. On UNIX, this default path is
normally /usr/local/lib/python3/.
The module search path is stored in the system module sys as the sys.path variable. The
sys.path variable contains the current directory, PYTHONPATH, and the installationdependent default.
The PYTHONPATH Variable
The PYTHONPATH is an environment variable, consisting of a list of directories. The syntax
of PYTHONPATH is the same as that of the shell variable PATH.
Python 3
211
Here is a typical PYTHONPATH from a Windows systemset PYTHONPATH=c:\python34\lib;
And here is a typical PYTHONPATH from a UNIX systemset PYTHONPATH=/usr/local/lib/python
Namespaces and Scoping
Variables are names (identifiers) that map to objects. A namespace is a dictionary of
variable names (keys) and their corresponding objects (values).
 A Python statement can access variables in a local namespace and in the global
namespace. If a local and a global variable have the same name, the local variable
shadows the global variable.
 Each function has its own local namespace. Class methods follow the same scoping
rule as ordinary functions.
 Python makes educated guesses on whether variables are local or global. It
assumes that any variable assigned a value in a function is local.
 Therefore, in order to assign a value to a global variable within a function, you must
first use the global statement.
 The statement global VarName tells Python that VarName is a global variable.
Python stops searching the local namespace for the variable.
For example, we define a variable Money in the global namespace. Within the
function Money, we assign Money a value, therefore Python assumes Money as a local
variable.
However, we accessed the value of the local variable Money before setting it, so an
UnboundLocalError is the result. Uncommenting the global statement fixes the problem.
#!/usr/bin/python3
Money = 2000
def AddMoney():
 # Uncomment the following line to fix the code:
 # global Money
 Money = Money + 1
print (Money)
AddMoney()
print (Money)
Python 3
212
The dir( ) Function
The dir() built-in function returns a sorted list of strings containing the names defined by
a module.
The list contains the names of all the modules, variables and functions that are defined in
a module. Following is a simple example-
#!/usr/bin/python3
# Import built-in module math
import math
content = dir(math)
print (content)
When the above code is executed, it produces the following result-
['__doc__', '__file__', '__name__', 'acos', 'asin', 'atan',
'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp',
'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',
'log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh',
'sqrt', 'tan', 'tanh']
Here, the special string variable __name__ is the module's name, and __file__is the
filename from which the module was loaded.
The globals() and locals() Functions
The globals() and locals() functions can be used to return the names in the global and
local namespaces depending on the location from where they are called.
 If locals() is called from within a function, it will return all the names that can be
accessed locally from that function.
 If globals() is called from within a function, it will return all the names that can
be accessed globally from that function.
The return type of both these functions is dictionary. Therefore, names can be extracted
using the keys() function.
The reload() Function
When a module is imported into a script, the code in the top-level portion of a module is
executed only once.
Therefore, if you want to reexecute the top-level code in a module, you can use
the reload() function. The reload() function imports a previously imported module again.
The syntax of the reload() function is this-
Python 3
213
reload(module_name)
Here, module_name is the name of the module you want to reload and not the string
containing the module name. For example, to reload hello module, do the followingreload(hello)
Packages in Python
A package is a hierarchical file directory structure that defines a single Python application
environment that consists of modules and subpackages and sub-subpackages, and so on.
Consider a file Pots.py available in Phone directory. This file has the following line of
source code-
#!/usr/bin/python3
def Pots():
 print ("I'm Pots Phone")
Similarly, we have other two files having different functions with the same name as above.
They are −
 Phone/Isdn.py file having function Isdn()
 Phone/G3.py file having function G3()
Now, create one more file __init__.py in the Phone directory-
 Phone/__init__.py
To make all of your functions available when you have imported Phone, you need to put
explicit import statements in __init__.py as followsfrom Pots import Pots
from Isdn import Isdn
from G3 import G3
After you add these lines to __init__.py, you have all of these classes available when you
import the Phone package.
#!/usr/bin/python3
# Now import your Phone Package.
import Phone
Phone.Pots()
Phone.Isdn()
Phone.G3()
When the above code is executed, it produces the following result-
Python 3
214
I'm Pots Phone
I'm 3G Phone
I'm ISDN Phone
In the above example, we have taken example of a single function in each file, but you
can keep multiple functions in your files. You can also define different Python classes in
those files and then you can create your packages out of those classes.
Python 3
215
This chapter covers all the basic I/O functions available in Python 3. For more functions,
please refer to the standard Python documentation.
Printing to the Screen
The simplest way to produce output is using the print statement where you can pass zero
or more expressions separated by commas. This function converts the expressions you
pass into a string and writes the result to standard output as follows-
#!/usr/bin/python3
print ("Python is really a great language,", "isn't it?")
This produces the following result on your standard screenPython is really a great language, isn't it?
Reading Keyboard Input
Python 2 has two built-in functions to read data from standard input, which by default
comes from the keyboard. These functions are input() and raw_input()
In Python 3, raw_input() function is deprecated. Moreover, input() functions read data
from keyboard as string, irrespective of whether it is enclosed with quotes ('' or "" ) or
not.
The input Function
The input([prompt]) function is equivalent to raw_input, except that it assumes that the
input is a valid Python expression and returns the evaluated result to you.
#!/usr/bin/python3
>>> x=input("something:")
something:10
>>> x
'10'
>>> x=input("something:")
something:'10' #entered data treated as string with or without ''
>>> x
"'10'"
17.Python 3 – Files I/O 
Python 3
216
Opening and Closing Files
Until now, you have been reading and writing to the standard input and output. Now, we
will see how to use actual data files.
Python provides basic functions and methods necessary to manipulate files by default. You
can do most of the file manipulation using a file object.
The open Function
Before you can read or write a file, you have to open it using Python's built-in
open() function. This function creates a file object, which would be utilized to call other
support methods associated with it.
Syntax
file object = open(file_name [, access_mode][, buffering])
Here are parameter details-
 file_name: The file_name argument is a string value that contains the name of
the file that you want to access.
 access_mode: The access_mode determines the mode in which the file has to be
opened, i.e., read, write, append, etc. A complete list of possible values is given
below in the table. This is an optional parameter and the default file access mode
is read (r).
 buffering: If the buffering value is set to 0, no buffering takes place. If the
buffering value is 1, line buffering is performed while accessing a file. If you specify
the buffering value as an integer greater than 1, then buffering action is performed
with the indicated buffer size. If negative, the buffer size is the system default
(default behavior).
Here is a list of the different modes of opening a fileModes Description
r Opens a file for reading only. The file pointer is placed at the beginning of the
file. This is the default mode.
rb Opens a file for reading only in binary format. The file pointer is placed at the
beginning of the file. This is the default mode.
r+ Opens a file for both reading and writing. The file pointer placed at the
beginning of the file.
Python 3
217
rb+ Opens a file for both reading and writing in binary format. The file pointer
placed at the beginning of the file.
w Opens a file for writing only. Overwrites the file if the file exists. If the file
does not exist, creates a new file for writing.
wb Opens a file for writing only in binary format. Overwrites the file if the file
exists. If the file does not exist, creates a new file for writing.
w+ Opens a file for both writing and reading. Overwrites the existing file if the file
exists. If the file does not exist, creates a new file for reading and writing.
wb+ Opens a file for both writing and reading in binary format. Overwrites the
existing file if the file exists. If the file does not exist, creates a new file for
reading and writing.
a Opens a file for appending. The file pointer is at the end of the file if the file
exists. That is, the file is in the append mode. If the file does not exist, it
creates a new file for writing.
ab Opens a file for appending in binary format. The file pointer is at the end of
the file if the file exists. That is, the file is in the append mode. If the file does
not exist, it creates a new file for writing.
a+ Opens a file for both appending and reading. The file pointer is at the end of
the file if the file exists. The file opens in the append mode. If the file does
not exist, it creates a new file for reading and writing.
ab+ Opens a file for both appending and reading in binary format. The file pointer
is at the end of the file if the file exists. The file opens in the append mode. If
the file does not exist, it creates a new file for reading and writing.
The file Object Attributes
Once a file is opened and you have one file object, you can get various information related
to that file.
Here is a list of all the attributes related to a file objectAttribute Description
file.closed Returns true if file is closed, false otherwise.
Python 3
218
file.mode Returns access mode with which file was opened.
file.name Returns name of the file.
Note: softspace attribute is not supported in Python 3.x
Example
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)
print ("Closed or not : ", fo.closed)
print ("Opening mode : ", fo.mode)
fo.close()
This produces the following resultName of the file: foo.txt
Closed or not : False
Opening mode : wb
The close() Method
The close() method of a file object flushes any unwritten information and closes the file
object, after which no more writing can be done.
Python automatically closes a file when the reference object of a file is reassigned to
another file. It is a good practice to use the close() method to close a file.
Syntax
fileObject.close();
Example
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)
Python 3
219
# Close opened file
fo.close()
This produces the following resultName of the file: foo.txt
Reading and Writing Files
The file object provides a set of access methods to make our lives easier. We would see
how to use read() and write() methods to read and write files.
The write() Method
The write() method writes any string to an open file. It is important to note that Python
strings can have binary data and not just text.
The write() method does not add a newline character ('\n') to the end of the stringSyntax
fileObject.write(string);
Here, passed parameter is the content to be written into the opened file.
Example
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "w")
fo.write( "Python is a great language.\nYeah its great!!\n")
# Close opend file
fo.close()
The above method would create foo.txt file and would write given content in that file and
finally it would close that file. If you would open this file, it would have the following
contentPython is a great language.
Yeah its great!!
Python 3
220
The read() Method
The read() method reads a string from an open file. It is important to note that Python
strings can have binary data apart from the text data.
Syntax
fileObject.read([count]);
Here, passed parameter is the number of bytes to be read from the opened file. This
method starts reading from the beginning of the file and if count is missing, then it tries
to read as much as possible, maybe until the end of file.
Example
Let us take a file foo.txt, which we created above.
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "r+")
str = fo.read(10)
print ("Read String is : ", str)
# Close opened file
fo.close()
This produces the following resultRead String is : Python is
File Positions
The tell() method tells you the current position within the file; in other words, the next
read or write will occur at that many bytes from the beginning of the file.
The seek(offset[, from]) method changes the current file position. The offset argument
indicates the number of bytes to be moved. The from argument specifies the reference
position from where the bytes are to be moved.
If from is set to 0, the beginning of the file is used as the reference position. If it is set to
1, the current position is used as the reference position. If it is set to 2 then the end of
the file would be taken as the reference position.
Example
Let us take a file foo.txt, which we created above.
#!/usr/bin/python3
Python 3
221
# Open a file
fo = open("foo.txt", "r+")
str = fo.read(10)
print ("Read String is : ", str)
# Check current position
position = fo.tell()
print ("Current file position : ", position)
# Reposition pointer at the beginning once again
position = fo.seek(0, 0)
str = fo.read(10)
print ("Again read String is : ", str)
# Close opened file
fo.close()
This produces the following resultRead String is : Python is
Current file position : 10
Again read String is : Python is
Renaming and Deleting Files
Python os module provides methods that help you perform file-processing operations,
such as renaming and deleting files.
To use this module, you need to import it first and then you can call any related functions.
The rename() Method
The rename() method takes two arguments, the current filename and the new filename.
Syntax
os.rename(current_file_name, new_file_name)
Example
Following is an example to rename an existing file test1.txt-
#!/usr/bin/python3
import os
Python 3
222
# Rename a file from test1.txt to test2.txt
os.rename( "test1.txt", "test2.txt" )
The remove() Method
You can use the remove() method to delete files by supplying the name of the file to be
deleted as the argument.
Syntax
os.remove(file_name)
Example
Following is an example to delete an existing file test2.txt-
#!/usr/bin/python3
import os
# Delete file test2.txt
os.remove("text2.txt")
Directories in Python
All files are contained within various directories, and Python has no problem handling these
too. The os module has several methods that help you create, remove, and change
directories.
The mkdir() Method
You can use the mkdir() method of the os module to create directories in the current
directory. You need to supply an argument to this method, which contains the name of
the directory to be created.
Syntax
os.mkdir("newdir")
Example
Following is an example to create a directory test in the current directory-
#!/usr/bin/python3
import os
Python 3
223
# Create a directory "test"
os.mkdir("test")
The chdir() Method
You can use the chdir() method to change the current directory. The chdir() method takes
an argument, which is the name of the directory that you want to make the current
directory.
Syntax
os.chdir("newdir")
Example
Following is an example to go into "/home/newdir" directory-
#!/usr/bin/python3
import os
# Changing a directory to "/home/newdir"
os.chdir("/home/newdir")
The getcwd() Method
The getcwd() method displays the current working directory.
Syntax
os.getcwd()
Example
Following is an example to give current directory-
#!/usr/bin/python3
import os
# This would give location of the current directory
os.getcwd()
Python 3
224
The rmdir() Method
The rmdir() method deletes the directory, which is passed as an argument in the method.
Before removing a directory, all the contents in it should be removed.
Syntax
os.rmdir('dirname')
Example
Following is an example to remove the "/tmp/test" directory. It is required to give fully
qualified name of the directory, otherwise it would search for that directory in the current
directory.
#!/usr/bin/python3
import os
# This would remove "/tmp/test" directory.
os.rmdir( "/tmp/test" )
File & Directory Related Methods
There are three important sources, which provide a wide range of utility methods to handle
and manipulate files & directories on Windows and Unix operating systems. They are as
follows-
 File Object Methods: The file object provides functions to manipulate files.
 OS Object Methods: This provides methods to process files as well as directories.
File Methods
A file object is created using open function and here is a list of functions which can be
called on this object.
S.
No. Methods with Description
1 file.close()
Close the file. A closed file cannot be read or written any more.
2 file.flush()
Python 3
225
Flush the internal buffer, like stdio's fflush. This may be a no-op on some file-like
objects.
3 file.fileno()
Returns the integer file descriptor that is used by the underlying implementation
to request I/O operations from the operating system.
4 file.isatty()
Returns True if the file is connected to a tty(-like) device, else False.
5 next(file)
Returns the next line from the file each time it is being called.
6 file.read([size])
Reads at most size bytes from the file (less if the read hits EOF before obtaining
size bytes).
7 file.readline([size])
Reads one entire line from the file. A trailing newline character is kept in the
string.
8 file.readlines([sizehint])
Reads until EOF using readline() and return a list containing the lines. If the
optional sizehint argument is present, instead of reading up to EOF, whole lines
totalling approximately sizehint bytes (possibly after rounding up to an internal
buffer size) are read.
9 file.seek(offset[, whence])
Sets the file's current position
10 file.tell()
Returns the file's current position
11 file.truncate([size])
Truncates the file's size. If the optional size argument is present, the file is
truncated to (at most) that size.
12 file.write(str)
Python 3
226
Writes a string to the file. There is no return value.
13 file.writelines(sequence)
Writes a sequence of strings to the file. The sequence can be any iterable object
producing strings, typically a list of strings.
Let us go through the above mentions methods briefly.
File close() Method
Description
The method close() closes the opened file. A closed file cannot be read or written any
more. Any operation, which requires that the file be opened will raise a ValueError after
the file has been closed. Calling close() more than once is allowed.
Python automatically closes a file when the reference object of a file is reassigned to
another file. It is a good practice to use the close() method to close a file.
Syntax
Following is the syntax for close() methodfileObject.close()
Parameters
NA
Return Value
This method does not return any value.
Example
The following example shows the usage of close() method.
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)
# Close opened file
fo.close()
Python 3
227
When we run the above program, it produces the following resultName of the file: foo.txt
File flush() Method
Description
The method flush() flushes the internal buffer, like stdio's fflush. This may be a no-op on
some file-like objects.
Python automatically flushes the files when closing them. But you may want to flush the
data before closing any file.
Syntax
Following is the syntax for flush() methodfileObject.flush()
Parameters
NA
Return Value
This method does not return any value.
Example
The following example shows the usage of flush() method.
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)
# Here it does nothing, but you can call it with read operation.
fo.flush()
# Close opend file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Python 3
228
File fileno() Method
Description
The method fileno() returns the integer file descriptor that is used by the underlying
implementation to request I/O operations from the operating system.
Syntax
Following is the syntax for fileno() methodfileObject.fileno()
Parameters
NA
Return Value
This method returns the integer file descriptor.
Example
The following example shows the usage of fileno() method.
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)
fid = fo.fileno()
print ("File Descriptor: ", fid)
# Close opend file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
File Descriptor: 3
File isatty() Method
Description
The method isatty() returns True if the file is connected (is associated with a terminal
device) to a tty(-like) device, else False.
Python 3
229
Syntax
Following is the syntax for isatty() methodfileObject.isatty()
Parameters
NA
Return Value
This method returns true if the file is connected (is associated with a terminal device) to
a tty(-like) device, else false.
Example
The following example shows the usage of isatty() method-
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "wb")
print ("Name of the file: ", fo.name)
ret = fo.isatty()
print ("Return value : ", ret)
# Close opend file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Return value : False
File next() Method
Description
File object in Python 3 does not support next() method. Python 3 has a built-in function
next() which retrieves the next item from the iterator by calling its __next__() method. If
default is given, it is returned if the iterator is exhausted, otherwise StopIteration is raised.
This method can be used to read the next input line, from the file object.
Syntax
Following is the syntax for next() method-
Python 3
230
next(iterator[,default])
Parameters
 iterator : file object from which lines are to be read
 default : returned if iterator exhausted. If not given, StopIteration is raised
Return Value
This method returns the next input line.
Example
The following example shows the usage of next() methodAssuming that 'foo.txt' contains following lines
C++
Java
Python
Perl
PHP
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "r")
print ("Name of the file: ", fo.name)
for index in range(5):
 line = next(fo)
 print ("Line No %d - %s" % (index, line))
# Close opened file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Line No 0 - C++
Line No 1 - Java
Line No 2 - Python
Line No 3 - Perl
Line No 4 - PHP
Python 3
231
File read() Method
Description
The method read() reads at most size bytes from the file. If the read hits EOF before
obtaining size bytes, then it reads only available bytes.
Syntax
Following is the syntax for read() methodfileObject.read( size );
Parameters
size - This is the number of bytes to be read from the file.
Return Value
This method returns the bytes read in string.
Example
The following example shows the usage of read() method.
Assuming that 'foo.txt' file contains the following text:
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "r+")
print ("Name of the file: ", fo.name)
line = fo.read(10)
print ("Read Line: %s" % (line))
# Close opened file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Python 3
232
Read Line: This is 1s
File readline() Method
Description
The method readline()reads one entire line from the file. A trailing newline character is
kept in the string. If the size argument is present and non-negative, it is a maximum byte
count including the trailing newline and an incomplete line may be returned.
An empty string is returned only when EOF is encountered immediately.
Syntax
Following is the syntax for readline() methodfileObject.readline( size );
Parameters
size - This is the number of bytes to be read from the file.
Return Value
This method returns the line read from the file.
Example
The following example shows the usage of readline() method.
Assuming that 'foo.txt' file contains following textThis is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "r+")
print ("Name of the file: ", fo.name)
line = fo.readline()
print ("Read Line: %s" % (line))
line = fo.readline(5)
Python 3
233
print ("Read Line: %s" % (line))
# Close opened file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Read Line: This is 1st line
Read Line: This
File readlines() Method
Description
The method readlines() reads until EOF using readline() and returns a list containing the
lines. If the optional sizehint argument is present, instead of reading up to EOF, whole
lines totalling approximately sizehint bytes (possibly after rounding up to an internal buffer
size) are read.
An empty string is returned only when EOF is encountered immediately.
Syntax
Following is the syntax for readlines() methodfileObject.readlines( sizehint );
Parameters
sizehint - This is the number of bytes to be read from the file.
Return Value
This method returns a list containing the lines.
Example
The following example shows the usage of readlines() method.
Assuming that 'foo.txt' file contains following text:
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
Python 3
234
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "r+")
print ("Name of the file: ", fo.name)
line = fo.readlines()
print ("Read Line: %s" % (line))
line = fo.readlines(2)
print ("Read Line: %s" % (line))
# Close opened file
fo.close()
When we run above program, it produces following resultName of the file: foo.txt
Read Line: ['This is 1st line\n', 'This is 2nd line\n',
 'This is 3rd line\n', 'This is 4th line\n',
 'This is 5th line\n']
Read Line:
File seek() Method
Description
The method seek() sets the file's current position at the offset. The whence argument is
optional and defaults to 0, which means absolute file positioning, other values are 1 which
means seek relative to the current position and 2 means seek relative to the file's end.
There is no return value. Note that if the file is opened for appending using either 'a' or
'a+', any seek() operations will be undone at the next write.
If the file is only opened for writing in append mode using 'a', this method is essentially a
no-op, but it remains useful for files opened in append mode with reading enabled (mode
'a+').
If the file is opened in text mode using 't', only offsets returned by tell() are legal. Use of
other offsets causes undefined behavior.
Note that not all file objects are seekable.
Syntax
Following is the syntax for seek() methodfileObject.seek(offset[, whence])
Python 3
235
Parameters
 offset- This is the position of the read/write pointer within the file.
 whence- This is optional and defaults to 0 which means absolute file positioning,
other values are 1 which means seek relative to the current position and 2 means
seek relative to the file's end.
Return Value
This method does not return any value.
Example
The following example shows the usage of seek() method.
Assuming that 'foo.txt' file contains following text:
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
#!/usr/bin/python3
# Open a file
fo = open("foo.txt", "rw+")
print ("Name of the file: ", fo.name)
line = fo.readlines()
print ("Read Line: %s" % (line))
# Again set the pointer to the beginning
fo.seek(0, 0)
line = fo.readline()
print ("Read Line: %s" % (line))
# Close opened file
fo.close()
When we run the above program, it produces the following result-
Python 3
236
Name of the file: foo.txt
Read Line: ['This is 1st line\n', 'This is 2nd line\n', 'This is 3rd line\n',
'This is 4th line\n', 'This is 5th line']
Read Line: This is 1st line
File tell() Method
Description
The method tell() returns the current position of the file read/write pointer within the file.
Syntax
Following is the syntax for tell() methodfileObject.tell()
Parameters
NA
Return Value
This method returns the current position of the file read/write pointer within the file.
Example
The following example shows the usage of tell() methodAssuming that 'foo.txt' file contains following text:
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
#!/usr/bin/python3
fo = open("foo.txt", "r+")
print ("Name of the file: ", fo.name)
line = fo.readline()
print ("Read Line: %s" % (line))
pos=fo.tell()
print ("current position : ",pos)
Python 3
237
# Close opened file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Read Line: This is 1st line
Current Position: 18
File truncate() Method
Description
The method truncate() truncates the file's size. If the optional size argument is present,
the file is truncated to (at most) that size.
The size defaults to the current position. The current file position is not changed. Note that
if a specified size exceeds the file's current size, the result is platform-dependent.
Note: This method will not work in case the file is opened in read-only mode.
Syntax
Following is the syntax for truncate() methodfileObject.truncate( [ size ])
Parameters
size - If this optional argument is present, the file is truncated to (at most) that size.
Return Value
This method does not return any value.
Example
The following example shows the usage of truncate() method.
Assuming that 'foo.txt' file contains following text:
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
Python 3
238
#!/usr/bin/python3
fo = open("foo.txt", "r+")
print ("Name of the file: ", fo.name)
line = fo.readline()
print ("Read Line: %s" % (line))
fo.truncate()
line = fo.readlines()
print ("Read Line: %s" % (line))
# Close opened file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Read Line: This is 1s
Read Line: []
File write() Method
Description
The method write() writes a string str to the file. There is no return value. Due to
buffering, the string may not actually show up in the file until the flush() or close() method
is called.
Syntax
Following is the syntax for write() methodfileObject.write( str )
Parameters
str - This is the String to be written in the file.
Return Value
This method does not return any value.
Python 3
239
Example
The following example shows the usage of write() method.
Assuming that 'foo.txt' file contains following text:
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
#!/usr/bin/python3
# Open a file in read/write mode
fo = open("abc.txt", "r+")
print ("Name of the file: ", fo.name)
str = "This is 6th line"
# Write a line at the end of the file.
fo.seek(0, 2)
line = fo.write( str )
# Now read complete file from beginning.
fo.seek(0,0)
for index in range(6):
 line = next(fo)
 print ("Line No %d - %s" % (index, line))
# Close opened file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Line No 0 - This is 1st line
Line No 1 - This is 2nd line
Line No 2 - This is 3rd line
Line No 3 - This is 4th line
Line No 4 - This is 5th line
Python 3
240
Line No 5 - This is 6th line
File writelines() Method
Description
The method writelines() writes a sequence of strings to the file. The sequence can be
any iterable object producing strings, typically a list of strings. There is no return value.
Syntax
Following is the syntax for writelines() method −
fileObject.writelines( sequence )
Parameters
sequence - This is the Sequence of the strings.
Return Value
This method does not return any value.
Example
The following example shows the usage of writelines() method.
Assuming that 'foo.txt' file contains following text:
This is 1st line
This is 2nd line
This is 3rd line
This is 4th line
This is 5th line
#!/usr/bin/python3
# Open a file in read/write mode
fo = open("abc.txt", "r+")
print ("Name of the file: ", fo.name)
seq = ["This is 6th line\n", "This is 7th line"]
# Write sequence of lines at the end of the file.
fo.seek(0, 2)
line = fo.writelines( seq )
Python 3
241
# Now read complete file from beginning.
fo.seek(0,0)
for index in range(7):
 line = next(fo)
 print ("Line No %d - %s" % (index, line))
# Close opened file
fo.close()
When we run the above program, it produces the following resultName of the file: foo.txt
Line No 0 - This is 1st line
Line No 1 - This is 2nd line
Line No 2 - This is 3rd line
Line No 3 - This is 4th line
Line No 4 - This is 5th line
Line No 5 - This is 6th line
Line No 6 - This is 7th line
OS File/Directory Methods
The os module provides a big range of useful methods to manipulate files and directories.
Most of the useful methods are listed here:
S.
No. Methods with Description
1 os.access(path, mode)
Use the real uid/gid to test for access to path.
Python 3
242
2 os.chdir(path)
Change the current working directory to path
3 os.chflags(path, flags)
Set the flags of path to the numeric flags.
4 os.chmod(path, mode)
Change the mode of path to the numeric mode.
5 os.chown(path, uid, gid)
Change the owner and group id of path to the numeric uid and gid.
6 os.chroot(path)
Change the root directory of the current process to path.
7 os.close(fd)
Close file descriptor fd.
8 os.closerange(fd_low, fd_high)
Close all file descriptors from fd_low (inclusive) to fd_high (exclusive), ignoring
errors.
9 os.dup(fd)
Return a duplicate of file descriptor fd.
10 os.dup2(fd, fd2)
Duplicate file descriptor fd to fd2, closing the latter first if necessary.
11 os.fchdir(fd)
Python 3
243
Change the current working directory to the directory represented by the file
descriptor fd.
12 os.fchmod(fd, mode)
Change the mode of the file given by fd to the numeric mode.
13 os.fchown(fd, uid, gid)
Change the owner and group id of the file given by fd to the numeric uid and
gid.
14 os.fdatasync(fd)
Force write of file with filedescriptor fd to disk.
15 os.fdopen(fd[, mode[, bufsize]])
Return an open file object connected to the file descriptor fd.
16 os.fpathconf(fd, name)
Return system configuration information relevant to an open file. name
specifies the configuration value to retrieve.
17 os.fstat(fd)
Return status for file descriptor fd, like stat().
18 os.fstatvfs(fd)
Return information about the filesystem containing the file associated with file
descriptor fd, like statvfs().
19 os.fsync(fd)
Force write of file with filedescriptor fd to disk.
20 os.ftruncate(fd, length)
Python 3
244
Truncate the file corresponding to file descriptor fd, so that it is at most length
bytes in size.
21 os.getcwd()
Return a string representing the current working directory.
22 os.getcwdu()
Return a Unicode object representing the current working directory.
23 os.isatty(fd)
Return True if the file descriptor fd is open and connected to a tty(-like) device,
else False.
24 os.lchflags(path, flags)
Set the flags of path to the numeric flags, like chflags(), but do not follow
symbolic links.
25 os.lchmod(path, mode)
Change the mode of path to the numeric mode.
26 os.lchown(path, uid, gid)
Change the owner and group id of path to the numeric uid and gid. This function
will not follow symbolic links.
27 os.link(src, dst)
Create a hard link pointing to src named dst.
28 os.listdir(path)
Return a list containing the names of the entries in the directory given by path.
29 os.lseek(fd, pos, how)
Python 3
245
Set the current position of file descriptor fd to position pos, modified by how.
30 os.lstat(path)
Like stat(), but do not follow symbolic links.
31 os.major(device)
Extract the device major number from a raw device number.
32 os.makedev(major, minor)
Compose a raw device number from the major and minor device numbers.
33 os.makedirs(path[, mode])
Recursive directory creation function.
34 os.minor(device)
Extract the device minor number from a raw device number .
35 os.mkdir(path[, mode])
Create a directory named path with numeric mode mode.
36 os.mkfifo(path[, mode])
Create a FIFO (a named pipe) named path with numeric mode mode. The
default mode is 0666 (octal).
37 os.mknod(filename[, mode=0600, device])
Create a filesystem node (file, device special file or named pipe) named
filename.
38 os.open(file, flags[, mode])
Python 3
246
Open the file file and set various flags according to flags and possibly its mode
according to mode.
39 os.openpty()
Open a new pseudo-terminal pair. Return a pair of file descriptors (master,
slave) for the pty and the tty, respectively.
40 os.pathconf(path, name)
Return system configuration information relevant to a named file.
41 os.pipe()
Create a pipe. Return a pair of file descriptors (r, w) usable for reading and
writing, respectively.
42 os.popen(command[, mode[, bufsize]])
Open a pipe to or from command.
43 os.read(fd, n)
Read at most n bytes from file descriptor fd. Return a string containing the
bytes read. If the end of the file referred to by fd has been reached, an empty
string is returned.
44 os.readlink(path)
Return a string representing the path to which the symbolic link points.
45 os.remove(path)
Remove the file path.
46 os.removedirs(path)
Remove directories recursively.
Python 3
247
47 os.rename(src, dst)
Rename the file or directory src to dst.
48 os.renames(old, new)
Recursive directory or file renaming function.
49 os.rmdir(path)
Remove the directory path
50 os.stat(path)
Perform a stat system call on the given path.
51 os.stat_float_times([newvalue])
Determine whether stat_result represents time stamps as float objects.
52 os.statvfs(path)
Perform a statvfs system call on the given path.
53 os.symlink(src, dst)
Create a symbolic link pointing to src named dst.
54 os.tcgetpgrp(fd)
Return the process group associated with the terminal given by fd (an open file
descriptor as returned by open()).
55 os.tcsetpgrp(fd, pg)
Set the process group associated with the terminal given by fd (an open file
descriptor as returned by open()) to pg.
56 os.tempnam([dir[, prefix]])
Python 3
248
Return a unique path name that is reasonable for creating a temporary file.
57 os.tmpfile()
Return a new file object opened in update mode (w+b).
58 os.tmpnam()
Return a unique path name that is reasonable for creating a temporary file.
59 os.ttyname(fd)
Return a string which specifies the terminal device associated with file
descriptor fd. If fd is not associated with a terminal device, an exception is
raised.
60 os.unlink(path)
Remove the file path.
61 os.utime(path, times)
Set the access and modified times of the file specified by path.
62 os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])
Generate the file names in a directory tree by walking the tree either top-down
or bottom-up.
63 os.write(fd, str)
Write the string str to file descriptor fd. Return the number of bytes actually
written.
Let us go through the methods brieflyos.access() Method
Description
Python 3
249
The method access() uses the real uid/gid to test for access to path. Most operations will
use the effective uid/gid, therefore this routine can be used in a suid/sgid environment to
test if the invoking user has the specified access to path.It returns True if access is allowed,
False if not.
Syntax
Following is the syntax for access() methodos.access(path, mode)
Parameters
 path - This is the path which would be tested for existence or any access.
 mode - This should be F_OK to test the existence of path, or it can be the inclusive
OR of one or more of R_OK, W_OK, and X_OK to test permissions.
o os.F_OK: Value to pass as the mode parameter of access() to test the existence
of path.
o os.R_OK: Value to include in the mode parameter of access() to test the
readability of path.
o os.W_OK: Value to include in the mode parameter of access() to test the
writability of path.
o os.X_OK: Value to include in the mode parameter of access() to determine if
path can be executed.
Return Value
This method returns True if access is allowed, False if not.
Example
The following example shows the usage of access() method.
#!/usr/bin/python3
import os, sys
# Assuming /tmp/foo.txt exists and has read/write permissions.
ret = os.access("/tmp/foo.txt", os.F_OK)
print ("F_OK - return value %s"% ret)
ret = os.access("/tmp/foo.txt", os.R_OK)
print ("R_OK - return value %s"% ret)
Python 3
250
ret = os.access("/tmp/foo.txt", os.W_OK)
print ("W_OK - return value %s"% ret)
ret = os.access("/tmp/foo.txt", os.X_OK)
print ("X_OK - return value %s"% ret)
When we run the above program, it produces the following resultF_OK - return value True
R_OK - return value True
W_OK - return value True
X_OK - return value False
os.chdir() Method
Description
The method chdir() changes the current working directory to the given path.It returns
None in all the cases.
Syntax
Following is the syntax for chdir() methodos.chdir(path)
Parameters
path - This is complete path of the directory to be changed to a new location.
Return Value
This method does not return any value. It throws FileNotFoundError if the specified path
is not found.
Example
The following example shows the usage of chdir() method.
#!/usr/bin/python3
import os
path = "d:\\python3" #change path for linux
# Now change the directory
os.chdir( path )
# Check current working directory.
Python 3
251
retval = os.getcwd()
print ("Directory changed successfully %s" % retval)
When we run the above program, it produces the following resultDirectory changed successfully d:\python3
os.chflags() Method
Description
The method chflags() sets the flags of path to the numeric flags. The flags may take a
combination (bitwise OR) of the various values described below.
Note: This method is available Python version 2.6 onwards. Most of the flags can be
changed by super-user only.
Syntax
Following is the syntax for chflags() methodos.chflags(path, flags)
Parameters
 path - This is a complete path of the directory to be changed to a new location.
 flags - The flags specified are formed by OR'ing the following valueso os.UF_NODUMP: Do not dump the file.
o os.UF_IMMUTABLE: The file may not be changed.
o os.UF_APPEND: The file may only be appended to.
o os.UF_NOUNLINK: The file may not be renamed or deleted.
o os.UF_OPAQUE: The directory is opaque when viewed through a union stack.
o os.SF_ARCHIVED: The file may be archived.
o os.SF_IMMUTABLE: The file may not be changed.
o os.SF_APPEND: The file may only be appended to.
o os.SF_NOUNLINK: The file may not be renamed or deleted.
o os.SF_SNAPSHOT: The file is a snapshot file.
Return Value
This method does not return any value.
Example
Python 3
252
The following example shows the usage of chflags() method.
#!/usr/bin/python3
import os
path = "/tmp/foo.txt"
# Set a flag so that file may not be renamed or deleted.
flags = os.SF_NOUNLINK
retval = os.chflags( path, flags)
print ("Return Value: %s" % retval)
When we run the above program, it produces the following resultReturn Value : None
os.chmod() Method
Description
The method chmod() changes the mode of path to the passed numeric mode. The mode
may take one of the following values or bitwise ORed combinations of them-
 stat.S_ISUID: Set user ID on execution.
 stat.S_ISGID: Set group ID on execution.
 stat.S_ENFMT: Record locking enforced.
 stat.S_ISVTX: Save text image after execution.
 stat.S_IREAD: Read by owner.
 stat.S_IWRITE: Write by owner.
 stat.S_IEXEC: Execute by owner.
 stat.S_IRWXU: Read, write, and execute by owner.
 stat.S_IRUSR: Read by owner.
 stat.S_IWUSR: Write by owner.
 stat.S_IXUSR: Execute by owner.
 stat.S_IRWXG: Read, write, and execute by group.
 stat.S_IRGRP: Read by group.
 stat.S_IWGRP: Write by group.
Python 3
253
 stat.S_IXGRP: Execute by group.
 stat.S_IRWXO: Read, write, and execute by others.
 stat.S_IROTH: Read by others.
 stat.S_IWOTH: Write by others.
 stat.S_IXOTH: Execute by others.
Syntax
Following is the syntax for chmod() methodos.chmod(path, mode)
Parameters
 path - This is the path for which mode would be set.
 mode - This may take one of the above mentioned values or bitwise ORed
combinations of them.
Return Value
This method does not return any value.
Note : Although Windows supports chmod(), you can only set the file’s read-only flag with
it (via the stat.S_IWRITE and stat.S_IREAD constants or a corresponding integer value).
All other bits are ignored.
Example
The following example shows the usage of chmod() method-
#!/usr/bin/python3
import os, sys, stat
# Assuming /tmp/foo.txt exists, Set a file execute by the group.
os.chmod("/tmp/foo.txt", stat.S_IXGRP)
# Set a file write by others.
os.chmod("/tmp/foo.txt", stat.S_IWOTH)
print ("Changed mode successfully!!")
Python 3
254
When we run the above program, it produces the following resultChanged mode successfully!!
os.chown() Method
Description
The method chown() changes the owner and group id of path to the numeric uid and gid.
To leave one of the ids unchanged, set it to -1.To set ownership, you would need super
user privilege..
Syntax
Following is the syntax for chown() methodos.chown(path, uid, gid)
Parameters
 path - This is the path for which owner id and group id need to be setup.
 uid - This is Owner ID to be set for the file.
 gid - This is Group ID to be set for the file.
Return Value
This method does not return any value.
Example
The following example shows the usage of chown() method.
#!/usr/bin/python3
import os, sys
# Assuming /tmp/foo.txt exists.
# To set owner ID 100 following has to be done.
os.chown("/tmp/foo.txt", 100, -1)
print ("Changed ownership successfully!!")
When we run the above program, it produces the following resultChanged ownership successfully!!
Python 3
255
os.chroot() Method
Description
The method chroot() changes the root directory of the current process to the given path.
Available on Unix like systems only. To use this method, you would need super user
privilege.
Syntax
Following is the syntax for chroot() methodos.chroot(path)
Parameters
path - This is the path which would be set as root for the current process.
Return Value
This method does not return any value.
Example
The following example shows the usage of chroot() method.
#!/usr/bin/python3
import os, sys
# To set the current root path to /tmp/user
os.chroot("/tmp/usr")
print ("Changed root path successfully!!")
When we run the above program, it produces the following resultChanged root path successfully!!
Python os.close() Method
Description
The method close() closes the associated with file descriptor fd.
Syntax
Following is the syntax for close() methodos.close(fd)
Python 3
256
Parameters
fd - This is the file descriptor of the file.
Return Value
This method does not return any value.
Note: This function is intended for low-level I/O and must be applied to a file descriptor
as returned by os.open() or pipe().
Example
The following example shows the usage of close() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
line="this is test"
# string needs to be converted byte object
b=str.encode(line)
os.write(fd, b)
# Close opened file
os.close( fd )
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultClosed the file successfully!!
os.closerange() Method
Description
The method closerange() closes all file descriptors from fd_low (inclusive) to fd_high
(exclusive), ignoring errors.This method is introduced in Python version 2.6.
Syntax
Following is the syntax for closerange() methodos.closerange(fd_low, fd_high)
Parameters
Python 3
257
 fd_low - This is the Lowest file descriptor to be closed.
 fd_high - This is the Highest file descriptor to be closed.
This function is equivalent tofor fd in xrange(fd_low, fd_high):
 try:
 os.close(fd)
 except OSError:
 pass
Return Value
This method does not return any value.
Example
The following example shows the usage of closerange() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
line="this is test"
# string needs to be converted byte object
b=str.encode(line)
os.write(fd, b)
# Close a single opened file
os.closerange( fd, fd)
print ("Closed all the files successfully!!")
This would create given file foo.txt and then write given content in that file. This will
produce the following resultClosed all the files successfully!
Python 3
258
os.dup() Method
Description
The method dup() returns a duplicate of file descriptor fd which can be used in place of
original descriptor.
Syntax
Following is the syntax for dup() methodos.dup(fd)
Parameters
fd - This is the original file descriptor.
Return Value
This method returns a duplicate of file descriptor.
Example
The following example shows the usage of dup() method-
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Get one duplicate file descriptor
d_fd = os.dup( fd )
# Write one string using duplicate fd
line="this is test"
# string needs to be converted byte object
b=str.encode(line)
os.write(d_fd, b)
# Close a single opened file
os.closerange( fd, d_fd)
Python 3
259
print "Closed all the files successfully!!"
When we run the above program, it produces the following resultClosed all the files successfully!!
os.dup2() Method
Description
The method dup2() duplicates file descriptor fd to fd2, closing the latter first if necessary.
Note: New file description would be assigned only when it is available. In the following
example given below, 1000 would be assigned as a duplicate fd in case when 1000 is
available.
Syntax
Following is the syntax for dup2() methodos.dup2(fd, fd2)
Parameters
 fd - This is File descriptor to be duplicated.
 fd2 - This is Duplicate file descriptor.
Return Value
This method returns a duplicate of file descriptor.
Example
The following example shows the usage of dup2() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string using duplicate fd
line="this is test"
# string needs to be converted byte object
b=str.encode(line)
Python 3
260
os.write(fd, b)
# Now duplicate this file descriptor as 1000
fd2 = 1000
os.dup2(fd, fd2);
# Now read this file from the beginning using fd2.
os.lseek(fd2, 0, 0)
line = os.read(fd2, 100)
str=line.decode()
print ("Read String is : ", str)
# Close opened file
os.closerange( fd,fd2 )
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultRead String is : This is test
Closed the file successfully!!
os.fchdir() Method
Description
The method fchdir() change the current working directory to the directory represented
by the file descriptor fd. The descriptor must refer to an opened directory, not an open
file.
Syntax
Following is the syntax for fchdir() methodos.fchdir(fd)
Parameters
fd - This is Directory descriptor.
Return Value
This method does not return any value.
Python 3
261
Example
The following example shows the usage of fchdir() method.
#!/usr/bin/python3
import os, sys
# First go to the "/var/www/html" directory
os.chdir("/var/www/html" )
# Print current working directory
print ("Current working dir : %s" % os.getcwd())
# Now open a directory "/tmp"
fd = os.open( "/tmp", os.O_RDONLY )
# Use os.fchdir() method to change the dir
os.fchdir(fd)
# Print current working directory
print ("Current working dir : %s" % os.getcwd())
# Close opened directory.
os.close( fd )
When we run the above program, it produces the following resultCurrent working dir : /var/www/html
Current working dir : /tmp
os.fchmod() Method
Description
The method fchmod() changes the mode of the file given by fd to the numeric mode. The
mode may take one of the following values or bitwise ORed combinations of themNote: This method is available Python 2.6 onwards.
 stat.S_ISUID: Set user ID on execution.
 stat.S_ISGID: Set group ID on execution.
 stat.S_ENFMT: Record locking enforced.
Python 3
262
 stat.S_ISVTX: Save text image after execution.
 stat.S_IREAD: Read by owner.
 stat.S_IWRITE: Write by owner.
 stat.S_IEXEC: Execute by owner.
 stat.S_IRWXU: Read, write, and execute by owner.
 stat.S_IRUSR: Read by owner.
 stat.S_IWUSR: Write by owner.
 stat.S_IXUSR: Execute by owner.
 stat.S_IRWXG: Read, write, and execute by group.
 stat.S_IRGRP: Read by group.
 stat.S_IWGRP: Write by group.
 stat.S_IXGRP: Execute by group.
 stat.S_IRWXO: Read, write, and execute by others.
 stat.S_IROTH: Read by others.
 stat.S_IWOTH: Write by others.
 stat.S_IXOTH: Execute by others.
Syntax
Following is the syntax for fchmod() methodos.fchmod(fd, mode)
Parameters
 fd - This is the file descriptor for which mode would be set.
 mode - This may take one of the above mentioned values or bitwise ORed
combinations of them.
Return Value
This method does not return any value. Available on Unix like operating systems only.
Example
Python 3
263
The following example shows the usage of fchmod() method-
#!/usr/bin/python3
import os, sys, stat
# Now open a file "/tmp/foo.txt"
fd = os.open( "/tmp", os.O_RDONLY )
# Set a file execute by the group.
os.fchmod( fd, stat.S_IXGRP)
# Set a file write by others.
os.fchmod(fd, stat.S_IWOTH)
print ("Changed mode successfully!!")
# Close opened file.
os.close( fd )
When we run the above program, it produces the following resultChanged mode successfully!!
os.fchown() Method
Description
The method fchown() changes the owner and group id of the file given by fd to the numeric
uid and gid. To leave one of the ids unchanged, set it to -1.
Note:This method is available Python 2.6 onwards.
Syntax
Following is the syntax for fchown() methodos.fchown(fd, uid, gid)
Parameters
 fd - This is the file descriptor for which owner id and group id need to be set up.
 uid - This is Owner ID to be set for the file.
Python 3
264
 gid - This is Group ID to be set for the file.
Return Value
This method does not return any value. Available in Unix like operating systems only.
Example
The following example shows the usage of fchown() method.
#!/usr/bin/python3
import os, sys, stat
# Now open a file "/tmp/foo.txt"
fd = os.open( "/tmp", os.O_RDONLY )
# Set the user Id to 100 for this file.
os.fchown( fd, 100, -1)
# Set the group Id to 50 for this file.
os.fchown( fd, -1, 50)
print ("Changed ownership successfully!!")
# Close opened file.
os.close( fd )
When we run the above program, it produces the following resultChanged ownership successfully!!
os.fdatasync() Method
Description
The method fdatasync() forces write of file with filedescriptor fd to disk. This does not
force update of metadata. If you want to flush your buffer then you can use this method.
Syntax
Following is the syntax for fdatasync() methodos.fdatasync(fd)
Parameters
fd - This is the file descriptor for which data to be written.
Python 3
265
Return Value
This method does not return any value.
Example
The following example shows the usage of fdatasync() method-
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
line="this is test"
# string needs to be converted byte object
b=str.encode(line)
os.write(fd, b)
# Now you can use fdatasync() method.
# Infact here you would not be able to see its effect.
os.fdatasync(fd)
# Now read this file from the beginning.
os.lseek(fd, 0, 0)
str = os.read(fd, 100)
line = os.read(fd2, 100)
str=line.decode()
print ("Read String is : ", str)
# Close opened file
os.close( fd )
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultRead String is : This is test
Closed the file successfully!!
Python 3
266
os.fdopen() Method
Description
The method fdopen() returns an open file object connected to the file descriptor fd. Then
you can perform all the defined functions on file object.
Syntax
Following is the syntax for fdopen() methodos.fdopen(fd, [, mode[, bufsize]]);
Parameters
 fd - This is the file descriptor for which a file object is to be returned.
 mode - This optional argument is a string indicating how the file is to be opened.
The most commonly-used values of mode are 'r' for reading, 'w' for writing
(truncating the file if it already exists), and 'a' for appending.
 bufsize - This optional argument specifies the file's desired buffer size: 0 means
unbuffered, 1 means line buffered, any other positive value means use a buffer of
(approximately) that size.
Return Value
This method returns an open file object connected to the file descriptor.
Example
The following example shows the usage of fdopen() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Now get a file object for the above file.
fo = os.fdopen(fd, "w+")
# Tell the current position
print ("Current I/O pointer position :%d" % fo.tell())
# Write one string
fo.write( "Python is a great language.\nYeah its great!!\n");
Python 3
267
# Now read this file from the beginning.
os.lseek(fd, 0, 0)
str = os.read(fd, 100)
print ("Read String is : ", str)
# Tell the current position
print "Current I/O pointer position :%d" % fo.tell()
# Close opened file
fo.close()
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultCurrent I/O pointer position :0
Read String is : This is testPython is a great language.
Yeah its great!!
Current I/O pointer position :45
Closed the file successfully!!
os.fpathconf() Method
Description
The method fpathconf() returns system configuration information relevant to an open
file.This variable is very similar to unix system call fpathconf() and accept the similar
arguments.
Syntax
Following is the syntax for fpathconf() methodos.fpathconf(fd, name)
Parameters
 fd - This is the file descriptor for which system configuration information is to be
returned.
 name - This specifies the configuration value to retrieve; it may be a string, which
is the name of a defined system value; these names are specified in a number of 
Python 3
268
standards (POSIX.1, Unix 95, Unix 98, and others). The names known to the host
operating system are given in the os.pathconf_names dictionary.
Return Value
This method returns system configuration information relevant to an open file.
Example
The following example shows the usage of fpathconf() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
print ("%s" % os.pathconf_names)
# Now get maximum number of links to the file.
no = os.fpathconf(fd, 'PC_LINK_MAX')
print ("Maximum number of links to the file. :%d" % no)
# Now get maximum length of a filename
no = os.fpathconf(fd, 'PC_NAME_MAX')
print ("Maximum length of a filename :%d" % no)
# Close opened file
os.close( fd)
print ("Closed the file successfully!!")
When we run the above program, it produces the following result-
{'PC_MAX_INPUT': 2, 'PC_VDISABLE': 8, 'PC_SYNC_IO': 9,
'PC_SOCK_MAXBUF': 12, 'PC_NAME_MAX': 3, 'PC_MAX_CANON': 1,
'PC_PRIO_IO': 11, 'PC_CHOWN_RESTRICTED': 6, 'PC_ASYNC_IO': 10,
'PC_NO_TRUNC': 7, 'PC_FILESIZEBITS': 13, 'PC_LINK_MAX': 0,
'PC_PIPE_BUF': 5, 'PC_PATH_MAX': 4}
Maximum number of links to the file. :127
Maximum length of a filename :255
Closed the file successfully!!
Python 3
269
os.fstat() Method
Description
The method fstat() returns information about a file associated with the fd. Here is the
structure returned by fstat method-
 st_dev: ID of device containing file
 st_ino: inode number
 st_mode: protection
 st_nlink: number of hard links
 st_uid: user ID of owner
 st_gid: group ID of owner
 st_rdev: device ID (if special file)
 st_size: total size, in bytes
 st_blksize: blocksize for filesystem I/O
 st_blocks: number of blocks allocated
 st_atime: time of last access
 st_mtime: time of last modification
 st_ctime: time of last status change
Syntax
Following is the syntax for fstat() methodos.fstat(fd)
Parameters
fd - This is the file descriptor for which system information is to be returned.
Return Value
This method returns information about a file associated with the fd.
Example
The following example shows the usage of chdir() method.
#!/usr/bin/python3
Python 3
270
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Now get the touple
info = os.fstat(fd)
print ("File Info :", info)
# Now get uid of the file
print ("UID of the file :%d" % info.st_uid)
# Now get gid of the file
print ("GID of the file :%d" % info.st_gid)
# Close opened file
os.close( fd)
When we run the above program, it produces the following resultFile Info : os.stat_result(st_mode=33206, st_ino=2533274790483933,
st_dev=1017554828, st_nlink=1, st_uid=0, st_gid=0, st_size=61,
st_atime=1455562034, st_mtime=1455561637, st_ctime=1455561164)
UID of the file :0
GID of the file :0
os.fstatvfs() Method
Description
The method fstatvfs() returns information about the file system containing the file
associated with file descriptor fd. This returns the following structure-
 f_bsize: file system block size
 f_frsize: fragment size
 f_blocks: size of fs in f_frsize units
 f_bfree: free blocks
 f_bavail: free blocks for non-root
 f_files: inodes
Python 3
271
 f_ffree: free inodes
 f_favail: free inodes for non-root
 f_fsid: file system ID
 f_flag: mount flags
 f_namemax: maximum filename length
Syntax
Following is the syntax for fstatvfs() methodos.fstatvfs(fd)
Parameters
fd - This is the file descriptor for which system information is to be returned.
Return Value
This method returns information about the file system containing the file associated.
Example
The following example shows the usage of fstatvfs() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Now get the touple
info = os.fstatvfs(fd)
print ("File Info :", info)
# Now get maximum filename length
print ("Maximum filename length :%d" % info.f_namemax:)
# Now get free blocks
Python 3
272
print ("Free blocks :%d" % info.f_bfree)
# Close opened file
os.close( fd)
When we run the above program, it produces the following resultFile Info : (4096, 4096, 2621440L, 1113266L, 1113266L,
 8929602L, 8764252L, 8764252L, 0, 255)
Maximum filename length :255
Free blocks :1113266
os.fsync() Method
Description
The method fsync() forces write of file with file descriptor fd to disk. If you're starting with
a Python file object f, first do f.flush(), and then do os.fsync(f.fileno()), to ensure that all
internal buffers associated with f are written to disk.
Syntax
Following is the syntax for fsync() methodos.fsync(fd)
Parameters
fd - This is the file descriptor for buffer sync is required.
Return Value
This method does not return any value.
Example
The following example shows the usage of fsync() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
Python 3
273
line="this is test"
b=line.encode()
os.write(fd, b)
# Now you can use fsync() method.
# Infact here you would not be able to see its effect.
os.fsync(fd)
# Now read this file from the beginning
os.lseek(fd, 0, 0)
line = os.read(fd, 100)
b=line.decode()
print ("Read String is : ", b)
# Close opened file
os.close( fd )
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultRead String is : this is test
Closed the file successfully!!
os.ftruncate() Method
Description
The method ftruncate() truncates the file corresponding to file descriptor fd, so that it is
at most length bytes in size.
Syntax
Following is the syntax for ftruncate() methodos.ftruncate(fd, length)
Parameters
 fd - This is the file descriptor, which needs to be truncated.
 length - This is the length of the file where file needs to be truncated.
Return Value
This method does not return any value. Available on Unix like systems.
Example
Python 3
274
The following example shows the usage of ftruncate() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
os.write(fd, "This is test - This is test")
# Now you can use ftruncate() method.
os.ftruncate(fd, 10)
# Now read this file from the beginning.
os.lseek(fd, 0, 0)
str = os.read(fd, 100)
print ("Read String is : ", str)
# Close opened file
os.close( fd )
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultRead String is : This is te
Closed the file successfully!!
os.getcwd() Method
Description
The method getcwd() returns current working directory of a process.
Syntax
Following is the syntax for getcwd() methodos.ggetcwd(path)
Parameters
NA
Python 3
275
Return Value
This method returns the current working directory of a process.
Example
The following example shows the usage of getcwd() method-
#!/usr/bin/python3
import os, sys
# First go to the "/var/www/html" directory
os.chdir("/var/www/html" )
# Print current working directory
print ("Current working dir : %s" % os.getcwd())
# Now open a directory "/tmp"
fd = os.open( "/tmp", os.O_RDONLY )
# Use os.fchdir() method to change the dir
os.fchdir(fd)
# Print current working directory
print ("Current working dir : %s" % os.getcwd())
# Close opened directory.
os.close( fd )
When we run the above program, it produces the following resultCurrent working dir : /var/www/html
Current working dir : /tmp
os.getcwdu() Method
Description
The method getcwdu() returns a unicode object representing the current working
directory.
Syntax
Following is the syntax for getcwdu() methodos.getcwdu()
Python 3
276
Parameters
NA
Return Value
This method returns a unicode object representing the current working directory.
Example
The following example shows the usage of getcwdu() method.
#!/usr/bin/python3
import os, sys
# First go to the "/var/www/html" directory
os.chdir("/var/www/html" )
# Print current working directory
print ("Current working dir : %s" % os.getcwdu())
# Now open a directory "/tmp"
fd = os.open( "/tmp", os.O_RDONLY )
# Use os.fchdir() method to change the dir
os.fchdir(fd)
# Print current working directory
print ("Current working dir : %s" % os.getcwdu())
# Close opened directory.
os.close( fd )
When we run the above program, it produces the following resultCurrent working dir : /var/www/html
Current working dir : /tmp
os.isatty() Method
Description
Python 3
277
The method isatty()returns True if the file descriptor fd is open and connected to a tty(-
like) device, else False.
Syntax
Following is the syntax for isatty() methodos.isatty( fd )
Parameters
fd - This is the file descriptor for which association needs to be checked.
Return Value
This method returns True if the file descriptor fd is open and connected to a tty(-like)
device, else False.
Example
The following example shows the usage of isatty() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
line="This is test"
b=line.encode()
os.write(fd, b)
# Now use isatty() to check the file.
ret = os.isatty(fd)
print ("Returned value is: ", ret)
# Close opened file
os.close( fd )
When we run the above program, it produces the following resultReturned value is: False
Python 3
278
os.lchflags() Method
Description
The method lchflags() sets the flags of path to the numeric flags. This method does not
follow symbolic links unlike chflags() method. As of Python 3.3, this is equivalent to
os.chflags(path, flags, follow_symlinks=False).
Here, flags may take a combination (bitwise OR) of the following values (as defined in the
stat module):
 UF_NODUMP: Do not dump the file.
 UF_IMMUTABLE: The file may not be changed.
 UF_APPEND: The file may only be appended to.
 UF_NOUNLINK: The file may not be renamed or deleted.
 UF_OPAQUE: The directory is opaque when viewed through a union stack.
 SF_ARCHIVED: The file may be archived.
 SF_IMMUTABLE: The file may not be changed.
 SF_APPEND: The file may only be appended to.
 SF_NOUNLINK: The file may not be renamed or deleted.
 SF_SNAPSHOT: The file is a snapshot file.
Note: This method has been introduced in Python 2.6
Syntax
Following is the syntax for lchflags() methodos.lchflags(path, flags)
Parameters
 path - This is the file path for which flags to be set.
 flags - This could be a combination (bitwise OR) of the above defined flags values.
Return Value
This method does not return any value. Available on Unix like systems.
Example
The following example shows the usage of lchflags() method.
Python 3
279
#!/usr/bin/python3
import os, sys
# Open a file
path = "/var/www/html/foo.txt"
fd = os.open( path, os.O_RDWR|os.O_CREAT )
# Close opened file
os.close( fd )
# Now change the file flag.
ret = os.lchflags(path, os.UF_IMMUTABLE )
print ("Changed file flag successfully!!")
When we run the above program, it produces the following resultChanged file flag successfully!!
os.lchown() Method
Description
The method lchown() changes the owner and group id of path to the numeric uid and gid.
This function will not follow symbolic links. To leave one of the ids unchanged, set it to -
1. As of Python 3.3, this is equivalent to os.chown(path, uid, gid, follow_symlinks=False).
Syntax
Following is the syntax for lchown() methodos.lchown(path, uid, gid)
Parameters
 path - This is the file path for which ownership to be set.
 uid - This is the Owner ID to be set for the file.
 gid - This is the Group ID to be set for the file.
Python 3
280
Return Value
This method does not return any value.
Example
The following example shows the usage of lchown() method.
#!/usr/bin/python3
import os, sys
# Open a file
path = "/var/www/html/foo.txt"
fd = os.open( path, os.O_RDWR|os.O_CREAT )
# Close opened file
os.close( fd )
# Now change the file ownership.
# Set a file owner ID
os.lchown( path, 500, -1)
# Set a file group ID
os.lchown( path, -1, 500)
print ("Changed ownership successfully!!")
When we run above program, it produces following resultChanged ownership successfully!!
os.link() Method
Description
The method link() creates a hard link pointing to src named dst. This method is very useful
to create a copy of existing file.
Syntax
Following is the syntax for link() methodos.link(src, dst)
Python 3
281
Parameters
 src - This is the source file path for which hard link would be created.
 dest - This is the target file path where hard link would be created.
Return Value
This method does not return any value. Available on Unix, Windows.
Example
The following example shows the usage of link() method.
#!/usr/bin/python3
import os, sys
# Open a file
path = "d:\\python3\\foo.txt"
fd = os.open( path, os.O_RDWR|os.O_CREAT )
# Close opened file
os.close( fd )
# Now create another copy of the above file.
dst = "d:\\tmp\\foo.txt"
os.link( path, dst)
print ("Created hard link successfully!!")
When we run the above program, it produces the following resultCreated hard link successfully!!
os.listdir() Method
Description
The method listdir() returns a list containing the names of the entries in the directory
given by path. The list is in arbitrary order. It does not include the special entries '.' and
'..' even if they are present in the directory.
path may be either of type str or of type bytes. If path is of type bytes, the filenames
returned will also be of type bytes; in all other circumstances, they will be of type str.
Syntax
Python 3
282
Following is the syntax for listdir() methodos.listdir(path)
Parameters
path - This is the directory, which needs to be explored.
Return Value
This method returns a list containing the names of the entries in the directory given by
path.
Example
The following example shows the usage of listdir() method.
#!/usr/bin/python3
import os, sys
# Open a file
path = "d:\\tmp\\"
dirs = os.listdir( path )
# This would print all the files and directories
for file in dirs:
 print (file)
When we run the above program, it produces the following resultApplicationdocs.docx
test.java
book.zip
foo.txt
Java Multiple Inheritance.htm
Java Multiple Inheritance_files
java.ppt
ParallelPortViewer
os.lseek() Method
Description
The method lseek() sets the current position of file descriptor fd to the given position pos,
modified by how.
Python 3
283
Syntax
Following is the syntax for lseek() methodos.lseek(fd, pos, how)
Parameters
 fd - This is the file descriptor, which needs to be processed.
 pos - This is the position in the file with respect to given parameter how. You give
os.SEEK_SET or 0 to set the position relative to the beginning of the file,
os.SEEK_CUR or 1 to set it relative to the current position; os.SEEK_END or 2 to
set it relative to the end of the file.
 how - This is the reference point with-in the file. os.SEEK_SET or 0 means
beginning of the file, os.SEEK_CUR or 1 means the current position and
os.SEEK_END or 2 means end of the file.
Defined pos constants
 os.SEEK_SET - 0
 os.SEEK_CUR - 1
 os.SEEK_END - 2
Return Value
This method does not return any value.
Example
The following example shows the usage of lseek() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
line="This is test"
b=line.encode()
os.write(fd, b)
# Now you can use fsync() method.
# Infact here you would not be able to see its effect.
os.fsync(fd)
# Now read this file from the beginning
os.lseek(fd, 0, 0)
Python 3
284
line = os.read(fd, 100)
print ("Read String is : ", line.decode())
# Close opened file
os.close( fd )
print "Closed the file successfully!!"
When we run the above program, it produces the following resultRead String is : This is test
Closed the file successfully!!
os.lstat() Method
Description
The method lstat() is very similar to fstat() and returns a stat_result object containing the
information about a file, but do not follow symbolic links. This is an alias for fstat() on
platforms that do not support symbolic links, such as Windows.
Here is the structure returned by lstat method-
 st_dev: ID of device containing file
 st_ino: inode number
 st_mode: protection
 st_nlink: number of hard links
 st_uid: user ID of owner
 st_gid: group ID of owner
 st_rdev: device ID (if special file)
 st_size: total size, in bytes
 st_blksize: blocksize for filesystem I/O
 st_blocks: number of blocks allocated
 st_atime: time of last access
 st_mtime: time of last modification
 st_ctime: time of last status change
Python 3
285
Syntax
Following is the syntax for lstat() method:
os.lstat(path)
Parameters
path - This is the file for which information would be returned.
Return Value
This method returns the information about a file.
Example
The following example shows the usage of lstat() method.
#!/usr/bin/python3
import os, sys
# Open a file
path = "d:\\python3\\foo.txt"
fd = os.open( path, os.O_RDWR|os.O_CREAT )
# Close opened file
os.close( fd )
# Now get the touple
info = os.lstat(path)
print ("File Info :", info)
# Now get uid of the file
print ("UID of the file :%d" % info.st_uid)
# Now get gid of the file
print ("GID of the file :%d" % info.st_gid)
When we run the above program, it produces the following resultFile Info : os.stat_result(st_mode=33206, st_ino=281474976797706,
st_dev=1017554828, st_nlink=2, st_uid=0, st_gid=0, st_size=13,
st_atime=1455597777, st_mtime=1438077266, st_ctime=1455560006)
UID of the file :0
GID of the file :0
Python 3
286
os.major() Method
Description
The method major() extracts the device major number from a raw device number (usually
the st_dev or st_rdev field from stat).
Syntax
Following is the syntax for major() methodos.major(device)
Parameters
device - This is a raw device number (usually the st_dev or st_rdev field from stat).
Return Value
This method returns the device major number.
Example
The following example shows the usage of major() method.
#!/usr/bin/python3
import os, sys
path = "/var/www/html/foo.txt"
# Now get the touple
info = os.lstat(path)
# Get major and minor device number
major_dnum = os.major(info.st_dev)
minor_dnum = os.minor(info.st_dev)
print ("Major Device Number :", major_dnum)
print ("Minor Device Number :", minor_dnum)
When we run the above program, it produces the following resultMajor Device Number : 0
Minor Device Number : 103
os.makedev() Method
Description
Python 3
287
The method makedev() composes a raw device number from the major and minor device
numbers.
Syntax
Following is the syntax for makedev() methodos.makedev(major, minor)
Parameters
 major - This is Major device number.
 minor - This is Minor device number.
Return Value
This method returns the device number.
Example
The following example shows the usage of makedev() method.
#!/usr/bin/python3
import os, sys
path = "/var/www/html/foo.txt"
# Now get the touple
info = os.lstat(path)
# Get major and minor device number
major_dnum = os.major(info.st_dev)
minor_dnum = os.minor(info.st_dev)
print ("Major Device Number :", major_dnum)
print ("Minor Device Number :", minor_dnum)
# Make a device number
dev_num = os.makedev(major_dnum, minor_dnum)
print ("Device Number :", dev_num)
When we run the above program, it produces the following resultMajor Device Number : 0
Minor Device Number : 103
Device Number : 103
Python 3
288
os.makedirs() Method
Description
The method makedirs() is recursive directory creation function. Like mkdir(), but makes
all intermediate-level directories needed to contain the leaf directory.
The default mode is 0o777 (octal). On some systems, mode is ignored. Where it is used,
the current umask value is first masked out.
If exist_ok is False (the default), an OSError is raised if the target directory already exists.
Syntax
Following is the syntax for makedirs() methodos.makedirs(path[, mode])
Parameters
 path - This is the path, which needs to be created recursively.
 mode - This is the Mode of the directories to be given.
Return Value
This method does not return any value.
Example
The following example shows the usage of makedirs() method.
#!/usr/bin/python3
import os, sys
# Path to be created
path = "d:/tmp/home/monthly/daily"
os.makedirs( path, 493 ) #decimal equivalent of 0755 used on Windows
print ("Path is created")
When we run the above program, it produces the following resultPath is created
os.minor() Method
Description
The method minor() extracts the device minor number from a raw device number (usually
the st_dev or st_rdev field from stat).
Python 3
289
Syntax
Following is the syntax for minor() methodos.minor(device)
Parameters
device - This is a raw device number (usually the st_dev or st_rdev field from stat).
Return Value
This method returns the device minor number.
Example
The following example shows the usage of minor() method.
#!/usr/bin/python3
import os, sys
path = "/var/www/html/foo.txt"
# Now get the touple
info = os.lstat(path)
# Get major and minor device number
major_dnum = os.major(info.st_dev)
minor_dnum = os.minor(info.st_dev)
print ("Major Device Number :", major_dnum)
print ("Minor Device Number :", minor_dnum)
When we run the above program, it produces the following resultMajor Device Number : 0
Minor Device Number : 103
os.mkdir() Method
Description
The method mkdir() create a directory named path with numeric mode mode. The default
mode is 0777 (octal). On some systems, mode is ignored. Where it is used, the current
umask value is first masked out.
Python 3
290
Syntax
Following is the syntax for mkdir() methodos.mkdir(path[, mode])
Parameters
 path - This is the path, which needs to be created.
 mode - This is the mode of the directories to be given.
Return Value
This method does not return any value.
Example
The following example shows the usage of mkdir() method.
#!/usr/bin/python3
import os, sys
# Path to be created
path = "/tmp/home/monthly/daily/hourly"
os.mkdir( path, 0755 );
print "Path is created"
When we run the above program, it produces the following resultPath is created
os.mkfifo() Method
Description
The method mkfifo() create a FIFO named path with numeric mode. The default mode is
0666 (octal).The current umask value is first masked out.
FIFOs are pipes that can be accessed like regular files. FIFOs exist until they are deleted
Syntax
Following is the syntax for mkfifo() methodos.mkfifo(path[, mode])
Python 3
291
Parameters
 path - This is the path, which needs to be created.
 mode - This is the mode of the named path to be given.
Return Value
This method does not return any value.
Example
The following example shows the usage of mkfifo() method.
# !/usr/bin/python3
import os, sys
# Path to be created
path = "/tmp/hourly"
os.mkfifo( path, 0644 )
print ("Path is created")
When we run the above program, it produces the following resultPath is created
os.mknod() Method
Description
The method mknod() creates a filesystem node (file, device special file or named pipe)
named filename.
Syntax
Following is the syntax for mknod() methodos.mknod(filename[, mode=0600[, device=0]])
Parameters
 filename - This is the filesystem node to be created.
 mode - The mode specifies both the permissions to use and the type of node to be
created combined (bitwise OR) with one of the values stat.S_IFREG, stat.S_IFCHR,
stat.S_IFBLK, and stat.S_IFIFO. They can be ORed base don requirement.
 device - This is the device special file created and its optional to provide.
Python 3
292
Return Value
This method does not return any value. Available on Unix like systems.
Example
The following example shows the usage of mknod() method.
# !/usr/bin/python3
import os
import stat
filename = '/tmp/tmpfile'
mode = 0600|stat.S_IRUSR
# filesystem node specified with different modes
os.mknod(filename, mode)
Let us compile and run the above program, this will create a simple file in /tmp directory
with a name tmpfile:
-rw-------. 1 root root 0 Apr 30 02:38 tmpfile
os.open() Method
Description
The method open() opens the file file and set various flags according to flags and possibly
its mode according to mode.The default mode is 0777 (octal), and the current umask value
is first masked out.
Syntax
Following is the syntax for open() method:
os.open(file, flags[, mode]);
Parameters
 file - File name to be opened.
 flags - The following constants are options for the flags. They can be combined
using the bitwise OR operator |. Some of them are not available on all platforms.
o os.O_RDONLY: open for reading only
o os.O_WRONLY: open for writing only
o os.O_RDWR : open for reading and writing
o os.O_NONBLOCK: do not block on open
Python 3
293
o os.O_APPEND: append on each write
o os.O_CREAT: create file if it does not exist
o os.O_TRUNC: truncate size to 0
o os.O_EXCL: error if create and file exists
o os.O_SHLOCK: atomically obtain a shared lock
o os.O_EXLOCK: atomically obtain an exclusive lock
o os.O_DIRECT: eliminate or reduce cache effects
o os.O_FSYNC : synchronous writes
o os.O_NOFOLLOW: do not follow symlinks
 mode - This work in similar way as it works for chmod() method.
Return Value
This method returns the file descriptor for the newly opened file.
Example
The following example shows the usage of open() method.
#!/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )
# Write one string
line="this is test"
# string needs to be converted byte object
b=str.encode(line)
os.write(fd, b)
# Close opened file
os.close( fd)
print ("Closed the file successfully!!")
This would create given file foo.txt and then would write given content in that file and
would produce the following resultClosed the file successfully!!
os.openpty() Method
Description
Python 3
294
The method openpty() opens a pseudo-terminal pair and returns a pair of file
descriptors(master,slave) for the pty & the tty respectively.
The new file descriptors are non-inheritable. For a (slightly) more portable approach, use
the pty module.
Syntax
Following is the syntax for openpty() methodos.openpty()
Parameters
NA
Return Value
This method returns a pair of file descriptors i.e., master and slave.
Example
The following example shows the usage of openpty() method.
# !/usr/bin/python3
import os
# master for pty, slave for tty
m,s = os.openpty()
print (m)
print (s)
# showing terminal name
s = os.ttyname(s)
print (m)
print( s)
When we run the above program, it produces the following result3
4
3
/dev/pty0
os.pathconf() Method
Description
Python 3
295
The method pathconf() returns system configuration information relevant to a named file.
Syntax
Following is the syntax for pathconf() methodos.pathconf(path, name)
Parameters
 path - This is the file path.
 name - This specifies the configuration value to retrieve; it may be a string which
is the name of a defined system value; these names are specified in a number of
standards (POSIX.1, Unix 95, Unix 98, and others). The names known to the host
operating system are given in the os.pathconf_names dictionary.
Return Value
This method returns system configuration information of a file. Available on Unix like
systems.
Example
The following example shows the usage of pathconf() method.
#!/usr/bin/python3
import os, sys
print ("%s" % os.pathconf_names)
# Retrieve maximum length of a filename
no = os.pathconf('a2.py', 'PC_NAME_MAX')
print ("Maximum length of a filename :%d" % no)
# Retrieve file size
no = os.pathconf('a2.py', 'PC_FILESIZEBITS')
print ("file size in bits :%d" % no)
When we run the above program, it produces the following result-
{'PC_MAX_INPUT': 2, 'PC_VDISABLE': 8, 'PC_SYNC_IO': 9,
'PC_SOCK_MAXBUF': 12, 'PC_NAME_MAX': 3, 'PC_MAX_CANON': 1,
'PC_PRIO_IO': 11, 'PC_CHOWN_RESTRICTED': 6, 'PC_ASYNC_IO': 10,
'PC_NO_TRUNC': 7, 'PC_FILESIZEBITS': 13, 'PC_LINK_MAX': 0,
'PC_PIPE_BUF': 5, 'PC_PATH_MAX': 4}
Maximum length of a filename :255
Python 3
296
file size in bits : 64
os.pipe() Method
Description
The method pipe() creates a pipe and returns a pair of file descriptors (r, w) usable for
reading and writing, respectively
Syntax
Following is the syntax for pipe() methodos.pipe()
Parameters
NA
Return Value
This method returns a pair of file descriptors.
Example
The following example shows the usage of pipe() method.
#!/usr/bin/python3
import os, sys
print ("The child will write text to a pipe and ")
print ("the parent will read the text written by child...")
# file descriptors r, w for reading and writing
r, w = os.pipe()
processid = os.fork()
if processid:
 # This is the parent process
 # Closes file descriptor w
 os.close(w)
 r = os.fdopen(r)
 print ("Parent reading")
Python 3
297
 str = r.read()
 print ("text =", str )
 sys.exit(0)
else:
 # This is the child process
 os.close(r)
 w = os.fdopen(w, 'w')
 print ("Child writing")
 w.write("Text written by child...")
 w.close()
 print ("Child closing")
 sys.exit(0)
When we run the above program, it produces the following resultThe child will write text to a pipe and
the parent will read the text written by child...
Parent reading
Child writing
Child closing
text = Text written by child...
os.popen() Method
Description
The method popen() opens a pipe to or from command.The return value is an open file
object connected to the pipe, which can be read or written depending on whether mode is
'r' (default) or 'w'.The bufsize argument has the same meaning as in open() function.
Syntax
Following is the syntax for popen() methodos.popen(command[, mode[, bufsize]])
Parameters
 command - This is command used.
 mode - This is the Mode can be 'r'(default) or 'w'.
Python 3
298
 bufsize - If the buffering value is set to 0, no buffering will take place. If the
buffering value is 1, line buffering will be performed while accessing a file. If you
specify the buffering value as an integer greater than 1, then buffering action will
be performed with the indicated buffer size. If negative, the buffer size is the
system default(default behavior).
Return Value
This method returns an open file object connected to the pipe.
Example
The following example shows the usage of popen() method.
# !/usr/bin/python3
import os, sys
# using command mkdir
a = 'mkdir nwdir'
b = os.popen(a,'r',1)
print b
When we run the above program, it produces the following resultopen file 'mkdir nwdir', mode 'r' at 0x81614d0
os.read() Method
Description
The method read() reads at most n bytes from file desciptor fd, return a string containing
the bytes read. If the end of file referred to by fd has been reached, an empty string is
returned.
Note: This function is intended for low-level I/O and must be applied to a file descriptor
as returned by os.open() or pipe(). To read a “file object” returned by the built-in function
open() or by popen() or fdopen(), or sys.stdin, use its read() or readline() methods.
Syntax
Following is the syntax for read() methodos.read(fd,n)
Parameters
 fd - This is the file descriptor of the file.
 n - These are n bytes from file descriptor fd.
Python 3
299
Return Value
This method returns a string containing the bytes read.
Example
The following example shows the usage of read() method.
# !/usr/bin/python3
import os, sys
# Open a file
fd = os.open("foo.txt",os.O_RDWR)
# Reading text
ret = os.read(fd,12)
print (ret.decode())
# Close opened file
os.close(fd)
print ("Closed the file successfully!!")
Let us compile and run the above program, this will print the contents of file foo.txtThis is test
Closed the file successfully!!
os.readlink() Method
Description
The method readlink() returns a string representing the path to which the symbolic link
points. It may return an absolute or relative pathname.
Syntax
Following is the syntax for readlink() methodos.readlink(path)
Parameters
path - This is the path or symblic link for which we are going to find source of the link.
Return Value
This method return a string representing the path to which the symbolic link points.
Example
Python 3
300
The following example shows the usage of readlink() method.
# !/usr/bin/python3
import os
src = 'd://tmp//python3'
dst = 'd://tmp//python2'
# This creates a symbolic link on python in tmp directory
os.symlink(src, dst)
# Now let us use readlink to display the source of the link.
path = os.readlink( dst )
print (path)
Let us compile and run the above program. This will create a symblic link to
d:\tmp\python3 and later it will read the source of the symbolic link using readlink() call.
This is an example on Windows platform and needs administrator privilege to run. Before
running this program make sure you do not have d:\tmp\python2 already available.
d:\tmp\python2
os.remove() Method
Description
The method remove() removes the file path. If the path is a directory, OSError is raised.
Syntax
Following is the syntax for remove() methodos.remove(path)
Parameters
path - This is the path, which is to be removed.
Return Value
This method does not return any value.
Example
The following example shows the usage of remove() method.
# !/usr/bin/python3
import os, sys
os.chdir("d:\\tmp")
Python 3
301
# listing directories
print ("The dir is: %s" %os.listdir(os.getcwd()))
# removing
os.remove("test.java")
# listing directories after removing path
print ("The dir after removal of path : %s" %os.listdir(os.getcwd()))
When we run above program, it produces following resultThe dir is: ['Applicationdocs.docx', 'book.zip', 'foo.txt', 'home', 'Java
Multiple Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt',
'ParallelPortViewer', 'test.java']
The dir after removal of path : ['Applicationdocs.docx', 'book.zip', 'foo.txt',
'home', 'Java Multiple Inheritance.htm', 'Java Multiple Inheritance_files',
'java.ppt', 'ParallelPortViewer']
os.removedirs() Method
Description
The method removedirs() removes dirs recursively. If the leaf directory is succesfully
removed, removedirs tries to successively remove every parent directory displayed in
path. Raises OSError if the leaf directory could not be successfully removed.
Syntax
Following is the syntax for removedirs() methodos.removedirs(path)
Parameters
path - This is the path of the directory, which needs to be removed.
Return Value
This method does not return any value.
Example
The following example shows the usage of removedirs() method.
# !/usr/bin/python3
import os, sys
Python 3
302
os.chdir("d:\\tmp")
# listing directories
print ("The dir is: %s" %os.listdir(os.getcwd()))
# removing
os.removedirs("home\\monthly\\daily")
# listing directories after removing directory
print ("The dir after removal is:" %os.listdir(os.getcwd()))
When we run the above program, it produces the following resultThe dir is: ['Applicationdocs.docx', 'book.zip', 'foo.txt', 'home', 'Java
Multiple Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt',
'ParallelPortViewer']
The dir after removal is:
['Applicationdocs.docx', 'book.zip', 'foo.txt', 'Java Multiple Inheritance.htm',
'Java Multiple Inheritance_files', 'java.ppt', 'ParallelPortViewer']
os.rename() Method
Description
The method rename() renames the file or directory src to dst. If dst is a file or
directory(already present), OSError will be raised.
Syntax
Following is the syntax for rename() methodos.rename(src, dst)
Parameters
 src - This is the actual name of the file or directory.
 dst - This is the new name of the file or directory.
Return Value
This method does not return any value.
Example
The following example shows the usage of rename() method.
# !/usr/bin/python3
import os, sys
Python 3
303
os.chdir("d:\\tmp")
# listing directories
print ("The dir is: %s"%os.listdir(os.getcwd()))
# renaming directory ''tutorialsdir"
os.rename("python3","python2")
print ("Successfully renamed.")
# listing directories after renaming "python3"
print ("the dir is: %s" %os.listdir(os.getcwd()))
When we run the above program, it produces the following resultThe dir is: ['Applicationdocs.docx', 'book.zip', 'foo.txt', 'Java Multiple
Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt', 'Python3']
Successfully renamed.
the dir is: ['Applicationdocs.docx', 'book.zip', 'foo.txt', 'Java Multiple
Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt', 'python2']
os.renames() Method
Description
The method renames() is recursive directory or file renaming function. It does the same
functioning as os.rename(), but it also moves a file to a directory, or a whole tree of
directories, that do not exist.
Syntax
Following is the syntax for renames() method:
os.renames(old, new)
Parameters
 old - This is the actual name of the file or directory to be renamed.
 new - This is the new name of the file or directory. It can even include a file to a
directory, or a whole tree of directories, that do not exist.
Return Value
This method does not return any value.
Example
The following example shows the usage of renames() method.
Python 3
304
# !/usr/bin/python3
import os, sys
os.chdir("d:\\tmp")
print ("Current directory is: %s" %os.getcwd())
# listing directories
print ("The dir is: %s"%os.listdir(os.getcwd()))
# renaming file "aa1.txt"
os.renames("foo.txt","newdir/foonew.txt")
print ("Successfully renamed.")
# listing directories after renaming and moving "foo.txt"
print ("The dir is: %s" %os.listdir(os.getcwd()))
os.chdir("newdir")
print ("The dir is: %s" %os.listdir(os.getcwd()))
When we run the above program, it produces the following resultCurrent directory is: d:\tmp
The dir is: ['Applicationdocs.docx', 'book.zip', 'foo.txt', 'Java Multiple
Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt', 'python2']
Successfully renamed.
The dir is: ['Applicationdocs.docx', 'book.zip', 'Java Multiple Inheritance.htm',
'Java Multiple Inheritance_files', 'java.ppt', 'newdir', 'python2']
The file foo.txt is not visible here, as it is been moved to newdir and renamed
as foonew.txt. The directory newdir and its contents are shown below:
The dir is: ['foonew.txt']
os.renames() Method
Description
The method renames() is recursive directory or file renaming function. It does the same
functioning as os.rename(), but it also moves a file to a directory, or a whole tree of
directories, that do not exist.
Syntax
Following is the syntax for renames() methodos.renames(old, new)
Parameters
 old - This is the actual name of the file or directory to be renamed.
Python 3
305
 new - This is the new name of the file or directory.It can even include a file to a
directory, or a whole tree of directories, that do not exist.
Return Value
This method does not return any value.
Example
The following example shows the usage of renames() method.
# !/usr/bin/python3
import os, sys
os.chdir("d:\\tmp")
print ("Current directory is: %s" %os.getcwd())
# listing directories
print ("The dir is: %s"%os.listdir(os.getcwd()))
# renaming file "aa1.txt"
os.renames("foo.txt","newdir/foonew.txt")
print ("Successfully renamed.")
# listing directories after renaming and moving "foo.txt"
print ("The dir is: %s" %os.listdir(os.getcwd()))
os.chdir("newdir")
print ("The dir is: %s" %os.listdir(os.getcwd()))
When we run the above program, it produces the following resultCurrent directory is: d:\tmp
The dir is: ['Applicationdocs.docx', 'book.zip', 'foo.txt', 'Java Multiple
Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt', 'python2']
Successfully renamed.
The dir is: ['Applicationdocs.docx', 'book.zip', 'Java Multiple Inheritance.htm',
'Java Multiple Inheritance_files', 'java.ppt', 'newdir', 'python2']
The file foo.txt is not visible here, as it is been moved to newdir and renamed
as foonew.txt. The directory newdir and its contents are shown below:
The dir is: ['foonew.txt']
os.rmdir() Method
Description
Python 3
306
The method rmdir() removes the directory path. It works only when the directory is
empty, else OSError is raised.
Syntax
Following is the syntax for rmdir() methodos.rmdir(path)
Parameters
path - This is the path of the directory, which needs to be removed.
Return Value
This method does not return any value.
Example
The following example shows the usage of rmdir() method.
# !/usr/bin/python3
import os, sys
os.chdir("d:\\tmp")
# listing directories
print ("the dir is: %s" %os.listdir(os.getcwd()))
# removing path
os.rmdir("newdir")
# listing directories after removing directory path
print ("the dir is:" %os.listdir(os.getcwd()))
When we run the above program, it produces the following resultthe dir is: ['Applicationdocs.docx', 'book.zip', 'Java Multiple Inheritance.htm',
'Java Multiple Inheritance_files', 'java.ppt', 'newdir', 'python2']
Traceback (most recent call last):
 File "test.py", line 8, in
 os.rmdir("newdir")
OSError: [WinError 145] The directory is not empty: 'newdir'
The error is coming as 'newdir' directory is not empty. If 'newdir' is an empty
directory, then this would produce following result:
Python 3
307
the dir is: ['Applicationdocs.docx', 'book.zip', 'Java Multiple Inheritance.htm',
'Java Multiple Inheritance_files', 'java.ppt', 'newdir', 'python2']
the dir is: ['Applicationdocs.docx', 'book.zip', 'Java Multiple Inheritance.htm',
'Java Multiple Inheritance_files', 'java.ppt', 'python2']
os.stat() Method
Description
The method stat() performs a stat system call on the given path.
Syntax
Following is the syntax for stat() methodos.stat(path)
Parameters
path - This is the path, whose stat information is required.
Return Value
Here is the list of members of stat structure-
 st_mode: protection bits.
 st_ino: inode number.
 st_dev: device.
 st_nlink: number of hard links.
 st_uid: user id of owner.
 st_gid: group id of owner.
 st_size: size of file, in bytes.
 st_atime: time of most recent access.
 st_mtime: time of most recent content modification.
 st_ctime: time of most recent metadata change.
Example
The following example shows the usage of stat() method.
# !/usr/bin/python3
import os, sys
# showing stat information of file "foo.txt"
statinfo = os.stat('foo.txt')
Python 3
308
print (statinfo)
When we run the above program, it produces the following resultos.stat_result(st_mode=33206, st_ino=281474976797706, st_dev=1017554828,
st_nlink=1, st_uid=0, st_gid=0, st_size=13, st_atime=1455649253,
st_mtime=1438077266, st_ctime=1455560006)
os.stat_float_times() Method
Description
The method stat_float_times() determines whether stat_result represents time stamps as
float objects.
Syntax
Following is the syntax for stat_float_times() methodos.stat_float_times([newvalue])
Parameters
newvalue - If newvalue is True, future calls to stat() return floats, if it is False, future call
on stat returns ints. If newvalue is not mentioned, it returns the current settings.
Return Value
This method returns either True or False.
Example
The following example shows the usage of stat_float_times() method.
#!/usr/bin/python3
import os, sys
# Stat information
statinfo = os.stat('a2.py')
print (statinfo)
statinfo = os.stat_float_times()
print (statinfo)
When we run the above program, it produces the following result-
Python 3
309
os.stat_result(st_mode=33206, st_ino=562949953508433, st_dev=1017554828,
st_nlink=1, st_uid=0, st_gid=0, st_size=27, st_atime=1455597032,
st_mtime=1455597032, st_ctime=1455562995)
True
os.statvfs() Method
Description
The method statvfs() perform a statvfs system call on the given path.
Syntax
Following is the syntax for statvfs() methodos.statvfs(path)
Parameters
path - This is the path, whose statvfs information is required.
Return Value
Here is the list of members of statvfs structure-
 f_bsize: preferred file system block size.
 f_frsize: fundamental file system block size.
 f_blocks: total number of blocks in the filesystem.
 f_bfree: total number of free blocks.
 f_bavail: free blocks available to non-super user.
 f_files: total number of file nodes.
 f_ffree: total number of free file nodes.
 f_favail: free nodes available to non-super user.
 f_flag: system dependent.
 f_namemax: maximum file name length.
Example
The following example shows the usage of statvfs() method. Availabe on Unix like
systems-
# !/usr/bin/python3
import os, sys
# showing statvfs information of file "a1.py"
stinfo = os.statvfs('a1.py')
Python 3
310
print (stinfo)
When we run the above program, it produces the following resultposix.statvfs_result(f_bsize=4096, f_frsize=4096, f_blocks=1909350L,
f_bfree=1491513L,
f_bavail=1394521L, f_files=971520L, f_ffree=883302L, f_fvail=883302L, f_flag=0,
f_namemax=255)
os.symlink() Method
Description
The method symlink() creates a symbolic link dst pointing to src.
Syntax
Following is the syntax for symlink() methodos.symlink(src, dst)
Parameters
 src - This is the source.
 dest - This is the destination, which did not exist previously.
Return Value
This method does not return any value.
Example
The following example shows the usage of symlink() method-
#!/usr/bin/python3
import os
src = '/usr/bin/python3'
dst = '/tmp/python'
# This creates a symbolic link on python in tmp directory
os.symlink(src, dst)
print "symlink created"
Let us compile and run the above program, this will create a symbolic link in /tmp directory
which will be as follows-
Python 3
311
lrwxrwxrwx. 1 root root 15 Apr 30 03:00 python -> /usr/bin/python3
os.tcgetpgrp() Method
Description
The method tcgetpgrp() returns the process group associated with the terminal given by
fd (an open file descriptor as returned by os.open())
Syntax
Following is the syntax for tcgetpgrp() methodos.tcgetpgrp(fd)
Parameters
fd - This is the file descriptor.
Return Value
This method returns the process group.
Example
The following example shows the usage of tcgetpgrp() method-
# !/usr/bin/python3
import os, sys
# Showing current directory
print ("Current working dir :%s" %os.getcwd())
# Changing dir to /dev/tty
fd = os.open("/dev/tty",os.O_RDONLY)
f = os.tcgetpgrp(fd)
# Showing the process group
print ("the process group associated is: ")
print (f)
os.close(fd)
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultCurrent working dir is :/tmp
the process group associated is:
Python 3
312
2670
Closed the file successfully!!
os.tcsetpgrp() Method
Description
The method tcsetpgrp() sets the process group associated with the terminal given by fd
(an open file descriptor as returned by os.open()) to pg.
Syntax
Following is the syntax for tcsetpgrp() methodos.tcsetpgrp(fd, pg)
Parameters
 fd - This is the file descriptor.
 pg - This set the process group to pg.
Return Value
This method does not return any value.
Example
The following example shows the usage of tcsetpgrp() method.
# !/usr/bin/python3
import os, sys
# Showing current directory
print ("Current working dir :%s" %os.getcwd())
# Changing dir to /dev/tty
fd = os.open("/dev/tty",os.O_RDONLY)
f = os.tcgetpgrp(fd)
# Showing the process group
print ("the process group associated is: ")
print (f)
Python 3
313
# Setting the process group
os.tcsetpgrp(fd,2672)
print ("done")
os.close(fd)
print "Closed the file successfully!!"
When we run the above program, it produces the following resultCurrent working dir is :/tmp
the process group associated is:
2672
done
Closed the file successfully!!
os.tempnam() Method
Description
The method tempnam() returns a unique path name that is reasonable for creating a
temporary file.
Syntax
Following is the syntax for tempnam() methodos.tempnam(dir, prefix)
Parameters
 dir - This is the dir where the temporary filename will be created.
 prefix - This is the prefix of the generated temporary filename.
Return Value
This method returns a unique path.
Example
The following example shows the usage of tempnam() method.
# !/usr/bin/python3
import os, sys
# prefix is tuts1 of the generated file
tmpfn = os.tempnam('/tmp/tutorialsdir,'tuts1')
Python 3
314
print "This is the unique path:"
print tmpfn
When we run the above program, it produces the following resultThis is the unique path:
/tmp/tutorialsdir/tuts1IbAco8
os.tmpfile() Method
Description
The method tmpfile() returns a new temporary file object opened in update mode (w+b).
The file has no directory entries associated with it and will be deleted automatically once
there are no file descriptors.
Syntax
Following is the syntax for tmpfile() methodos.tmpfile
Parameters
NA
Return Value
This method returns a new temporary file object.
Example
The following example shows the usage of tmpfile() method.
# !/usr/bin/python3
import os
# The file has no directory entries associated with it and will be
# deleted automatically once there are no file descriptors.
tmpfile = os.tmpfile()
tmpfile.write('Temporary newfile is here.....')
tmpfile.seek(0)
print tmpfile.read()
Python 3
315
tmpfile.close
When we run the above program, it produces the following resultTemporary newfile is here.....
os.tmpnam() Method
Description
The method tmpnam() returns a unique path name that is reasonable for creating a
temporary file.
Syntax
Following is the syntax for tmpnam() methodos.tmpnam()
Parameters
NA
Return Value
This method returns a unique path name.
Example
The following example shows the usage of tmpnam() method.
# !/usr/bin/python3
import os, sys
# Temporary file generated in current directory
tmpfn = os.tmpnam()
print "This is the unique path:"
print tmpfn
When we run the above program, it produces the following resultThis is the unique path:
/tmp/fileUFojpd
os.ttyname() Method
Description
Python 3
316
The method ttyname() returns a string, which specifies the terminal device associated
with fd. If fd is not associated with a terminal device, an exception is raised.
Syntax
Following is the syntax for ttyname() methodos.ttyname(fd)
Parameters
fd - This is the file descriptor.
Return Value
This method returns a string which specifies the terminal device. Available on Unix like
Systems.
Example
The following example shows the usage of ttyname() method.
# !/usr/bin/python33
import os, sys
# Showing current directory
print ("Current working dir :%s" %os.getcwd())
# Changing dir to /dev/tty
fd = os.open("/dev/tty",os.O_RDONLY)
p = os.ttyname(fd)
print ("the terminal device associated is: ")
print p
print ("done!!")
os.close(fd)
print ("Closed the file successfully!!")
When we run the above program, it produces the following resultCurrent working dir is :/tmp
the terminal device associated is:
/dev/tty
Python 3
317
done!!
Closed the file successfully!!
os.unlink() Method
Description
The method unlink() removes (deletes) the file path. If the path is a directory, OSError
is raised. This function is identical to the remove() mehod; the unlink name is its traditional
Unix name.
Syntax
Following is the syntax for unlink() methodos.unlink(path)
Parameters
path - This is the path, which is to be removed.
Return Value
This method does not return any value.
Example
The following example shows the usage of unlink() method.
# !/usr/bin/python3
import os, sys
os.chdir("d:\\tmp")
# listing directories
print ("The dir is: %s" %os.listdir(os.getcwd()))
os.unlink("foo.txt")
# listing directories after removing path
print ("The dir after removal of path : %s" %os.listdir(os.getcwd()))
When we run the above program, it produces the following resultThe dir is: ['Applicationdocs.docx', 'book.zip', 'foo.txt', 'Java Multiple
Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt', 'python2']
The dir after removal of path : ['Applicationdocs.docx', 'book.zip', 'Java
Multiple Inheritance.htm', 'Java Multiple Inheritance_files', 'java.ppt',
'python2']
Python 3
318
os.utime() Method
Description
The method utime() sets the access and modified times of the file specified by path.
Syntax
Following is the syntax for utime() methodos.utime(path, times)
Parameters
 path - This is the path of the file.
 times - This is the file access and modified time. If times is none, then the file
access and modified times are set to the current time. The parameter times consists
of row in the form of (atime, mtime) i.e (accesstime, modifiedtime).
Return Value
This method does not return any value.
Example
The following example shows the usage of utime() method.
# !/usr/bin/python3
import os, sys, time
os.chdir("d:\\tmp")
# Showing stat information of file
stinfo = os.stat('foo.txt')
print (stinfo)
# Using os.stat to recieve atime and mtime of file
print ("access time of foo.txt: %s" %stinfo.st_atime)
print ("modified time of foo.txt: %s" %stinfo.st_mtime)
print (time.asctime( time.localtime(stinfo.st_atime)))
# Modifying atime and mtime
os.utime("foo.txt",(1330712280, 1330712292))
print ("after modification")
print (time.asctime( time.localtime(stinfo.st_atime)))
print ("done!!")
When we run the above program, it produces the following result-
Python 3
319
os.stat_result(st_mode=33206, st_ino=1688849860351098, st_dev=1017554828,
st_nlink=1, st_uid=0, st_gid=0, st_size=0, st_atime=1455684273,
st_mtime=1455684273, st_ctime=1455683589)
access time of foo.txt: 1455684273.84375
modified time of foo.txt: 1455684273.84375
Wed Feb 17 10:14:33 2016
after modification
Fri Mar 2 23:48:00 2012
done!!
os.walk() Method
Description
The method walk() generates the file names in a directory tree by walking the tree either
top-down or bottom-up.
Syntax
Following is the syntax for the walk() methodos.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])
Parameters
 top - Each directory rooted at directory, yields 3-tuples, i.e., (dirpath, dirnames,
filenames)
 topdown - If optional argument topdown is True or not specified, directories are
scanned from top-down. If topdown is set to False, directories are scanned from
bottom-up.
 onerror - This can show error to continue with the walk, or raise the exception to
abort the walk.
 followlinks - This visits directories pointed to by symlinks, if set to true.
Return Value
This method does not return any value.
Example
The following example shows the usage of walk() method.
# !/usr/bin/python3
import os
Python 3
320
os.chdir("d:\\tmp")
for root, dirs, files in os.walk(".", topdown=False):
 for name in files:
 print(os.path.join(root, name))
 for name in dirs:
 print(os.path.join(root, name))
Let us compile and run the above program. This will scan all the directories and
subdirectories bottom-to-up.
.\python2\testdir\Readme_files\Lpt_Port_Config.gif
.\python2\testdir\Readme_files\ParallelPortViever.gif
.\python2\testdir\Readme_files\softcollection.css
.\python2\testdir\Readme_files\Thumbs.db
.\python2\testdir\Readme_files\Yellov_Ball.gif
.\python2\testdir\Readme.htm
.\python2\testdir\Readme_files
.\python2\testdir
.\Applicationdocs.docx
.\book.zip
.\foo.txt
.\java.ppt
.\python2
If you will change the value of topdown to True, then it will give you the following result-
.\Applicationdocs.docx
.\book.zip
.\foo.txt
.\java.ppt
.\python2
.\python2\testdir
.\python2\testdir\Readme.htm
.\python2\testdir\Readme_files
.\python2\testdir\Readme_files\Lpt_Port_Config.gif
.\python2\testdir\Readme_files\ParallelPortViever.gif
.\python2\testdir\Readme_files\softcollection.css
.\python2\testdir\Readme_files\Thumbs.db
Python 3
321
.\python2\testdir\Readme_files\Yellov_Ball.gif
os.write() Method
Description
The method write() writes the string str to file descriptor fd. It returns the number of
bytes actually written.
Syntax
Following is the syntax for write() methodos.write(fd, str)
Parameters
 fd - This is the file descriptor.
 str - This is the string to be written.
Return Value
This method returns the number of bytes actually written.
Example
The following example shows the usage of the write() method-
# !/usr/bin/python3
import os, sys
# Open a file
fd = os.open( "f1.txt", os.O_RDWR|os.O_CREAT )
# Write one string
line="this is test"
# string needs to be converted byte object
b=str.encode(line)
ret=os.write(fd, b)
# ret consists of number of bytes written to f1.txt
print ("the number of bytes written: ", ret)
# Close opened file
os.close( fd)
print ("Closed the file successfully!!")
When we run the above program, it produces the following result-
Python 3
322
the number of bytes written: 12
Closed the file successfully!!
Python 3
323
Python provides two very important features to handle any unexpected error in your
Python programs and to add debugging capabilities in them-
 Exception Handling.
 Assertions.
Standard Exceptions
Here is a list of Standard Exceptions available in Python.
EXCEPTION NAME DESCRIPTION
Exception Base class for all exceptions
StopIteration Raised when the next() method of an iterator does not point to
any object.
SystemExit Raised by the sys.exit() function.
StandardError Base class for all built-in exceptions except StopIteration and
SystemExit.
ArithmeticError Base class for all errors that occur for numeric calculation.
OverflowError Raised when a calculation exceeds maximum limit for a numeric
type.
FloatingPointError Raised when a floating point calculation fails.
ZeroDivisonError Raised when division or modulo by zero takes place for all
numeric types.
AssertionError Raised in case of failure of the Assert statement.
AttributeError Raised in case of failure of attribute reference or assignment.
18.Python 3 – Exceptions Handling 
Python 3
324
EOFError Raised when there is no input from either the raw_input() or
input() function and the end of file is reached.
ImportError Raised when an import statement fails.
KeyboardInterrupt Raised when the user interrupts program execution, usually by
pressing Ctrl+c.
LookupError Base class for all lookup errors.
IndexError Raised when an index is not found in a sequence.
KeyError Raised when the specified key is not found in the dictionary.
NameError Raised when an identifier is not found in the local or global
namespace.
UnboundLocalError Raised when trying to access a local variable in a function or
method but no value has been assigned to it.
EnvironmentError Base class for all exceptions that occur outside the Python
environment.
IOError Raised when an input/ output operation fails, such as the print
statement or the open() function when trying to open a file that
does not exist.
OSError Raised for operating system-related errors.
SyntaxError Raised when there is an error in Python syntax.
IndentationError Raised when indentation is not specified properly.
SystemError Raised when the interpreter finds an internal problem, but when
this error is encountered the Python interpreter does not exit.
SystemExit Raised when Python interpreter is quit by using the sys.exit()
function. If not handled in the code, causes the interpreter to
exit.
Python 3
325
TypeError Raised when an operation or function is attempted that is
invalid for the specified data type.
ValueError Raised when the built-in function for a data type has the valid
type of arguments, but the arguments have invalid values
specified.
RuntimeError Raised when a generated error does not fall into any category.
NotImplementedError Raised when an abstract method that needs to be implemented
in an inherited class is not actually implemented.
Assertions in Python
An assertion is a sanity-check that you can turn on or turn off when you are done with
your testing of the program.
 The easiest way to think of an assertion is to liken it to a raise-if statement (or to
be more accurate, a raise-if-not statement). An expression is tested, and if the
result comes up false, an exception is raised.
 Assertions are carried out by the assert statement, the newest keyword to Python,
introduced in version 1.5.
 Programmers often place assertions at the start of a function to check for valid
input, and after a function call to check for valid output.
The assert Statement
When it encounters an assert statement, Python evaluates the accompanying expression,
which is hopefully true. If the expression is false, Python raises
anAssertionError exception.
The syntax for assert is −
assert Expression[, Arguments]
If the assertion fails, Python uses ArgumentExpression as the argument for the
AssertionError. AssertionError exceptions can be caught and handled like any other
exception, using the try-except statement. If they are not handled, they will terminate the
program and produce a traceback.
Example
Here is a function that converts a given temperature from degrees Kelvin to degrees
Fahrenheit. Since 0° K is as cold as it gets, the function bails out if it sees a negative
temperature −
Python 3
326
#!/usr/bin/python3
def KelvinToFahrenheit(Temperature):
 assert (Temperature >= 0),"Colder than absolute zero!"
 return ((Temperature-273)*1.8)+32
print (KelvinToFahrenheit(273))
print (int(KelvinToFahrenheit(505.78)))
print (KelvinToFahrenheit(-5))
When the above code is executed, it produces the following result32.0
451
Traceback (most recent call last):
File "test.py", line 9, in
print KelvinToFahrenheit(-5)
File "test.py", line 4, in KelvinToFahrenheit
assert (Temperature >= 0),"Colder than absolute zero!"
AssertionError: Colder than absolute zero!
What is Exception?
An exception is an event, which occurs during the execution of a program that disrupts
the normal flow of the program's instructions. In general, when a Python script encounters
a situation that it cannot cope with, it raises an exception. An exception is a Python object
that represents an error.
When a Python script raises an exception, it must either handle the exception immediately
otherwise it terminates and quits.
Handling an Exception
If you have some suspicious code that may raise an exception, you can defend your
program by placing the suspicious code in a try: block. After the try: block, include
an except: statement, followed by a block of code which handles the problem as elegantly
as possible.
Syntax
Here is simple syntax of try....except...else blockstry:
 You do your operations here
 ......................
Python 3
327
except ExceptionI:
 If there is ExceptionI, then execute this block.
except ExceptionII:
 If there is ExceptionII, then execute this block.
 ......................
else:
 If there is no exception then execute this block.
Here are few important points about the above-mentioned syntax-
 A single try statement can have multiple except statements. This is useful when
the try block contains statements that may throw different types of exceptions.
 You can also provide a generic except clause, which handles any exception.
 After the except clause(s), you can include an else-clause. The code in the elseblock executes if the code in the try: block does not raise an exception.
 The else-block is a good place for code that does not need the try: block's
protection.
Example
This example opens a file, writes content in the file and comes out gracefully because there
is no problem at all.
#!/usr/bin/python3
try:
 fh = open("testfile", "w")
 fh.write("This is my test file for exception handling!!")
except IOError:
 print ("Error: can\'t find file or read data")
else:
 print ("Written content in the file successfully")
 fh.close()
This produces the following resultWritten content in the file successfully
Example
This example tries to open a file where you do not have the write permission, so it raises
an exception-
Python 3
328
#!/usr/bin/python3
try:
 fh = open("testfile", "r")
 fh.write("This is my test file for exception handling!!")
except IOError:
 print ("Error: can\'t find file or read data")
else:
 print ("Written content in the file successfully")
This produces the following resultError: can't find file or read data
The except Clause with No Exceptions
You can also use the except statement with no exceptions defined as followstry:
 You do your operations here
 ......................
except:
 If there is any exception, then execute this block.
 ......................
else:
 If there is no exception then execute this block.
This kind of a try-except statement catches all the exceptions that occur. Using this kind
of try-except statement is not considered a good programming practice though, because
it catches all exceptions but does not make the programmer identify the root cause of the
problem that may occur.
The except Clause with Multiple Exceptions
You can also use the same except statement to handle multiple exceptions as followstry:
 You do your operations here
 ......................
except(Exception1[, Exception2[,...ExceptionN]]]):
 If there is any exception from the given exception list,
 then execute this block.
 ......................
Python 3
329
else:
 If there is no exception then execute this block.
The try-finally Clause
You can use a finally: block along with a try: block. The finally: block is a place to put
any code that must execute, whether the try-block raised an exception or not. The syntax
of the try-finally statement is thistry:
 You do your operations here;
 ......................
 Due to any exception, this may be skipped.
finally:
 This would always be executed.
 ......................
Note: You can provide except clause(s), or a finally clause, but not both. You cannot
use else clause as well along with a finally clause.
Example
#!/usr/bin/python3
try:
 fh = open("testfile", "w")
 fh.write("This is my test file for exception handling!!")
finally:
 print ("Error: can\'t find file or read data")
 fh.close()
If you do not have permission to open the file in writing mode, then this will produce the
following resultError: can't find file or read data
Same example can be written more cleanly as follows-
#!/usr/bin/python3
try:
 fh = open("testfile", "w")
 try:
 fh.write("This is my test file for exception handling!!")
Python 3
330
 finally:
 print ("Going to close the file")
 fh.close()
except IOError:
 print ("Error: can\'t find file or read data")
When an exception is thrown in the try block, the execution immediately passes to
the finally block. After all the statements in the finally block are executed, the exception
is raised again and is handled in the except statements if present in the next higher layer
of the try-except statement.
Argument of an Exception
An exception can have an argument, which is a value that gives additional information
about the problem. The contents of the argument vary by exception. You capture an
exception's argument by supplying a variable in the except clause as followstry:
 You do your operations here
 ......................
except ExceptionType as Argument:
 You can print value of Argument here...
If you write the code to handle a single exception, you can have a variable follow the name
of the exception in the except statement. If you are trapping multiple exceptions, you can
have a variable follow the tuple of the exception.
This variable receives the value of the exception mostly containing the cause of the
exception. The variable can receive a single value or multiple values in the form of a tuple.
This tuple usually contains the error string, the error number, and an error location.
Example
Following is an example for a single exception-
#!/usr/bin/python3
# Define a function here.
def temp_convert(var):
try:
returnint(var)
except ValueError as Argument:
print("The argument does not contain numbers\n",Argument)
# Call above function here.
Python 3
331
temp_convert("xyz")
This produces the following resultThe argument does not contain numbers
invalid literal for int() with base 10: 'xyz'
Raising an Exception
You can raise exceptions in several ways by using the raise statement. The general syntax
for the raise statement is as followsSyntax
raise [Exception [, args [, traceback]]]
Here, Exception is the type of exception (for example, NameError) and argument is a
value for the exception argument. The argument is optional; if not supplied, the exception
argument is None.
The final argument, traceback, is also optional (and rarely used in practice), and if present,
is the traceback object used for the exception.
Example
An exception can be a string, a class or an object. Most of the exceptions that the Python
core raises are classes, with an argument that is an instance of the class. Defining new
exceptions is quite easy and can be done as followsdef functionName( level ):
 if level <1:
 raise Exception(level)
 # The code below to this would not be executed
 # if we raise the exception
 return level
Note: In order to catch an exception, an "except" clause must refer to the same exception
thrown either as a class object or a simple string. For example, to capture the above
exception, we must write the except clause as followstry:
 Business Logic here...
except Exception as e:
 Exception handling here using e.args...
Python 3
332
else:
 Rest of the code here...
The following example illustrates the use of raising an exception-
#!/usr/bin/python3
def functionName( level ):
 if level <1:
 raise Exception(level)
 # The code below to this would not be executed
 # if we raise the exception
 return level
try:
 l=functionName(-10)
 print ("level=",l)
except Exception as e:
 print ("error in level argument",e.args[0])
This will produce the following resulterror in level argument -10
User-Defined Exceptions
Python also allows you to create your own exceptions by deriving classes from the standard
built-in exceptions.
Here is an example related to RuntimeError. Here, a class is created that is subclassed
from RuntimeError. This is useful when you need to display more specific information when
an exception is caught.
In the try block, the user-defined exception is raised and caught in the except block. The
variable e is used to create an instance of the class Networkerror.
class Networkerror(RuntimeError):
 def __init__(self, arg):
 self.args = arg
So once you have defined the above class, you can raise the exception as followstry:
 raise Networkerror("Bad hostname")
except Networkerror,e:
 print e.args
Python 3
333
Python 3 – Advanced Tutorial
Python 3
334
Python has been an object-oriented language since the time it existed. Due to this,
creating and using classes and objects are downright easy. This chapter helps you become
an expert in using Python's object-oriented programming support.
If you do not have any previous experience with object-oriented (OO) programming, you
may want to consult an introductory course on it or at least a tutorial of some sort so that
you have a grasp of the basic concepts.
However, here is a small introduction of Object-Oriented Programming (OOP) to help you.
Overview of OOP Terminology
 Class: A user-defined prototype for an object that defines a set of attributes that
characterize any object of the class. The attributes are data members (class
variables and instance variables) and methods, accessed via dot notation.
 Class variable: A variable that is shared by all instances of a class. Class variables
are defined within a class but outside any of the class's methods. Class variables
are not used as frequently as instance variables are.
 Data member: A class variable or instance variable that holds data associated with
a class and its objects.
 Function overloading: The assignment of more than one behavior to a particular
function. The operation performed varies by the types of objects or arguments
involved.
 Instance variable: A variable that is defined inside a method and belongs only to
the current instance of a class.
 Inheritance: The transfer of the characteristics of a class to other classes that are
derived from it.
 Instance: An individual object of a certain class. An object obj that belongs to a
class Circle, for example, is an instance of the class Circle.
 Instantiation: The creation of an instance of a class.
 Method : A special kind of function that is defined in a class definition.
 Object: A unique instance of a data structure that is defined by its class. An object
comprises both data members (class variables and instance variables) and
methods.
 Operator overloading: The assignment of more than one function to a particular
operator.
19.Python 3 – Object Oriented 
Python 3
335
Creating Classes
The class statement creates a new class definition. The name of the class immediately
follows the keyword class followed by a colon as followsclass ClassName:
 'Optional class documentation string'
 class_suite
 The class has a documentation string, which can be accessed
viaClassName.__doc__.
 The class_suite consists of all the component statements defining class members,
data attributes and functions.
Example
Following is an example of a simple Python classclass Employee:
 'Common base class for all employees'
 empCount = 0
 def __init__(self, name, salary):
 self.name = name
 self.salary = salary
 Employee.empCount += 1

 def displayCount(self):
 print "Total Employee %d" % Employee.empCount
 def displayEmployee(self):
 print ("Name : ", self.name, ", Salary: ", self.salary)
 The variable empCount is a class variable whose value is shared among all the
instances of a in this class. This can be accessed as Employee.empCount from
inside the class or outside the class.
 The first method __init__() is a special method, which is called class constructor
or initialization method that Python calls when you create a new instance of this
class.
 You declare other class methods like normal functions with the exception that the
first argument to each method is self. Python adds the self argument to the list for
you; you do not need to include it when you call the methods.
Python 3
336
Creating Instance Objects
To create instances of a class, you call the class using class name and pass in whatever
arguments its __init__ method accepts.
This would create first object of Employee class
emp1 = Employee("Zara", 2000)
This would create second object of Employee class
emp2 = Employee("Manni", 5000)
Accessing Attributes
You access the object's attributes using the dot operator with object. Class variable would
be accessed using class name as followsemp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)
Now, putting all the concepts together-
#!/usr/bin/python3
class Employee:
 'Common base class for all employees'
 empCount = 0
 def __init__(self, name, salary):
 self.name = name
 self.salary = salary
 Employee.empCount += 1

 def displayCount(self):
 print ("Total Employee %d" % Employee.empCount)
 def displayEmployee(self):
 print ("Name : ", self.name, ", Salary: ", self.salary)
#This would create first object of Employee class"
emp1 = Employee("Zara", 2000)
#This would create second object of Employee class"
Python 3
337
emp2 = Employee("Manni", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print ("Total Employee %d" % Employee.empCount)
When the above code is executed, it produces the following resultName : Zara ,Salary: 2000
Name : Manni ,Salary: 5000
Total Employee 2
You can add, remove, or modify attributes of classes and objects at any timeemp1.salary = 7000 # Add an 'salary' attribute.
emp1.name = 'xyz' # Modify 'age' attribute.
del emp1.salary # Delete 'age' attribute.
Instead of using the normal statements to access attributes, you can use the following
functions-
 The getattr(obj, name[, default]): to access the attribute of object.
 The hasattr(obj,name): to check if an attribute exists or not.
 The setattr(obj,name,value): to set an attribute. If attribute does not exist, then
it would be created.
 The delattr(obj, name): to delete an attribute.
hasattr(emp1, 'salary') # Returns true if 'salary' attribute exists
getattr(emp1, 'salary') # Returns value of 'salary' attribute
setattr(emp1, 'salary', 7000) # Set attribute 'age' at 8
delattr(emp1, 'salary') # Delete attribute 'age'
Built-In Class Attributes
Every Python class keeps the following built-in attributes and they can be accessed using
dot operator like any other attribute −
 __dict__: Dictionary containing the class's namespace.
 __doc__: Class documentation string or none, if undefined.
 __name__: Class name.
 __module__: Module name in which the class is defined. This attribute is
"__main__" in interactive mode.
Python 3
338
 __bases__: A possibly empty tuple containing the base classes, in the order of
their occurrence in the base class list.
For the above class let us try to access all these attributes-
#!/usr/bin/python3
class Employee:
 'Common base class for all employees'
 empCount = 0
 def __init__(self, name, salary):
 self.name = name
 self.salary = salary
 Employee.empCount += 1

 def displayCount(self):
 print ("Total Employee %d" % Employee.empCount)
 def displayEmployee(self):
 print ("Name : ", self.name, ", Salary: ", self.salary)
emp1 = Employee("Zara", 2000)
emp2 = Employee("Manni", 5000)
print ("Employee.__doc__:", Employee.__doc__)
print ("Employee.__name__:", Employee.__name__)
print ("Employee.__module__:", Employee.__module__)
print ("Employee.__bases__:", Employee.__bases__)
print ("Employee.__dict__:", Employee.__dict__ )
When the above code is executed, it produces the following resultEmployee.__doc__: Common base class for all employees
Employee.__name__: Employee
Employee.__module__: __main__
Employee.__bases__: (,)
Employee.__dict__: {'displayCount': , '__module__': '__main__', '__doc__':
'Common base class for all employees', 'empCount': 2, '__init__': ,
'displayEmployee': , '__weakref__': , '__dict__': }
Python 3
339
Destroying Objects (Garbage Collection)
Python deletes unneeded objects (built-in types or class instances) automatically to free
the memory space. The process by which Python periodically reclaims blocks of memory
that no longer are in use is termed as Garbage Collection.
Python's garbage collector runs during program execution and is triggered when an
object's reference count reaches zero. An object's reference count changes as the number
of aliases that point to it changes.
An object's reference count increases when it is assigned a new name or placed in a
container (list, tuple, or dictionary). The object's reference count decreases when it is
deleted with del, its reference is reassigned, or its reference goes out of scope. When an
object's reference count reaches zero, Python collects it automatically.
a = 40 # Create object <40>
b = a # Increase ref. count of <40>
c = [b] # Increase ref. count of <40>
del a # Decrease ref. count of <40>
b = 100 # Decrease ref. count of <40>
c[0] = -1 # Decrease ref. count of <40>
You normally will not notice when the garbage collector destroys an orphaned instance
and reclaims its space. However, a class can implement the special method__del__(),
called a destructor, that is invoked when the instance is about to be destroyed. This
method might be used to clean up any non-memory resources used by an instance.
Example
This __del__() destructor prints the class name of an instance that is about to be
destroyed.
#!/usr/bin/python3
class Point:
 def __init( self, x=0, y=0):
 self.x = x
 self.y = y
 def __del__(self):
 class_name = self.__class__.__name__
 print (class_name, "destroyed")
pt1 = Point()
pt2 = pt1
pt3 = pt1
Python 3
340
print (id(pt1), id(pt2), id(pt3) # prints the ids of the obejcts)
del pt1
del pt2
del pt3
When the above code is executed, it produces the following result3083401324 3083401324 3083401324
Point destroyed
Note: Ideally, you should define your classes in a separate file, then you should import
them in your main program file using import statement.
In the above example, assuming definition of a Point class is contained in point.py and there
is no other executable code in it.
#!/usr/bin/python3
import point
p1=point.Point()
Class Inheritance
Instead of starting from a scratch, you can create a class by deriving it from a pre-existing
class by listing the parent class in parentheses after the new class name.
The child class inherits the attributes of its parent class, and you can use those attributes
as if they were defined in the child class. A child class can also override data members and
methods from the parent.
Syntax
Derived classes are declared much like their parent class; however, a list of base classes
to inherit from is given after the class name −
class SubClassName (ParentClass1[, ParentClass2, ...]):
 'Optional class documentation string'
 class_suite
Example
#!/usr/bin/python3
class Parent: # define parent class
 parentAttr = 100
 def __init__(self):
Python 3
341
 print ("Calling parent constructor")
 def parentMethod(self):
 print ('Calling parent method')
 def setAttr(self, attr):
 Parent.parentAttr = attr
 def getAttr(self):
 print ("Parent attribute :", Parent.parentAttr)
class Child(Parent): # define child class
 def __init__(self):
 print ("Calling child constructor")
 def childMethod(self):
 print ('Calling child method')
c = Child() # instance of child
c.childMethod() # child calls its method
c.parentMethod() # calls parent's method
c.setAttr(200) # again call parent's method
c.getAttr() # again call parent's method
When the above code is executed, it produces the following resultCalling child constructor
Calling child method
Calling parent method
Parent attribute : 200
In a similar way, you can drive a class from multiple parent classes as followsclass A: # define your class A
.....
class B: # define your calss B
.....
class C(A, B): # subclass of A and B
.....
Python 3
342
You can use issubclass() or isinstance() functions to check a relationship of two classes
and instances.
 The issubclass(sub, sup) boolean function returns True, if the given
subclass sub is indeed a subclass of the superclass sup.
 The isinstance(obj, Class) boolean function returns True, if obj is an instance of
class Class or is an instance of a subclass of Class.
Overriding Methods
You can always override your parent class methods. One reason for overriding parent's
methods is that you may want special or different functionality in your subclass.
Example
#!/usr/bin/python3
class Parent: # define parent class
 def myMethod(self):
 print ('Calling parent method')
class Child(Parent): # define child class
 def myMethod(self):
 print ('Calling child method')
c = Child() # instance of child
c.myMethod() # child calls overridden method
When the above code is executed, it produces the following resultCalling child method
Base Overloading Methods
The following table lists some generic functionality that you can override in your own
classesSN Method, Description & Sample Call
1 __init__ ( self [,args...] )
Constructor (with any optional arguments)
Sample Call : obj = className(args)
Python 3
343
2 __del__( self )
Destructor, deletes an object
Sample Call : del obj
3 __repr__( self )
Evaluatable string representation
Sample Call : repr(obj)
4 __str__( self )
Printable string representation
Sample Call : str(obj)
5 __cmp__ ( self, x )
Object comparison
Sample Call : cmp(obj, x)
Overloading Operators
Suppose you have created a Vector class to represent two-dimensional vectors. What
happens when you use the plus operator to add them? Most likely Python will yell at you.
You could, however, define the __add__ method in your class to perform vector addition
and then the plus operator would behave as per expectation −
Example
#!/usr/bin/python3
class Vector:
 def __init__(self, a, b):
 self.a = a
 self.b = b
 def __str__(self):
 return 'Vector (%d, %d)' % (self.a, self.b)

 def __add__(self,other):
 return Vector(self.a + other.a, self.b + other.b)
v1 = Vector(2,10)
v2 = Vector(5,-2)
print (v1 + v2)
When the above code is executed, it produces the following result-
Python 3
344
Vector(7,8)
Data Hiding
An object's attributes may or may not be visible outside the class definition. You need to
name attributes with a double underscore prefix, and those attributes then will not be
directly visible to outsiders.
Example
#!/usr/bin/python3
class JustCounter:
 __secretCount = 0

 def count(self):
 self.__secretCount += 1
 print (self.__secretCount)
counter = JustCounter()
counter.count()
counter.count()
print (counter.__secretCount)
When the above code is executed, it produces the following result1
2
Traceback (most recent call last):
 File "test.py", line 12, in <module>
 print counter.__secretCount
AttributeError: JustCounter instance has no attribute '__secretCount'
Python protects those members by internally changing the name to include the class name.
You can access such attributes as object._className__attrName. If you would replace
your last line as following, then it works for you-
.........................
print (counter._JustCounter__secretCount)
When the above code is executed, it produces the following result-
Python 3
345
1
2
2
Python 3
346
A regular expression is a special sequence of characters that helps you match or find other
strings or sets of strings, using a specialized syntax held in a pattern. Regular expressions
are widely used in UNIX world.
The module re provides full support for Perl-like regular expressions in Python. The re
module raises the exception re.error if an error occurs while compiling or using a regular
expression.
We would cover two important functions, which would be used to handle regular
expressions. Nevertheless, a small thing first: There are various characters, which would
have special meaning when they are used in regular expression. To avoid any confusion
while dealing with regular expressions, we would use Raw Strings asr'expression'.
Basic patterns that match single chars
 a, X, 9, < -- ordinary characters just match themselves exactly.
 . (a period) -- matches any single character except newline '\n'
 \w -- matches a "word" character: a letter or digit or underbar [a-zA-Z0-9_].
 \W -- matches any non-word character.
 \b -- boundary between word and non-word
 \s -- matches a single whitespace character -- space, newline, return, tab
 \S -- matches any non-whitespace character.
 \t, \n, \r -- tab, newline, return
 \d -- decimal digit [0-9]
 ^ = matches start of the string
 $ = match the end of the string
 \ -- inhibit the "specialness" of a character.
Compilation flags
Compilation flags let you modify some aspects of how regular expressions work. Flags are
available in the re module under two names, a long name such as IGNORECASE and a
short, one-letter form such as I.
Flag Meaning
ASCII, A Makes several escapes like \w, \b, \s and \d match only on ASCII
characters with the respective property.
DOTALL, S Make, match any character, including newlines
IGNORECASE, I Do case-insensitive matches
20.Python 3 – Regular Expressions 
Python 3
347
LOCALE, L Do a locale-aware match
MULTILINE, M Multi-line matching, affecting ^ and $
VERBOSE, X (for
‘extended’)
Enable verbose REs, which can be organized more cleanly and
understandably
The match Function
This function attempts to match RE pattern to string with optional flags.
Here is the syntax for this functionre.match(pattern, string, flags=0)
Here is the description of the parametersParameter Description
pattern This is the regular expression to be matched.
string This is the string, which would be searched to match the
pattern at the beginning of string.
flags You can specify different flags using bitwise OR (|). These are
modifiers, which are listed in the table below.
The re.match function returns a match object on success, None on failure. We use
group(num) or groups() function of match object to get matched expression.
Match Object
Methods
Description
group(num=0) This method returns entire match (or specific subgroup num)
groups() This method returns all matching subgroups in a tuple (empty
if there weren't any)
Example
#!/usr/bin/python3
import re
line = "Cats are smarter than dogs"
Python 3
348
matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)
if matchObj:
 print ("matchObj.group() : ", matchObj.group())
 print ("matchObj.group(1) : ", matchObj.group(1))
 print ("matchObj.group(2) : ", matchObj.group(2))
else:
 print ("No match!!")
When the above code is executed, it produces the following resultmatchObj.group() : Cats are smarter than dogs
matchObj.group(1) : Cats
matchObj.group(2) : smarter
The search Function
This function searches for first occurrence of RE pattern within the string, with
optional flags.
Here is the syntax for this functionre.search(pattern, string, flags=0)
Here is the description of the parametersParameter Description
pattern This is the regular expression to be matched.
string This is the string, which would be searched to match the
pattern anywhere in the string.
flags You can specify different flags using bitwise OR (|). These are
modifiers, which are listed in the table below.
The re.search function returns a match object on success, none on failure. We
use group(num) or groups() function of match object to get the matched expression.
Match Object
Methods
Description
group(num=0) This method returns entire match (or specific subgroup num)
Python 3
349
groups() This method returns all matching subgroups in a tuple (empty
if there weren't any)
Example
#!/usr/bin/python3
import re
line = "Cats are smarter than dogs";
searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)
if searchObj:
 print ("searchObj.group() : ", searchObj.group())
 print ("searchObj.group(1) : ", searchObj.group(1))
 print ("searchObj.group(2) : ", searchObj.group(2))
else:
 print ("Nothing found!!")
When the above code is executed, it produces following resultmatchObj.group() : Cats are smarter than dogs
matchObj.group(1) : Cats
matchObj.group(2) : smarter
Matching Versus Searching
Python offers two different primitive operations based on regular expressions
:match checks for a match only at the beginning of the string, while search checks for a
match anywhere in the string (this is what Perl does by default).
Example
#!/usr/bin/python3
import re
line = "Cats are smarter than dogs";
matchObj = re.match( r'dogs', line, re.M|re.I)
if matchObj:
 print ("match --> matchObj.group() : ", matchObj.group())
else:
 print ("No match!!")
searchObj = re.search( r'dogs', line, re.M|re.I)
if searchObj:
Python 3
350
 print ("search --> searchObj.group() : ", searchObj.group())
else:
 print ("Nothing found!!")
When the above code is executed, it produces the following resultNo match!!
search --> matchObj.group() : dogs
Search and Replace
One of the most important re methods that use regular expressions is sub.
Syntax
re.sub(pattern, repl, string, max=0)
This method replaces all occurrences of the RE pattern in string with repl, substituting all
occurrences unless max is provided. This method returns modified string.
Example
#!/usr/bin/python3
import re
phone = "2004-959-559 # This is Phone Number"
# Delete Python-style comments
num = re.sub(r'#.*$', "", phone)
print ("Phone Num : ", num)
# Remove anything other than digits
num = re.sub(r'\D', "", phone)
print ("Phone Num : ", num)
When the above code is executed, it produces the following resultPhone Num : 2004-959-559
Phone Num : 2004959559
Regular Expression Modifiers: Option Flags
Regular expression literals may include an optional modifier to control various aspects of
matching. The modifiers are specified as an optional flag. You can provide multiple 
Python 3
351
modifiers using exclusive OR (|), as shown previously and may be represented by one of
theseModifier Description
re.I Performs case-insensitive matching.
re.L Interprets words according to the current locale. This
interpretation affects the alphabetic group (\w and \W), as well
as word boundary behavior (\b and \B).
re.M Makes $ match the end of a line (not just the end of the string)
and makes ^ match the start of any line (not just the start of the
string).
re.S Makes a period (dot) match any character, including a newline.
re.U Interprets letters according to the Unicode character set. This flag
affects the behavior of \w, \W, \b, \B.
re.X Permits "cuter" regular expression syntax. It ignores whitespace
(except inside a set [] or when escaped by a backslash) and treats
unescaped # as a comment marker.
Regular Expression Patterns
Except for the control characters, (+ ? . * ^ $ ( ) [ ] { } | \), all characters match
themselves. You can escape a control character by preceding it with a backslash.
The following table lists the regular expression syntax that is available in PythonPattern Description
^ Matches beginning of line.
$ Matches end of line.
. Matches any single character except newline. Using m option
allows it to match newline as well.
[...] Matches any single character in brackets.
[^...] Matches any single character not in brackets
Python 3
352
re* Matches 0 or more occurrences of preceding expression.
re+ Matches 1 or more occurrence of preceding expression.
re? Matches 0 or 1 occurrence of preceding expression.
re{ n} Matches exactly n number of occurrences of preceding
expression.
re{ n,} Matches n or more occurrences of preceding expression.
re{ n, m} Matches at least n and at most m occurrences of preceding
expression.
a| b Matches either a or b.
(re) Groups regular expressions and remembers matched text.
(?imx) Temporarily toggles on i, m, or x options within a regular
expression. If in parentheses, only that area is affected.
(?-imx) Temporarily toggles off i, m, or x options within a regular
expression. If in parentheses, only that area is affected.
(?: re) Groups regular expressions without remembering matched text.
(?imx: re) Temporarily toggles on i, m, or x options within parentheses.
(?-imx: re) Temporarily toggles off i, m, or x options within parentheses.
(?#...) Comment.
(?= re) Specifies position using a pattern. Does not have a range.
(?! re) Specifies position using pattern negation. Does not have a range.
(?> re) Matches independent pattern without backtracking.
\w Matches word characters.
Python 3
353
\W Matches nonword characters.
\s Matches whitespace. Equivalent to [\t\n\r\f].
\S Matches nonwhitespace.
\d Matches digits. Equivalent to [0-9].
\D Matches nondigits.
\A Matches beginning of string.
\Z Matches end of string. If a newline exists, it matches just before
newline.
\z Matches end of string.
\G Matches point where last match finished.
\b Matches word boundaries when outside brackets. Matches
backspace (0x08) when inside brackets.
\B Matches nonword boundaries.
\n, \t, etc. Matches newlines, carriage returns, tabs, etc.
\1...\9 Matches nth grouped subexpression.
\10 Matches nth grouped subexpression if it matched already.
Otherwise refers to the octal representation of a character code.
Regular Expression Examples
Literal characters
Example Description
python Match "python".
Python 3
354
Character classes
Example Description
[Pp]ython Match "Python" or "python"
rub[ye] Match "ruby" or "rube"
[aeiou] Match any one lowercase vowel
[0-9] Match any digit; same as [0123456789]
[a-z] Match any lowercase ASCII letter
[A-Z] Match any uppercase ASCII letter
[a-zA-Z0-9] Match any of the above
[^aeiou] Match anything other than a lowercase vowel
[^0-9] Match anything other than a digit
Special Character Classes
Example Description
. Match any character except newline
\d Match a digit: [0-9]
\D Match a nondigit: [^0-9]
\s Match a whitespace character: [ \t\r\n\f]
\S Match nonwhitespace: [^ \t\r\n\f]
\w Match a single word character: [A-Za-z0-9_]
\W Match a nonword character: [^A-Za-z0-9_]
Python 3
355
Repetition Cases
Example Description
ruby? Match "rub" or "ruby": the y is optional
ruby* Match "rub" plus 0 or more ys
ruby+ Match "rub" plus 1 or more ys
\d{3} Match exactly 3 digits
\d{3,} Match 3 or more digits
\d{3,5} Match 3, 4, or 5 digits
Nongreedy Repetition
This matches the smallest number of repetitionsExample Description
<.*> Greedy repetition: matches "<python>perl>"
<.*?> Nongreedy: matches "<python>" in "<python>perl>"
Grouping with Parentheses
Example Description
\D\d+ No group: + repeats \d
(\D\d)+ Grouped: + repeats \D\d pair
([Pp]ython(, )?)+ Match "Python", "Python, python, python", etc.
Python 3
356
Backreferences
This matches a previously matched group againExample Description
([Pp])ython&\1ails Match python&pails or Python&Pails
(['"])[^\1]*\1 Single or double-quoted string. \1 matches whatever the 1st
group matched. \2 matches whatever the 2nd group matched,
etc.
Alternatives
Example Description
python|perl Match "python" or "perl"
rub(y|le)) Match "ruby" or "ruble"
Python(!+|\?) "Python" followed by one or more ! or one ?
Anchors
This needs to specify match position.
Example Description
^Python Match "Python" at the start of a string or internal line
Python$ Match "Python" at the end of a string or line
\APython Match "Python" at the start of a string
Python\Z Match "Python" at the end of a string
\bPython\b Match "Python" at a word boundary
\brub\B \B is nonword boundary: match "rub" in "rube" and "ruby" but not
alone
Python 3
357
Python(?=!) Match "Python", if followed by an exclamation point.
Python(?!!) Match "Python", if not followed by an exclamation point.
Special Syntax with Parentheses
Example Description
R(?#comment) Matches "R". All the rest is a comment
R(?i)uby Case-insensitive while matching "uby"
R(?i:uby) Same as above
rub(?:y|le)) Group only without creating \1 backreference
Python 3
358
The Common Gateway Interface, or CGI, is a set of standards that define how information
is exchanged between the web server and a custom script. The CGI specs are currently
maintained by the NCSA and NCSA.
What is CGI?
 The Common Gateway Interface, or CGI, is a standard for external gateway
programs to interface with information servers such as HTTP servers.
 The current version is CGI/1.1 and CGI/1.2 is under progress.
Web Browsing
To understand the concept of CGI, let us see what happens when we click a hyperlink to
browse a particular web page or URL.
 Your browser contacts the HTTP web server and demands for the URL, i.e.,
filename.
 The web server parses the URL and looks for the filename. If it finds the particular
file, then it sends it back to the browser, otherwise sends an error message
indicating that you requested a wrong file.
 The web browser takes response from the web server and displays either, the
received file or error message.
However, it is possible to set up the HTTP server so that whenever a file in a certain
directory is requested that file is not sent back. Instead, it is executed as a program, and
whatever that output of the program, is sent back for your browser to display. This function
is called the Common Gateway Interface or CGI and the programs are called CGI scripts.
These CGI programs can be Python Script, PERL Script, Shell Script, C or C++ program,
etc.
21.Python 3 – CGI Programming 
Python 3
359
CGI Architecture Diagram
Web Server Support and Configuration
Before you proceed with CGI Programming, make sure that your Web Server supports CGI
and it is configured to handle CGI Programs. All the CGI Programs, which are to be
executed by the HTTP server, are kept in a pre-configured directory. This directory is called
CGI Directory and by convention it is named as /var/www/cgi-bin. By convention, CGI files
have extension as .cgi, but you can keep your files with python extension .py as well.
By default, the Linux server is configured to run only the scripts in the cgi-bin directory in
/var/www. If you want to specify any other directory to run your CGI scripts, comment
the following lines in the httpd.conf file −
<Directory "/var/www/cgi-bin">
 AllowOverride None
 Options ExecCGI
 Order allow,deny
 Allow from all
</Directory>
Python 3
360
<Directory "/var/www/cgi-bin">
Options All
</Directory>
The following line should also be added for apache server to treat .py file as cgi script.
AddHandler cgi-script .py
Here, we assume that you have Web Server up and running successfully and you are able
to run any other CGI program like Perl or Shell, etc.
First CGI Program
Here is a simple link, which is linked to a CGI script called hello.py. This file is kept in
/var/www/cgi-bin directory and it has the following content. Before running your CGI
program, make sure you have changed the mode of file using chmod 755 hello.py,
the UNIX command to make file executable.
#!/usr/bin/python3
print ("Content-type:text/html")
print()
print ("<html>")
print ('<head>')
print ('<title>Hello Word - First CGI Program</title>')
print ('</head>')
print ('<body>')
print ('<h2>Hello Word! This is my first CGI program</h2>')
print ('</body>')
print ('</html>')
Note: First line in the script must be the path to Python executable. In Linux, it should be
#!/usr/bin/python3
Enter the following URL in your browser -
http://www.tutorialspoint.com/cgi-bin/hello.py
Hello Word! This is my first CGI program
This hello.py script is a simple Python script, which writes its output on STDOUT file, i.e.,
the screen. There is one important and extra feature available that is the first line to be
printed Content-type:text/html followed by a blank line. This line is sent back to the
browser and it specifies the content type to be displayed on the browser screen.
Python 3
361
By now, you must have understood the basic concept of CGI and you can write many
complicated CGI programs using Python. This script can interact with any other external
system also to exchange information such as RDBMS.
HTTP Header
The line Content-type:text/html\r\n\r\n is part of HTTP header which is sent to the
browser to understand the content. All the HTTP header will be in the following formHTTP Field Name: Field Content
For Example
Content-type: text/html\r\n\r\n
There are few other important HTTP headers, which you will use frequently in your CGI
Programming.
Header Description
Content-type: A MIME string defining the format of the file being returned.
Example is Content-type:text/html
Expires: Date The date the information becomes invalid. It is used by the
browser to decide when a page needs to be refreshed. A valid
date string is in the format 01 Jan 1998 12:00:00 GMT.
Location: URL The URL that is returned instead of the URL requested. You
can use this field to redirect a request to any file.
Last-modified: Date The date of last modification of the resource.
Content-length: N The length, in bytes, of the data being returned. The browser
uses this value to report the estimated download time for a
file.
Set-Cookie: String Set the cookie passed through the string
CGI Environment Variables
All the CGI programs have access to the following environment variables. These variables
play an important role while writing any CGI program.
Variable Name Description
Python 3
362
CONTENT_TYPE The data type of the content. Used when the client is sending
attached content to the server. For example, file upload.
CONTENT_LENGTH The length of the query information. It is available only for
POST requests.
HTTP_COOKIE Returns the set cookies in the form of key & value pair.
HTTP_USER_AGENT The User-Agent request-header field contains information
about the user agent originating the request. It is name of
the web browser.
PATH_INFO The path for the CGI script.
QUERY_STRING The URL-encoded information that is sent with GET method
request.
REMOTE_ADDR The IP address of the remote host making the request. This
is useful logging or for authentication.
REMOTE_HOST The fully qualified name of the host making the request. If
this information is not available, then REMOTE_ADDR can be
used to get IR address.
REQUEST_METHOD The method used to make the request. The most common
methods are GET and POST.
SCRIPT_FILENAME The full path to the CGI script.
SCRIPT_NAME The name of the CGI script.
SERVER_NAME The server's hostname or IP Address
SERVER_SOFTWARE The name and version of the software the server is running.
Here is a small CGI program to list out all the CGI variables. Click this link to see the
result Get Environment.
#!/usr/bin/python3
import os
print ("Content-type: text/html")
print ()
print ("<font size=+1>Environment</font><\br>";)
Python 3
363
for param in os.environ.keys():
 print ("<b>%20s</b>: %s<\br>" % (param, os.environ[param]))
GET and POST Methods
You must have come across many situations when you need to pass some information
from your browser to web server and ultimately to your CGI Program. Most frequently, a
browser uses two methods to pass this information to the web server. These methods are
GET Method and POST Method.
Passing Information using GET method
The GET method sends the encoded user information appended to the page request. The
page and the encoded information are separated by the ? character as followshttp://www.test.com/cgi-bin/hello.py?key1=value1&key2=value2
 The GET method is the default method to pass information from the browser to the
web server and it produces a long string that appears in your browser's
Location:box.
 Never use GET method if you have password or other sensitive information to pass
to the server.
 The GET method has size limtation: only 1024 characters can be sent in a request
string.
 The GET method sends information using QUERY_STRING header and will be
accessible in your CGI Program through QUERY_STRING environment variable.
You can pass information by simply concatenating key and value pairs along with any URL
or you can use HTML <FORM> tags to pass information using GET method.
Simple URL Example–GetMethod
Here is a simple URL, which passes two values to hello_get.py program using GET method.
/cgi-bin/hello_get.py?first_name=Malhar&last_name=Lathkar
Given below is the hello_get.py script to handle the input given by web browser. We are
going to use the cgi module, which makes it very easy to access the passed information-
#!/usr/bin/python3
# Import modules for CGI handling
import cgi, cgitb
# Create instance of FieldStorage
form = cgi.FieldStorage()
Python 3
364
# Get data from fields
first_name = form.getvalue('first_name')
last_name = form.getvalue('last_name')
print ("Content-type:text/html")
print()
print ("<html>)"
print ("<head>")
print ("<title>Hello - Second CGI Program</title>")
print ("</head>")
print ("<body>")
print ("<h2>Hello %s %s</h2>" % (first_name, last_name))
print ("</body>")
print ("</html>">)
This would generate the following resultHello ZARA ALI
Simple FORM Example–GETMethod
This example passes two values using HTML FORM and submit button. We use the same
CGI script hello_get.py to handle this input.
<form action="/cgi-bin/hello_get.py" method="get">
First Name: <input type="text" name="first_name"> <br />
Last Name: <input type="text" name="last_name" />
<input type="submit" value="Submit" />
</form>
Here is the actual output of the above form, you enter the First and the Last Name and
then click submit button to see the result.
First Name:
Last Name:
Submit
Passing Information Using POST Method
Python 3
365
A generally more reliable method of passing information to a CGI program is the POST
method. This packages the information in exactly the same way as the GET methods, but
instead of sending it as a text string after a ? in the URL, it sends it as a separate message.
This message comes into the CGI script in the form of the standard input.
Given below is same hello_get.py script, which handles GET as well as the POST method.
#!/usr/bin/python3
# Import modules for CGI handling
import cgi, cgitb
# Create instance of FieldStorage
form = cgi.FieldStorage()
# Get data from fields
first_name = form.getvalue('first_name')
last_name = form.getvalue('last_name')
print ("Content-type:text/html")
print()
print ("<html>")
print ("<head>")
print ("<title>Hello - Second CGI Program</title>")
print ("</head>")
print ("<body>")
print ("<h2>Hello %s %s</h2>" % (first_name, last_name))
print ("</body>")
print ("</html>")
Let us again take the same example as above, which passes two values using the HTML
FORM and the submit button. We use the same CGI script hello_get.py to handle this
input.
<form action="/cgi-bin/hello_get.py" method="post">
First Name: <input type="text" name="first_name"><br />
Last Name: <input type="text" name="last_name" />
<input type="submit" value="Submit" />
</form>
Python 3
366
Here is the actual output of the above form. You enter the First and the Last Name and
then click the submit button to see the result.
First Name:
Last Name:
Submit
Passing Checkbox Data to CGI Program
Checkboxes are used when more than one option is required to be selected.
Here is an HTML code example for a form with two checkboxes-
<form action="/cgi-bin/checkbox.py" method="POST" target="_blank">
<input type="checkbox" name="maths" value="on" /> Maths
<input type="checkbox" name="physics" value="on" /> Physics
<input type="submit" value="Select Subject" />
</form>
The result of this code is in the above formMaths Physics
Select Subject
Given below is the checkbox.cgi script to handle the input given by web browser for
checkbox button.
#!/usr/bin/python3
# Import modules for CGI handling
import cgi, cgitb
# Create instance of FieldStorage
form = cgi.FieldStorage()
# Get data from fields
if form.getvalue('maths'):
 math_flag = "ON"
else:
 math_flag = "OFF"
if form.getvalue('physics'):
 physics_flag = "ON"
else:
Python 3
367
 physics_flag = "OFF"
print ("Content-type:text/html")
print()
print ("<html>")
print ("<head>")
print ("<title>Checkbox - Third CGI Program</title>")
print ("</head>")
print ("<body>")
print ("<h2> CheckBox Maths is : %s</h2>" % math_flag)
print ("<h2> CheckBox Physics is : %s</h2>" % physics_flag)
print ("</body>")
print ("</html>")
Passing Radio Button Data to CGI Program
Radio Buttons are used when only one option is required to be selected.
Here is an HTML code example for a form with two radio buttons-
<form action="/cgi-bin/radiobutton.py" method="post" target="_blank">
<input type="radio" name="subject" value="maths" /> Maths
<input type="radio" name="subject" value="physics" /> Physics
<input type="submit" value="Select Subject" />
</form>
The result of this code is the following formMaths Physics
Select Subject
Below is radiobutton.py script to handle input given by web browser for radio button-
#!/usr/bin/python3
# Import modules for CGI handling
import cgi, cgitb
# Create instance of FieldStorage
form = cgi.FieldStorage()
# Get data from fields
if form.getvalue('subject'):
Python 3
368
 subject = form.getvalue('subject')
else:
 subject = "Not set"
print "Content-type:text/html")
print()
print ("<html>")
print ("<head>")
print ("<title>Radio - Fourth CGI Program</title>")
print ("</head>")
print ("<body>")
print ("<h2> Selected Subject is %s</h2>" % subject)
print ("</body>")
print ("</html>")
Passing Text Area Data to CGI Program
TEXTAREA element is used when multiline text has to be passed to the CGI Program.
Here is an HTML code example for a form with a TEXTAREA box-
<form action="/cgi-bin/textarea.py" method="post" target="_blank">
<textarea name="textcontent" cols="40" rows="4">
Type your text here...
</textarea>
<input type="submit" value="Submit" />
</form>
The result of this code is the following formSubmit
Given below is the textarea.cgi script to handle input given by web browser-
#!/usr/bin/python3
# Import modules for CGI handling
import cgi, cgitb
# Create instance of FieldStorage 
Python 3
369
form = cgi.FieldStorage()
# Get data from fields
if form.getvalue('textcontent'):
 text_content = form.getvalue('textcontent')
else:
 text_content = "Not entered"
print "Content-type:text/html")
print()
print ("<html>")
print ("<head>";)
print ("<title>Text Area - Fifth CGI Program</title>")
print ("</head>")
print ("<body>")
print ("<h2> Entered Text Content is %s</h2>" % text_content)
print ("</body>")
Passing Drop Down Box Data to CGI Program
The Drop-Down Box is used when we have many options available but only one or two are
selected.
Here is an HTML code example for a form with one drop-down box-
<form action="/cgi-bin/dropdown.py" method="post" target="_blank">
<select name="dropdown">
<option value="Maths" selected>Maths</option>
<option value="Physics">Physics</option>
</select>
<input type="submit" value="Submit"/>
</form>
The result of this code is the following form-

Maths Submit
Following is the dropdown.py script to handle the input given by web browser.
#!/usr/bin/python3
# Import modules for CGI handling
import cgi, cgitb 
Python 3
370
# Create instance of FieldStorage
form = cgi.FieldStorage()
# Get data from fields
if form.getvalue('dropdown'):
 subject = form.getvalue('dropdown')
else:
 subject = "Not entered"
print "Content-type:text/html")
print()
print ("<html>")
print ("<head>")
print ("<title>Dropdown Box - Sixth CGI Program</title>")
print ("</head>")
print ("<body>")
print ("<h2> Selected Subject is %s</h2>" % subject)
print ("</body>")
print ("</html>")
Using Cookies in CGI
HTTP protocol is a stateless protocol. For a commercial website, it is required to maintain
session information among different pages. For example, one user registration ends after
completing many pages. How to maintain user's session information across all the web
pages?
In many situations, using cookies is the most efficient method of remembering and
tracking preferences, purchases, commissions, and other information required for better
visitor experience or site statistics.
How It Works?
Your server sends some data to the visitor's browser in the form of a cookie. The browser
may accept the cookie. If it does, it is stored as a plain text record on the visitor's hard
drive. Now, when the visitor arrives at another page on your site, the cookie is available
for retrieval. Once retrieved, your server knows/remembers what was stored.
Cookies are a plain text data record of five variable-length fields-
 Expires: The date the cookie will expire. If this is blank, the cookie will expire when
the visitor quits the browser.
Python 3
371
 Domain: The domain name of your site.
 Path: The path to the directory or web page that sets the cookie. This may be
blank if you want to retrieve the cookie from any directory or page.
 Secure: If this field contains the word "secure", then the cookie may only be
retrieved with a secure server. If this field is blank, no such restriction exists.
 Name=Value: Cookies are set and retrieved in the form of key and value pairs.
Setting up Cookies
It is very easy to send cookies to the browser. These cookies are sent along with the HTTP
Header before the Content-type field is sent. Assuming you want to set the User ID and
Password as cookies, Cookies are set as follows-
#!/usr/bin/python3
print ("Set-Cookie:UserID=XYZ;\r\n")
print ("Set-Cookie:Password=XYZ123;\r\n")
print ("Set-Cookie:Expires=Tuesday, 31-Dec-2007 23:12:40 GMT";\r\n")
print ("Set-Cookie:Domain=www.tutorialspoint.com;\r\n")
print ("Set-Cookie:Path=/perl;\n")
print ("Content-type:text/html\r\n\r\n")
...........Rest of the HTML Content....
From this example, you must have understood how to set cookies. We use SetCookie HTTP header to set the cookies.
It is optional to set cookies attributes like Expires, Domain, and Path. It is notable that the
cookies are set before sending the magic line "Content-type:text/html\r\n\r\n.
Retrieving Cookies
It is very easy to retrieve all the set cookies. Cookies are stored in CGI environment
variable HTTP_COOKIE and they will have the following formkey1=value1;key2=value2;key3=value3....
Here is an example of how to retrieve cookies-
#!/usr/bin/python3
# Import modules for CGI handling
from os import environ
import cgi, cgitb
Python 3
372
if environ.has_key('HTTP_COOKIE'):
 for cookie in map(strip, split(environ['HTTP_COOKIE'], ';')):
 (key, value ) = split(cookie, '=');
 if key == "UserID":
 user_id = value
 if key == "Password":
 password = value
print ("User ID = %s" % user_id)
print ("Password = %s" % password)
This produces the following result for the cookies set by the above scriptUser ID = XYZ
Password = XYZ123
File Upload Example
To upload a file, the HTML form must have the enctype attribute set to multipart/formdata. The input tag with the file type creates a "Browse" button.
<html>
<body>
 <form enctype="multipart/form-data"
 action="save_file.py" method="post">
 <p>File: <input type="file" name="filename" /></p>
 <p><input type="submit" value="Upload" /></p>
 </form>
</body>
</html>
The result of this code is the following formFile:
Upload
The above example has been disabled intentionally to save the people from uploading the
file on our server, but you can try the above code with your server.
Python 3
373
Here is the script save_file.py to handle file upload-
#!/usr/bin/python3
import cgi, os
import cgitb; cgitb.enable()
form = cgi.FieldStorage()
# Get filename here.
fileitem = form['filename']
# Test if the file was uploaded
if fileitem.filename:
 # strip leading path from file name to avoid
 # directory traversal attacks
 fn = os.path.basename(fileitem.filename)
 open('/tmp/' + fn, 'wb').write(fileitem.file.read())
 message = 'The file "' + fn + '" was uploaded successfully'

else:
 message = 'No file was uploaded'

print ("""\
Content-Type: text/html\n
<html>
<body>
 <p>%s</p>
</body>
</html>
""" % (message,))
If you run the above script on Unix/Linux, then you need to take care of replacing file
separator as follows, otherwise on your windows machine above open() statement should
work fine.
Python 3
374
fn = os.path.basename(fileitem.filename.replace("\\", "/" ))
How To Raise a "File Download" Dialog Box ?
Sometimes, it is desired that you want to give an option where a user can click a link and
it will pop up a "File Download" dialogue box to the user instead of displaying actual
content. This is very easy and can be achieved through HTTP header. This HTTP header is
different from the header mentioned in the previous section.
For example, if you want make a FileName file downloadable from a given link, then its
syntax is as follows-
#!/usr/bin/python3
# HTTP Header
print ("Content-Type:application/octet-stream; name=\"FileName\"\r\n")
print ("Content-Disposition: attachment; filename=\"FileName\"\r\n\n")
# Actual File Content will go hear.
fo = open("foo.txt", "rb")
str = fo.read()
print (str)
# Close opened file
fo.close()
Python 3
375
The Python standard for database interfaces is the Python DB-API. Most Python database
interfaces adhere to this standard.
You can choose the right database for your application. Python Database API supports a
wide range of database servers such as −
 GadFly
 mSQL
 MySQL
 PostgreSQL
 Microsoft SQL Server 2000
 Informix
 Interbase
 Oracle
 Sybase
 SQLite
Here is the list of available Python database interfaces: Python Database Interfaces and
APIs. You must download a separate DB API module for each database you need to access.
For example, if you need to access an Oracle database as well as a MySQL database, you
must download both the Oracle and the MySQL database modules.
The DB API provides a minimal standard for working with databases using Python
structures and syntax wherever possible. This API includes the following:
 Importing the API module.
 Acquiring a connection with the database.
 Issuing SQL statements and stored procedures.
 Closing the connection
Python has an in-built support for SQLite. In this section, we would learn all the concepts
using MySQL. MySQLdb module, a popular interface with MySQL is not compatible with
Python 3. Instead, we shall use PyMySQL module.
What is PyMySQL ?
PyMySQL is an interface for connecting to a MySQL database server from Python. It
implements the Python Database API v2.0 and contains a pure-Python MySQL client
library. The goal of PyMySQL is to be a drop-in replacement for MySQLdb .
22.Python 3 – MySQL Database Access 
Python 3
376
Howdo I Install PyMySQL?
Before proceeding further, you make sure you have PyMySQL installed on your machine.
Just type the following in your Python script and execute it-
#!/usr/bin/python3
import PyMySQL
If it produces the following result, then it means MySQLdb module is not installedTraceback (most recent call last):
 File “test.py”, line 3, in <module>
 Import PyMySQL
ImportError: No module named PyMySQL
The last stable release is available on PyPI and can be installed with pip:
pip install PyMySQL
Alternatively (e.g. if pip is not available), a tarball can be downloaded from GitHub and
installed with Setuptools as follows-
$ # X.X is the desired PyMySQL version (e.g. 0.5 or 0.6).
$ curl -L https://github.com/PyMySQL/PyMySQL/tarball/pymysql-X.X | tar xz
$ cd PyMySQL*
$ python setup.py install
$ # The folder PyMySQL* can be safely removed now.
Note: Make sure you have root privilege to install the above module.
Database Connection
Before connecting to a MySQL database, make sure of the following points-
 You have created a database TESTDB.
 You have created a table EMPLOYEE in TESTDB.
 This table has fields FIRST_NAME, LAST_NAME, AGE, SEX and INCOME.
 User ID "testuser" and password "test123" are set to access TESTDB.
 Python module PyMySQL is installed properly on your machine.
 You have gone through MySQL tutorial to understand MySQL Basics.
Python 3
377
Example
Following is an example of connecting with MySQL database "TESTDB"-
#!/usr/bin/python3
import PyMySQL
# Open database connection
db = PyMySQL.connect("localhost","testuser","test123","TESTDB" )
# prepare a cursor object using cursor() method
cursor = db.cursor()
# execute SQL query using execute() method.
cursor.execute("SELECT VERSION()")
# Fetch a single row using fetchone() method.
data = cursor.fetchone()
print ("Database version : %s " % data)
# disconnect from server
db.close()
While running this script, it produces the following resultDatabase version : 5.5.20-log
If a connection is established with the datasource, then a Connection Object is returned
and saved into db for further use, otherwise db is set to None. Next, db object is used to
create a cursor object, which in turn is used to execute SQL queries. Finally, before
coming out, it ensures that the database connection is closed and resources are released.
Creating Database Table
Once a database connection is established, we are ready to create tables or records into
the database tables using execute method of the created cursor.
Example
Let us create a Database table EMPLOYEE-
#!/usr/bin/python3
import PyMySQL
Python 3
378
# Open database connection
db = PyMySQL.connect("localhost","testuser","test123","TESTDB" )
# prepare a cursor object using cursor() method
cursor = db.cursor()
# Drop table if it already exist using execute() method.
cursor.execute("DROP TABLE IF EXISTS EMPLOYEE")
# Create table as per requirement
sql = """CREATE TABLE EMPLOYEE (
 FIRST_NAME CHAR(20) NOT NULL,
 LAST_NAME CHAR(20),
 AGE INT,
 SEX CHAR(1),
 INCOME FLOAT )"""
cursor.execute(sql)
# disconnect from server
db.close()
INSERT Operation
The INSERT Operation is required when you want to create your records into a database
table.
Example
The following example, executes SQL INSERT statement to create a record in the
EMPLOYEE table-
#!/usr/bin/python3
import PyMySQL
# Open database connection
db = PyMySQL.connect("localhost","testuser","test123","TESTDB" )
# prepare a cursor object using cursor() method
Python 3
379
cursor = db.cursor()
# Prepare SQL query to INSERT a record into the database.
sql = """INSERT INTO EMPLOYEE(FIRST_NAME,
 LAST_NAME, AGE, SEX, INCOME)
 VALUES ('Mac', 'Mohan', 20, 'M', 2000)"""
try:
 # Execute the SQL command
 cursor.execute(sql)
 # Commit your changes in the database
 db.commit()
except:
 # Rollback in case there is any error
 db.rollback()
# disconnect from server
db.close()
The above example can be written as follows to create SQL queries dynamically-
#!/usr/bin/python3
import PyMySQL
# Open database connection
db = PyMySQL.connect("localhost","testuser","test123","TESTDB" )
# prepare a cursor object using cursor() method
cursor = db.cursor()
# Prepare SQL query to INSERT a record into the database.
sql = "INSERT INTO EMPLOYEE(FIRST_NAME, \
 LAST_NAME, AGE, SEX, INCOME) \
 VALUES ('%s', '%s', '%d', '%c', '%d' )" % \
 ('Mac', 'Mohan', 20, 'M', 2000)
try:
 # Execute the SQL command
 cursor.execute(sql)
 # Commit your changes in the database
 db.commit()
Python 3
380
except:
 # Rollback in case there is any error
 db.rollback()
# disconnect from server
db.close()
Example
The following code segment is another form of execution where you can pass parameters
directly-
..................................
user_id = "test123"
password = "password"
con.execute('insert into Login values("%s", "%s")' % \
 (user_id, password))
..................................
READ Operation
READ Operation on any database means to fetch some useful information from the
database.
Once the database connection is established, you are ready to make a query into this
database. You can use either fetchone() method to fetch a single record
or fetchall() method to fetch multiple values from a database table.
 fetchone(): It fetches the next row of a query result set. A result set is an object
that is returned when a cursor object is used to query a table.
 fetchall(): It fetches all the rows in a result set. If some rows have already been
extracted from the result set, then it retrieves the remaining rows from the result
set.
 rowcount: This is a read-only attribute and returns the number of rows that were
affected by an execute() method.
Python 3
381
Example
The following procedure queries all the records from EMPLOYEE table having salary more
than 1000-
#!/usr/bin/python3
import PyMySQL
# Open database connection
db = PyMySQL.connect("localhost","testuser","test123","TESTDB" )
# prepare a cursor object using cursor() method
cursor = db.cursor()
# Prepare SQL query to INSERT a record into the database.
sql = "SELECT * FROM EMPLOYEE \
 WHERE INCOME > '%d'" % (1000)
try:
 # Execute the SQL command
 cursor.execute(sql)
 # Fetch all the rows in a list of lists.
 results = cursor.fetchall()
 for row in results:
 fname = row[0]
 lname = row[1]
 age = row[2]
 sex = row[3]
 income = row[4]
 # Now print fetched result
 print ("fname=%s,lname=%s,age=%d,sex=%s,income=%d" % \
 (fname, lname, age, sex, income ))
except:
 print ("Error: unable to fecth data")
# disconnect from server
db.close()
Python 3
382
This will produce the following resultfname=Mac, lname=Mohan, age=20, sex=M, income=2000
Update Operation
UPDATE Operation on any database means to update one or more records, which are
already available in the database.
The following procedure updates all the records having SEX as 'M'. Here, we increase the
AGE of all the males by one year.
Example
#!/usr/bin/python3
import PyMySQL
# Open database connection
db = PyMySQL.connect("localhost","testuser","test123","TESTDB" )
# prepare a cursor object using cursor() method
cursor = db.cursor()
# Prepare SQL query to UPDATE required records
sql = "UPDATE EMPLOYEE SET AGE = AGE + 1
 WHERE SEX = '%c'" % ('M')
try:
 # Execute the SQL command
 cursor.execute(sql)
 # Commit your changes in the database
 db.commit()
except:
 # Rollback in case there is any error
 db.rollback()
# disconnect from server
db.close()
Python 3
383
DELETE Operation
DELETE operation is required when you want to delete some records from your database.
Following is the procedure to delete all the records from EMPLOYEE where AGE is more
than 20-
Example
#!/usr/bin/python3
import PyMySQL
# Open database connection
db = PyMySQL.connect("localhost","testuser","test123","TESTDB" )
# prepare a cursor object using cursor() method
cursor = db.cursor()
# Prepare SQL query to DELETE required records
sql = "DELETE FROM EMPLOYEE WHERE AGE > '%d'" % (20)
try:
 # Execute the SQL command
 cursor.execute(sql)
 # Commit your changes in the database
 db.commit()
except:
 # Rollback in case there is any error
 db.rollback()
# disconnect from server
db.close()
Performing Transactions
Transactions are a mechanism that ensure data consistency. Transactions have the
following four properties-
 Atomicity: Either a transaction completes or nothing happens at all.
 Consistency: A transaction must start in a consistent state and leave the system
in a consistent state.
 Isolation: Intermediate results of a transaction are not visible outside the current
transaction.
Python 3
384
 Durability: Once a transaction was committed, the effects are persistent, even
after a system failure.
The Python DB API 2.0 provides two methods to either commit or rollback a transaction.
Example
You already know how to implement transactions. Here is a similar example-
# Prepare SQL query to DELETE required records
sql = "DELETE FROM EMPLOYEE WHERE AGE > '%d'" % (20)
try:
 # Execute the SQL command
 cursor.execute(sql)
 # Commit your changes in the database
 db.commit()
except:
 # Rollback in case there is any error
 db.rollback()
COMMIT Operation
Commit is an operation, which gives a green signal to the database to finalize the changes,
and after this operation, no change can be reverted back.
Here is a simple example to call the commit method.
db.commit()
ROLLBACK Operation
If you are not satisfied with one or more of the changes and you want to revert back those
changes completely, then use the rollback() method.
Here is a simple example to call the rollback() method.
db.rollback()
Disconnecting Database
To disconnect the Database connection, use the close() method.
db.close()
If the connection to a database is closed by the user with the close() method, any
outstanding transactions are rolled back by the DB. However, instead of depending on any 
Python 3
385
of the DB lower level implementation details, your application would be better off calling
commit or rollback explicitly.
Handling Errors
There are many sources of errors. A few examples are a syntax error in an executed SQL
statement, a connection failure, or calling the fetch method for an already cancelled or
finished statement handle.
The DB API defines a number of errors that must exist in each database module. The
following table lists these exceptions.
Exception Description
Warning Used for non-fatal issues. Must subclass StandardError.
Error Base class for errors. Must subclass StandardError.
InterfaceError Used for errors in the database module, not the database itself.
Must subclass Error.
DatabaseError Used for errors in the database. Must subclass Error.
DataError Subclass of DatabaseError that refers to errors in the data.
OperationalError Subclass of DatabaseError that refers to errors such as the loss of
a connection to the database. These errors are generally outside
of the control of the Python scripter.
IntegrityError Subclass of DatabaseError for situations that would damage the
relational integrity, such as uniqueness constraints or foreign
keys.
InternalError Subclass of DatabaseError that refers to errors internal to the
database module, such as a cursor no longer being active.
ProgrammingError Subclass of DatabaseError that refers to errors such as a bad table
name and other things that can safely be blamed on you.
NotSupportedError Subclass of DatabaseError that refers to trying to call unsupported
functionality.
Python 3
386
Your Python scripts should handle these errors, but before using any of the above
exceptions, make sure your MySQLdb has support for that exception. You can get more
information about them by reading the DB API 2.0 specification.
Python 3
387
Python provides two levels of access to the network services. At a low level, you can access
the basic socket support in the underlying operating system, which allows you to
implement clients and servers for both connection-oriented and connectionless protocols.
Python also has libraries that provide higher-level access to specific application-level
network protocols, such as FTP, HTTP, and so on.
This chapter gives you an understanding on the most famous concept in Networking -
Socket Programming.
What is Sockets?
Sockets are the endpoints of a bidirectional communications channel. Sockets may
communicate within a process, between processes on the same machine, or between
processes on different continents.
Sockets may be implemented over a number of different channel types: Unix domain
sockets, TCP, UDP, and so on. The socket library provides specific classes for handling the
common transports as well as a generic interface for handling the rest.
Sockets have their own vocabularyTerm Description
domain The family of protocols that is used as the transport mechanism. These
values are constants such as AF_INET, PF_INET, PF_UNIX, PF_X25,
and so on.
type The type of communications between the two endpoints, typically
SOCK_STREAM for connection-oriented protocols and SOCK_DGRAM
for connectionless protocols.
protocol Typically zero, this may be used to identify a variant of a protocol
within a domain and type.
hostname The identifier of a network interface:
A string, which can be a host name, a dotted-quad address, or an IPV6
address in colon (and possibly dot) notation
A string "<broadcast>", which specifies an INADDR_BROADCAST
address.
A zero-length string, which specifies INADDR_ANY, or
23.Python 3 – Network Programming 
Python 3
388
An Integer, interpreted as a binary address in host byte order.
port Each server listens for clients calling on one or more ports. A port may
be a Fixnum port number, a string containing a port number, or the
name of a service.
The socket Module
To create a socket, you must use the socket.socket() function available in the
socket module, which has the general syntaxs = socket.socket (socket_family, socket_type, protocol=0)
Here is the description of the parameters-
 socket_family: This is either AF_UNIX or AF_INET, as explained earlier.
 socket_type: This is either SOCK_STREAM or SOCK_DGRAM.
 protocol: This is usually left out, defaulting to 0.
Once you have socket object, then you can use the required functions to create your client
or server program. Following is the list of functions requiredServer Socket Methods
Method Description
s.bind() This method binds address (hostname, port number pair) to socket.
s.listen() This method sets up and start TCP listener.
s.accept() This passively accept TCP client connection, waiting until connection
arrives (blocking).
Client Socket Methods
Method Description
s.connect() This method actively initiates TCP server connection.
Python 3
389
General Socket Methods
Method Description
s.recv() This method receives TCP message
s.send() This method transmits TCP message
s.recvfrom() This method receives UDP message
s.sendto() This method transmits UDP message
s.close() This method closes socket
socket.gethostname() Returns the hostname.
A Simple Server
To write Internet servers, we use the socket function available in socket module to create
a socket object. A socket object is then used to call other functions to setup a socket
server.
Now call the bind(hostname, port) function to specify a port for your service on the
given host.
Next, call the accept method of the returned object. This method waits until a client
connects to the port you specified, and then returns a connection object that represents
the connection to that client.
#!/usr/bin/python3 # This is server.py file
import socket
# create a socket object
serversocket = socket.socket(
 socket.AF_INET, socket.SOCK_STREAM)
# get local machine name
host = socket.gethostname()
port = 9999 
Python 3
390
# bind to the port
serversocket.bind((host, port))
# queue up to 5 requests
serversocket.listen(5)
while True:
 # establish a connection
 clientsocket,addr = serversocket.accept()
 print("Got a connection from %s" % str(addr))

 msg='Thank you for connecting'+ "\r\n"
 clientsocket.send(msg.encode('ascii'))
 clientsocket.close()
A Simple Client
Let us write a very simple client program, which opens a connection to a given port 12345
and a given host. It is very simple to create a socket client using the
Python's socket module function.
The socket.connect(hosname, port ) opens a TCP connection to hostname on the port.
Once you have a socket open, you can read from it like any IO object. When done,
remember to close it, as you would close a file.
The following code is a very simple client that connects to a given host and port, reads
any available data from the socket, and then exits-
#!/usr/bin/python3 # This is client.py file
import socket
# create a socket object
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# get local machine name
host = socket.gethostname()
port = 9999
# connection to hostname on the port.
s.connect((host, port))
# Receive no more than 1024 bytes
msg = s.recv(1024)
s.close()
Python 3
391
print (msg.decode('ascii'))
Now run this server.py in the background and then run the above client.py to see the
result.
# Following would start a server in background.
$ python server.py &
# Once server is started run client as follows:
$ python client.py
This would produce the following resulton server terminal
Got a connection from ('192.168.1.10', 3747)
On client terminal
Thank you for connecting
Python Internet Modules
A list of some important modules in Python Network/Internet programming are given
below.
Protocol Common function Port No Python module
HTTP Web pages 80 httplib, urllib, xmlrpclib
NNTP Usenet news 119 nntplib
FTP File transfers 20 ftplib, urllib
SMTP Sending email 25 smtplib
POP3 Fetching email 110 poplib
IMAP4 Fetching email 143 imaplib
Telnet Command lines 23 telnetlib
Gopher Document transfers 70 gopherlib, urllib
Python 3
392
Please check all the libraries mentioned above to work with FTP, SMTP, POP, and IMAP
protocols.
Further Readings
This was a quick start with the Socket Programming. It is a vast subject. It is
recommended to go through the following link to find more detail-
 Unix Socket Programming.
 Python Socket Library and Modules.
Python 3
393
Simple Mail Transfer Protocol (SMTP) is a protocol, which handles sending an e-mail and
routing e-mail between mail servers.
Python provides smtplib module, which defines an SMTP client session object that can be
used to send mails to any Internet machine with an SMTP or ESMTP listener daemon.
Here is a simple syntax to create one SMTP object, which can later be used to send an emailimport smtplib
smtpObj = smtplib.SMTP( [host [, port [, local_hostname]]] )
Here is the detail of the parameters-
 host: This is the host running your SMTP server. You can specifiy IP address of the
host or a domain name like tutorialspoint.com. This is an optional argument.
 port: If you are providing host argument, then you need to specify a port, where
SMTP server is listening. Usually this port would be 25.
 local_hostname: If your SMTP server is running on your local machine, then you
can specify just localhost as the option.
An SMTP object has an instance method called sendmail, which is typically, used to do
the work of mailing a message. It takes three parameters-
 The sender - A string with the address of the sender.
 The receivers - A list of strings, one for each recipient.
 The message - A message as a string formatted as specified in the various RFCs.
Example
Here is a simple way to send one e-mail using Python script. Try it once-
#!/usr/bin/python3
import smtplib
sender ='from@fromdomain.com'
receivers =['to@todomain.com']
message ="""From: From Person <from@fromdomain.com>
To: To Person <to@todomain.com>
Subject: SMTP e-mail test
24.Python 3 – Sending Email using SMTP
Python 3
394
This is a test e-mail message.
"""
try:
 smtpObj = smtplib.SMTP('localhost')
 smtpObj.sendmail(sender, receivers, message)
print ("Successfully sent email")
except smtplib.SMTPException:
print ("Error: unable to send email")
Here, you have placed a basic e-mail in message, using a triple quote, taking care to
format the headers correctly. An e-mail requires a From, To, and a Subject header,
separated from the body of the e-mail with a blank line.
To send the mail you use smtpObj to connect to the SMTP server on the local machine.
Then use the sendmail method along with the message, the from address, and the
destination address as parameters (even though the from and to addresses are within the
e-mail itself, these are not always used to route the mail).
If you are not running an SMTP server on your local machine, you can the usesmtplib client
to communicate with a remote SMTP server. Unless you are using a webmail service (such
as gmail or Yahoo! Mail), your e-mail provider must have provided you with the outgoing
mail server details that you can supply them, as followsmail=smtplib.SMTP('smtp.gmail.com', 587)
Sending an HTML e-mail using Python
When you send a text message using Python, then all the content is treated as simple
text. Even if you include HTML tags in a text message, it is displayed as simple text and
HTML tags will not be formatted according to the HTML syntax. However, Python provides
an option to send an HTML message as actual HTML message.
While sending an e-mail message, you can specify a Mime version, content type and the
character set to send an HTML e-mail.
Example
Following is an example to send the HTML content as an e-mail. Try it once-
#!/usr/bin/python3
import smtplib
message = """From: From Person <from@fromdomain.com>
To: To Person <to@todomain.com>
Python 3
395
MIME-Version: 1.0
Content-type: text/html
Subject: SMTP HTML e-mail test
This is an e-mail message to be sent in HTML format
<b>This is HTML message.</b>
<h1>This is headline.</h1>
"""
try:
 smtpObj = smtplib.SMTP('localhost')
 smtpObj.sendmail(sender, receivers, message)
 print "Successfully sent email"
except SMTPException:
 print "Error: unable to send email"
Sending Attachments as an E-mail
To send an e-mail with mixed content requires setting the Content-type header to
multipart/mixed. Then, the text and the attachment sections can be specified within
boundaries.
A boundary is started with two hyphens followed by a unique number, which cannot appear
in the message part of the e-mail. A final boundary denoting the e-mail's final section must
also end with two hyphens.
The attached files should be encoded with the pack("m") function to have base 64
encoding before transmission.
Example
Following is an example, which sends a file /tmp/test.txt as an attachment. Try it once-
#!/usr/bin/python3
import smtplib
import base64
filename = "/tmp/test.txt"
# Read a file and encode it into base64 format
fo = open(filename, "rb")
filecontent = fo.read()
Python 3
396
encodedcontent = base64.b64encode(filecontent) # base64
sender = 'webmaster@tutorialpoint.com'
reciever = 'amrood.admin@gmail.com'
marker = "AUNIQUEMARKER"
body ="""
This is a test email to send an attachement.
"""
# Define the main headers.
part1 = """From: From Person <me@fromdomain.net>
To: To Person <amrood.admin@gmail.com>
Subject: Sending Attachement
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=%s
--%s
""" % (marker, marker)
# Define the message action
part2 = """Content-Type: text/plain
Content-Transfer-Encoding:8bit
%s
--%s
""" % (body,marker)
# Define the attachment section
part3 = """Content-Type: multipart/mixed; name=\"%s\"
Content-Transfer-Encoding:base64
Content-Disposition: attachment; filename=%s
%s
--%s--
""" %(filename, filename, encodedcontent, marker)
message = part1 + part2 + part3
try:
 smtpObj = smtplib.SMTP('localhost')
 smtpObj.sendmail(sender, reciever, message)
Python 3
397
 print ("Successfully sent email")
except Exception:
 print ("Error: unable to send email")
Python 3
398
Running several threads is similar to running several different programs concurrently, but
with the following benefits-
 Multiple threads within a process share the same data space with the main thread
and can therefore share information or communicate with each other more easily
than if they were separate processes.
 Threads are sometimes called light-weight processes and they do not require much
memory overhead; they are cheaper than processes.
A thread has a beginning, an execution sequence, and a conclusion. It has an instruction
pointer that keeps track of where within its context is it currently running.
 It can be pre-empted (interrupted).
 It can temporarily be put on hold (also known as sleeping) while other threads are
running - this is called yielding.
There are two different kind of threads-
 kernel thread
 user thread
Kernel Threads are a part of the operating system, while the User-space threads are not
implemented in the kernel.
There are two modules, which support the usage of threads in Python3-
 _thread
 threading
The thread module has been "deprecated" for quite a long time. Users are encouraged to
use the threading module instead. Hence, in Python 3, the module "thread" is not available
anymore. However, it has been renamed to "_thread" for backward compatibilities in
Python3.
Starting a New Thread
To spawn another thread, you need to call the following method available in the thread
module-
_thread.start_new_thread ( function, args[, kwargs] )
This method call enables a fast and efficient way to create new threads in both Linux and
Windows.
The method call returns immediately and the child thread starts and calls function with
the passed list of agrs. When the function returns, the thread terminates.
25.Python 3 – Multithreaded Programming 
Python 3
399
Here, args is a tuple of arguments; use an empty tuple to call function without passing
any arguments. kwargs is an optional dictionary of keyword arguments.
Example
#!/usr/bin/python3
import _thread
import time
# Define a function for the thread
def print_time( threadName, delay):
 count = 0
 while count < 5:
 time.sleep(delay)
 count += 1
 print ("%s: %s" % ( threadName, time.ctime(time.time()) ))
# Create two threads as follows
try:
 _thread.start_new_thread( print_time, ("Thread-1", 2, ) )
 _thread.start_new_thread( print_time, ("Thread-2", 4, ) )
except:
 print ("Error: unable to start thread")
while 1:
 pass
When the above code is executed, it produces the following resultThread-1: Fri Feb 19 09:41:39 2016
Thread-2: Fri Feb 19 09:41:41 2016
Thread-1: Fri Feb 19 09:41:41 2016
Thread-1: Fri Feb 19 09:41:43 2016
Thread-2: Fri Feb 19 09:41:45 2016
Thread-1: Fri Feb 19 09:41:45 2016
Thread-1: Fri Feb 19 09:41:47 2016
Thread-2: Fri Feb 19 09:41:49 2016
Thread-2: Fri Feb 19 09:41:53 2016
Python 3
400
Program goes in an infinite loop. You will have to press ctrl-c to stop.
Although it is very effective for low-level threading, the thread module is very limited
compared to the newer threading module.
The Threading Module
The newer threading module included with Python 2.4 provides much more powerful, highlevel support for threads than the thread module discussed in the previous section.
The threading module exposes all the methods of the thread module and provides some
additional methods:
 threading.activeCount(): Returns the number of thread objects that are active.
 threading.currentThread(): Returns the number of thread objects in the caller's
thread control.
 threading.enumerate(): Returns a list of all the thread objects that are currently
active.
In addition to the methods, the threading module has the Thread class that implements
threading. The methods provided by the Thread class are as follows:
 run(): The run() method is the entry point for a thread.
 start(): The start() method starts a thread by calling the run method.
 join([time]): The join() waits for threads to terminate.
 isAlive(): The isAlive() method checks whether a thread is still executing.
 getName(): The getName() method returns the name of a thread.
 setName(): The setName() method sets the name of a thread.
Creating Thread Using Threading Module
To implement a new thread using the threading module, you have to do the following −
 Define a new subclass of the Thread class.
 Override the __init__(self [,args]) method to add additional arguments.
 Then, override the run(self [,args]) method to implement what the thread should
do when started.
Once you have created the new Thread subclass, you can create an instance of it and then
start a new thread by invoking the start(), which in turn calls the run()method.
Example
#!/usr/bin/python3
Python 3
401
import threading
import time
exitFlag = 0
class myThread (threading.Thread):
 def __init__(self, threadID, name, counter):
 threading.Thread.__init__(self)
 self.threadID = threadID
 self.name = name
 self.counter = counter
 def run(self):
 print ("Starting " + self.name)
 print_time(self.name, self.counter, 5)
 print ("Exiting " + self.name)
def print_time(threadName, delay, counter):
 while counter:
 if exitFlag:
 threadName.exit()
 time.sleep(delay)
 print ("%s: %s" % (threadName, time.ctime(time.time())))
 counter -= 1
# Create new threads
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)
# Start new Threads
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print ("Exiting Main Thread")
When we run the above program, it produces the following resultStarting Thread-1
Starting Thread-2
Thread-1: Fri Feb 19 10:00:21 2016
Thread-2: Fri Feb 19 10:00:22 2016
Thread-1: Fri Feb 19 10:00:22 2016
Python 3
402
Thread-1: Fri Feb 19 10:00:23 2016
Thread-2: Fri Feb 19 10:00:24 2016
Thread-1: Fri Feb 19 10:00:24 2016
Thread-1: Fri Feb 19 10:00:25 2016
Exiting Thread-1
Thread-2: Fri Feb 19 10:00:26 2016
Thread-2: Fri Feb 19 10:00:28 2016
Thread-2: Fri Feb 19 10:00:30 2016
Exiting Thread-2
Exiting Main Thread
Synchronizing Threads
The threading module provided with Python includes a simple-to-implement locking
mechanism that allows you to synchronize threads. A new lock is created by calling
the Lock() method, which returns the new lock.
The acquire(blocking) method of the new lock object is used to force the threads to run
synchronously. The optional blocking parameter enables you to control whether the thread
waits to acquire the lock.
If blocking is set to 0, the thread returns immediately with a 0 value if the lock cannot be
acquired and with a 1 if the lock was acquired. If blocking is set to 1, the thread blocks
and wait for the lock to be released.
The release() method of the new lock object is used to release the lock when it is no longer
required.
Example
#!/usr/bin/python3
import threading
import time
class myThread (threading.Thread):
 def __init__(self, threadID, name, counter):
 threading.Thread.__init__(self)
 self.threadID = threadID
 self.name = name
 self.counter = counter
 def run(self):
 print ("Starting " + self.name)
 # Get lock to synchronize threads
 threadLock.acquire()
 print_time(self.name, self.counter, 3)
Python 3
403
 # Free lock to release next thread
 threadLock.release()
def print_time(threadName, delay, counter):
 while counter:
 time.sleep(delay)
 print ("%s: %s" % (threadName, time.ctime(time.time())))
 counter -= 1
threadLock = threading.Lock()
threads = []
# Create new threads
thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)
# Start new Threads
thread1.start()
thread2.start()
# Add threads to thread list
threads.append(thread1)
threads.append(thread2)
# Wait for all threads to complete
for t in threads:
 t.join()
print ("Exiting Main Thread")
When the above code is executed, it produces the following resultStarting Thread-1
Starting Thread-2
Thread-1: Fri Feb 19 10:04:14 2016
Thread-1: Fri Feb 19 10:04:15 2016
Thread-1: Fri Feb 19 10:04:16 2016
Thread-2: Fri Feb 19 10:04:18 2016
Thread-2: Fri Feb 19 10:04:20 2016
Thread-2: Fri Feb 19 10:04:22 2016
Exiting Main Thread
Python 3
404
Multithreaded Priority Queue
The Queue module allows you to create a new queue object that can hold a specific
number of items. There are following methods to control the Queue −
 get(): The get() removes and returns an item from the queue.
 put(): The put adds item to a queue.
 qsize() : The qsize() returns the number of items that are currently in the queue.
 empty(): The empty( ) returns True if queue is empty; otherwise, False.
 full(): the full() returns True if queue is full; otherwise, False.
Example
#!/usr/bin/python3
import queue
import threading
import time
exitFlag = 0
class myThread (threading.Thread):
 def __init__(self, threadID, name, q):
 threading.Thread.__init__(self)
 self.threadID = threadID
 self.name = name
 self.q = q
 def run(self):
 print ("Starting " + self.name)
 process_data(self.name, self.q)
 print ("Exiting " + self.name)
def process_data(threadName, q):
 while not exitFlag:
 queueLock.acquire()
 if not workQueue.empty():
 data = q.get()
 queueLock.release()
 print ("%s processing %s" % (threadName, data))
 else:
 queueLock.release()
Python 3
405
 time.sleep(1)
threadList = ["Thread-1", "Thread-2", "Thread-3"]
nameList = ["One", "Two", "Three", "Four", "Five"]
queueLock = threading.Lock()
workQueue = queue.Queue(10)
threads = []
threadID = 1
# Create new threads
for tName in threadList:
 thread = myThread(threadID, tName, workQueue)
 thread.start()
 threads.append(thread)
 threadID += 1
# Fill the queue
queueLock.acquire()
for word in nameList:
 workQueue.put(word)
queueLock.release()
# Wait for queue to empty
while not workQueue.empty():
 pass
# Notify threads it's time to exit
exitFlag = 1
# Wait for all threads to complete
for t in threads:
 t.join()
print ("Exiting Main Thread")
When the above code is executed, it produces the following resultStarting Thread-1
Starting Thread-2
Starting Thread-3
Python 3
406
Thread-1 processing One
Thread-2 processing Two
Thread-3 processing Three
Thread-1 processing Four
Thread-2 processing Five
Exiting Thread-3
Exiting Thread-1
Exiting Thread-2
Exiting Main Thread
Python 3
407
XML is a portable, open source language that allows programmers to develop applications
that can be read by other applications, regardless of operating system and/or
developmental language.
What is XML?
The Extensible Markup Language (XML) is a markup language much like HTML or SGML.
This is recommended by the World Wide Web Consortium and available as an open
standard.
XML is extremely useful for keeping track of small to medium amounts of data without
requiring an SQL- based backbone.
XML Parser Architectures and APIs
The Python standard library provides a minimal but useful set of interfaces to work with
XML.
The two most basic and broadly used APIs to XML data are the SAX and DOM interfaces.
 Simple API for XML (SAX): Here, you register callbacks for events of interest
and then let the parser proceed through the document. This is useful when your
documents are large or you have memory limitations, it parses the file as it reads
it from the disk and the entire file is never stored in the memory.
 Document Object Model (DOM) API: This is a World Wide Web Consortium
recommendation wherein the entire file is read into the memory and stored in a
hierarchical (tree-based) form to represent all the features of an XML document.
SAX obviously cannot process information as fast as DOM, when working with large files.
On the other hand, using DOM exclusively can really kill your resources, especially if used
on many small files.
SAX is read-only, while DOM allows changes to the XML file. Since these two different APIs
literally complement each other, there is no reason why you cannot use them both for
large projects.
For all our XML code examples, let us use a simple XML file movies.xml as an input-
<collection shelf="New Arrivals">
<movie title="Enemy Behind">
 <type>War, Thriller</type>
 <format>DVD</format>
 <year>2003</year>
 <rating>PG</rating>
 <stars>10</stars>
26.Python 3 – XML Processing
Python 3
408
 <description>Talk about a US-Japan war</description>
</movie>
<movie title="Transformers">
 <type>Anime, Science Fiction</type>
 <format>DVD</format>
 <year>1989</year>
 <rating>R</rating>
 <stars>8</stars>
 <description>A schientific fiction</description>
</movie>
 <movie title="Trigun">
 <type>Anime, Action</type>
 <format>DVD</format>
 <episodes>4</episodes>
 <rating>PG</rating>
 <stars>10</stars>
 <description>Vash the Stampede!</description>
</movie>
<movie title="Ishtar">
 <type>Comedy</type>
 <format>VHS</format>
 <rating>PG</rating>
 <stars>2</stars>
 <description>Viewable boredom</description>
</movie>
</collection>
Parsing XML with SAX APIs
SAX is a standard interface for event-driven XML parsing. Parsing XML with SAX generally
requires you to create your own ContentHandler by subclassing xml.sax.ContentHandler.
Your ContentHandler handles the particular tags and attributes of your flavor(s) of XML. A
ContentHandler object provides methods to handle various parsing events. Its owning
parser calls ContentHandler methods as it parses the XML file.
The methods startDocument and endDocument are called at the start and the end of the
XML file. The method characters(text) is passed the character data of the XML file via the
parameter text.
The ContentHandler is called at the start and end of each element. If the parser is not in
namespace mode, the methods startElement(tag, attributes) andendElement(tag) are 
Python 3
409
called; otherwise, the corresponding methodsstartElementNS and endElementNS are
called. Here, tag is the element tag, and attributes is an Attributes object.
Here are other important methods to understand before proceedingThe make_parser Method
The following method creates a new parser object and returns it. The parser object created
will be of the first parser type, the system finds.
xml.sax.make_parser( [parser_list] )
Here is the detail of the parameters-
 parser_list: The optional argument consisting of a list of parsers to use, which
must all implement the make_parser method.
The parse Method
The following method creates a SAX parser and uses it to parse a document.
xml.sax.parse( xmlfile, contenthandler[, errorhandler])
Here are the details of the parameters-
 xmlfile: This is the name of the XML file to read from.
 contenthandler: This must be a ContentHandler object.
 errorhandler: If specified, errorhandler must be a SAX ErrorHandler object.
The parseString Method
There is one more method to create a SAX parser and to parse the specifiedXML string.
xml.sax.parseString(xmlstring, contenthandler[, errorhandler])
Here are the details of the parameters-
 xmlstring: This is the name of the XML string to read from.
 contenthandler: This must be a ContentHandler object.
 errorhandler: If specified, errorhandler must be a SAX ErrorHandler object.
Example
#!/usr/bin/python3
import xml.sax
Python 3
410
class MovieHandler( xml.sax.ContentHandler ):
 def __init__(self):
 self.CurrentData = ""
 self.type = ""
 self.format = ""
 self.year = ""
 self.rating = ""
 self.stars = ""
 self.description = ""
 # Call when an element starts
 def startElement(self, tag, attributes):
 self.CurrentData = tag
 if tag == "movie":
 print ("*****Movie*****")
 title = attributes["title"]
 print ("Title:", title)
 # Call when an elements ends
 def endElement(self, tag):
 if self.CurrentData == "type":
 print ("Type:", self.type)
 elif self.CurrentData == "format":
 print ("Format:", self.format)
 elif self.CurrentData == "year":
 print ("Year:", self.year)
 elif self.CurrentData == "rating":
 print ("Rating:", self.rating)
 elif self.CurrentData == "stars":
 print ("Stars:", self.stars)
 elif self.CurrentData == "description":
 print ("Description:", self.description)
 self.CurrentData = ""
 # Call when a character is read
 def characters(self, content):
 if self.CurrentData == "type":
 self.type = content
 elif self.CurrentData == "format":
Python 3
411
 self.format = content
 elif self.CurrentData == "year":
 self.year = content
 elif self.CurrentData == "rating":
 self.rating = content
 elif self.CurrentData == "stars":
 self.stars = content
 elif self.CurrentData == "description":
 self.description = content

if ( __name__ == "__main__"):

 # create an XMLReader
 parser = xml.sax.make_parser()
 # turn off namepsaces
 parser.setFeature(xml.sax.handler.feature_namespaces, 0)
 # override the default ContextHandler
 Handler = MovieHandler()
 parser.setContentHandler( Handler )

 parser.parse("movies.xml")
This would produce the following result-
*****Movie*****
Title: Enemy Behind
Type: War, Thriller
Format: DVD
Year: 2003
Rating: PG
Stars: 10
Description: Talk about a US-Japan war
*****Movie*****
Title: Transformers
Type: Anime, Science Fiction
Format: DVD
Year: 1989
Rating: R
Stars: 8
Python 3
412
Description: A schientific fiction
*****Movie*****
Title: Trigun
Type: Anime, Action
Format: DVD
Rating: PG
Stars: 10
Description: Vash the Stampede!
*****Movie*****
Title: Ishtar
Type: Comedy
Format: VHS
Rating: PG
Stars: 2
Description: Viewable boredom
For a complete detail on SAX API documentation, please refer to the standard Python SAX
APIs.
Parsing XML with DOM APIs
The Document Object Model ("DOM") is a cross-language API from the World Wide Web
Consortium (W3C) for accessing and modifying the XML documents.
The DOM is extremely useful for random-access applications. SAX only allows you a view
of one bit of the document at a time. If you are looking at one SAX element, you have no
access to another.
Here is the easiest way to load an XML document quickly and to create a minidom object
using the xml.dom module. The minidom object provides a simple parser method that
quickly creates a DOM tree from the XML file.
The sample phrase calls the parse( file [,parser] ) function of the minidom object to parse
the XML file, designated by file into a DOM tree object.
#!/usr/bin/python3
from xml.dom.minidom import parse
import xml.dom.minidom
# Open XML document using minidom parser
DOMTree = xml.dom.minidom.parse("movies.xml")
collection = DOMTree.documentElement
if collection.hasAttribute("shelf"):
 print ("Root element : %s" % collection.getAttribute("shelf"))
Python 3
413
# Get all the movies in the collection
movies = collection.getElementsByTagName("movie")
# Print detail of each movie.
for movie in movies:
 print ("*****Movie*****")
 if movie.hasAttribute("title"):
 print ("Title: %s" % movie.getAttribute("title"))
 type = movie.getElementsByTagName('type')[0]
 print ("Type: %s" % type.childNodes[0].data)
 format = movie.getElementsByTagName('format')[0]
 print ("Format: %s" % format.childNodes[0].data)
 rating = movie.getElementsByTagName('rating')[0]
 print ("Rating: %s" % rating.childNodes[0].data)
 description = movie.getElementsByTagName('description')[0]
 print ("Description: %s" % description.childNodes[0].data)
This would produce the following resultRoot element : New Arrivals
*****Movie*****
Title: Enemy Behind
Type: War, Thriller
Format: DVD
Rating: PG
Description: Talk about a US-Japan war
*****Movie*****
Title: Transformers
Type: Anime, Science Fiction
Format: DVD
Rating: R
Description: A schientific fiction
*****Movie*****
Title: Trigun
Type: Anime, Action
Format: DVD
Python 3
414
Rating: PG
Description: Vash the Stampede!
*****Movie*****
Title: Ishtar
Type: Comedy
Format: VHS
Rating: PG
Description: Viewable boredom
For a complete detail on DOM API documentation, please refer to the standard Python
DOM APIs.
Python 3
415
Python provides various options for developing graphical user interfaces (GUIs). The most
important features are listed below.
 Tkinter: Tkinter is the Python interface to the Tk GUI toolkit shipped with Python.
We would look at this option in this chapter.
 wxPython: This is an open-source Python interface for wxWidgets GUI toolkit. You
can find a complete tutorial on WxPython here.
 PyQt:This is also a Python interface for a popular cross-platform Qt GUI library.
TutorialsPoint has a very good tutorial on PyQt here.
 JPython: JPython is a Python port for Java, which gives Python scripts seamless
access to the Java class libraries on the local machinehttp://www.jython.org.
There are many other interfaces available, which you can find them on the net.
Tkinter Programming
Tkinter is the standard GUI library for Python. Python when combined with Tkinter provides
a fast and easy way to create GUI applications. Tkinter provides a powerful object-oriented
interface to the Tk GUI toolkit.
Creating a GUI application using Tkinter is an easy task. All you need to do is perform the
following steps −
 Import the Tkinter module.
 Create the GUI application main window.
 Add one or more of the above-mentioned widgets to the GUI application.
 Enter the main event loop to take action against each event triggered by the user.
Example
#!/usr/bin/python3
import tkinter # note that module name has changed from Tkinter in Python 2 to tkinter in
Python 3
top = tkinter.Tk()
# Code to add widgets will go here...
top.mainloop()
27.Python 3 – GUI Programming (Tkinter) 
Python 3
416
This would create a following windowTkinterWidgets
Tkinter provides various controls, such as buttons, labels and text boxes used in a GUI
application. These controls are commonly called widgets.
There are currently 15 types of widgets in Tkinter. We present these widgets as well as a
brief description in the following tableOperator Description
Button The Button widget is used to display the buttons in your
application.
Canvas The Canvas widget is used to draw shapes, such as lines,
ovals, polygons and rectangles, in your application.
Checkbutton The Checkbutton widget is used to display a number of
options as checkboxes. The user can select multiple
options at a time.
Entry The Entry widget is used to display a single-line text field
for accepting values from a user.
Frame The Frame widget is used as a container widget to
organize other widgets.
Label The Label widget is used to provide a single-line caption
for other widgets. It can also contain images.
Python 3
417
Listbox The Listbox widget is used to provide a list of options to
a user.
Menubutton The Menubutton widget is used to display menus in your
application.
Menu The Menu widget is used to provide various commands
to a user. These commands are contained inside
Menubutton.
Message The Message widget is used to display multiline text fields
for accepting values from a user.
Radiobutton The Radiobutton widget is used to display a number of
options as radio buttons. The user can select only one
option at a time.
Scale The Scale widget is used to provide a slider widget.
Scrollbar The Scrollbar widget is used to add scrolling capability to
various widgets, such as list boxes.
Text The Text widget is used to display text in multiple lines.
Toplevel The Toplevel widget is used to provide a separate window
container.
Spinbox The Spinbox widget is a variant of the standard Tkinter
Entry widget, which can be used to select from a fixed
number of values.
PanedWindow A PanedWindow is a container widget that may contain
any number of panes, arranged horizontally or vertically.
LabelFrame A labelframe is a simple container widget. Its primary
purpose is to act as a spacer or container for complex
window layouts.
tkMessageBox This module is used to display the message boxes in your
applications.
Python 3
418
Let us study these widgets in detail.
Tkinter Button
The Button widget is used to add buttons in a Python application. These buttons can display
text or images that convey the purpose of the buttons. You can attach a function or a
method to a button which is called automatically when you click the button.
Syntax
Here is the simple syntax to create this widgetw = Button ( master, option=value, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Option Description
activebackground Background color when the button is under the cursor.
activeforeground Foreground color when the button is under the cursor.
bd Border width in pixels. Default is 2.
bg Normal background color.
command Function or method to be called when the button is clicked.
fg Normal foreground (text) color.
font Text font to be used for the button's label.
height Height of the button in text lines (for textual buttons) or pixels
(for images).
Python 3
419
highlightcolor The color of the focus highlight when the widget has focus.
image Image to be displayed on the button (instead of text).
justify How to show multiple text lines: LEFT to left-justify each line;
CENTER to center them; or RIGHT to right-justify.
padx Additional padding left and right of the text.
pady Additional padding above and below the text.
relief Relief specifies the type of the border. Some of the values are
SUNKEN, RAISED, GROOVE, and RIDGE.
state Set this option to DISABLED to gray out the button and make it
unresponsive. Has the value ACTIVE when the mouse is over it.
Default is NORMAL.
underline Default is -1, meaning that no character of the text on the button
will be underlined. If nonnegative, the corresponding text
character will be underlined.
width Width of the button in letters (if displaying text) or pixels (if
displaying an image).
wraplength If this value is set to a positive number, the text lines will be
wrapped to fit within this length.
Methods
Following are commonly used methods for this widgetMethod Description
flash() Causes the button to flash several times between active and normal
colors. Leaves the button in the state it was in originally. Ignored if
the button is disabled.
invoke() Calls the button's callback, and returns what that function returns. Has
no effect if the button is disabled or there is no callback.
Python 3
420
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
from tkinter import messagebox
top = Tk()
top.geometry("100x100")
def helloCallBack():
 msg=messagebox.showinfo( "Hello Python", "Hello World")
B = Button(top, text ="Hello", command = helloCallBack)
B.place(x=50,y=50)
top.mainloop()
When the above code is executed, it produces the following resultTkinter Canvas
The Canvas is a rectangular area intended for drawing pictures or other complex layouts.
You can place graphics, text, widgets or frames on a Canvas.
Syntax
Here is the simple syntax to create this widgetw = Canvas ( master, option=value, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Python 3
421
Option Description
bd Border width in pixels. Default is 2.
bg Normal background color.
confine If true (the default), the canvas cannot be scrolled outside of the
scrollregion.
cursor Cursor used in the canvas like arrow, circle, dot etc.
height Size of the canvas in the Y dimension.
highlightcolor Color shown in the focus highlight.
relief Relief specifies the type of the border. Some of the values are
SUNKEN, RAISED, GROOVE, and RIDGE.
scrollregion A tuple (w, n, e, s) that defines over how large an area the canvas
can be scrolled, where w is the left side, n the top, e the right side,
and s the bottom.
width Size of the canvas in the X dimension.
xscrollincrement If you set this option to some positive dimension, the canvas can be
positioned only on multiples of that distance, and the value will be
used for scrolling by scrolling units, such as when the user clicks on
the arrows at the ends of a scrollbar.
xscrollcommand If the canvas is scrollable, this attribute should be the .set() method
of the horizontal scrollbar.
yscrollincrement Works like xscrollincrement, but governs vertical movement.
yscrollcommand If the canvas is scrollable, this attribute should be the .set() method
of the vertical scrollbar.
The Canvas widget can support the following standard itemsarc . Creates an arc item, which can be a chord, a pieslice or a simple arc.
coord = 10, 50, 240, 210
Python 3
422
arc = canvas.create_arc(coord, start=0, extent=150, fill="blue")
image . Creates an image item, which can be an instance of either the BitmapImage or
the PhotoImage classes.
filename = PhotoImage(file = "sunshine.gif")
image = canvas.create_image(50, 50, anchor=NE, image=filename)
line . Creates a line item.
line = canvas.create_line(x0, y0, x1, y1, ..., xn, yn, options)
oval . Creates a circle or an ellipse at the given coordinates. It takes two pairs of
coordinates; the top left and bottom right corners of the bounding rectangle for the oval.
oval = canvas.create_oval(x0, y0, x1, y1, options)
polygon . Creates a polygon item that must have at least three vertices.
oval = canvas.create_polygon(x0, y0, x1, y1,...xn, yn, options)
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
from tkinter import messagebox
top = Tk()
C = Canvas(top, bg="blue", height=250, width=300)
coord = 10, 50, 240, 210
arc = C.create_arc(coord, start=0, extent=150, fill="red")
line = C.create_line(10,10,200,200,fill='white')
C.pack()
Top.mainloop()
Python 3
423
When the above code is executed, it produces the following resultTkinter Checkbutton
The Checkbutton widget is used to display a number of options to a user as toggle buttons.
The user can then select one or more options by clicking the button corresponding to each
option.
You can also display images in place of text.
Syntax
Here is the simple syntax to create this widgetw = Checkbutton ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Option Description
activebackground Background color when the checkbutton is under the cursor.
Python 3
424
activeforeground Foreground color when the checkbutton is under the cursor.
bg The normal background color displayed behind the label and
indicator.
bitmap To display a monochrome image on a button.
bd The size of the border around the indicator. Default is 2 pixels.
command A procedure to be called every time the user changes the state of
this checkbutton.
cursor If you set this option to a cursor name (arrow, dot etc.), the
mouse cursor will change to that pattern when it is over the
checkbutton.
disabledforeground The foreground color used to render the text of a disabled
checkbutton. The default is a stippled version of the default
foreground color.
font The font used for the text.
fg The color used to render the text.
height The number of lines of text on the checkbutton. Default is 1.
highlightcolor The color of the focus highlight when the checkbutton has the
focus.
image To display a graphic image on the button.
justify If the text contains multiple lines, this option controls how the
text is justified: CENTER, LEFT, or RIGHT.
offvalue Normally, a checkbutton's associated control variable will be set
to 0 when it is cleared (off). You can supply an alternate value for
the off state by setting offvalue to that value.
onvalue Normally, a checkbutton's associated control variable will be set
to 1 when it is set (on). You can supply an alternate value for the
on state by setting onvalue to that value.
Python 3
425
padx How much space to leave to the left and right of the checkbutton
and text. Default is 1 pixel.
pady How much space to leave above and below the checkbutton and
text. Default is 1 pixel.
relief With the default value, relief=FLAT, the checkbutton does not
stand out from its background. You may set this option to any of
the other styles
selectcolor The color of the checkbutton when it is set. Default is
selectcolor="red".
selectimage If you set this option to an image, that image will appear in the
checkbutton when it is set.
state The default is state=NORMAL, but you can use state=DISABLED
to gray out the control and make it unresponsive. If the cursor is
currently over the checkbutton, the state is ACTIVE.
text The label displayed next to the checkbutton. Use newlines ("\n")
to display multiple lines of text.
underline With the default value of -1, none of the characters of the text
label are underlined. Set this option to the index of a character in
the text (counting from zero) to underline that character.
variable The control variable that tracks the current state of the
checkbutton. Normally this variable is an IntVar, and 0 means
cleared and 1 means set, but see the offvalue and onvalue options
above.
width The default width of a checkbutton is determined by the size of
the displayed image or text. You can set this option to a number
of characters and the checkbutton will always have room for that
many characters.
wraplength Normally, lines are not wrapped. You can set this option to a
number of characters and all lines will be broken into pieces no
longer than that number.
Methods
Following are commonly used methods for this widget-
Python 3
426
Method Description
deselect() Clears (turns off) the checkbutton.
flash() Flashes the checkbutton a few times between its active and normal
colors, but leaves it the way it started.
invoke() You can call this method to get the same actions that would occur if
the user clicked on the checkbutton to change its state.
select() Sets (turns on) the checkbutton.
toggle() Clears the checkbutton if set, sets it if cleared.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
import tkinter

top = Tk()
CheckVar1 = IntVar()
CheckVar2 = IntVar()
C1 = Checkbutton(top, text = "Music", variable = CheckVar1, \
 onvalue = 1, offvalue = 0, height=5, \
 width = 20, )
C2 = Checkbutton(top, text = "Video", variable = CheckVar2, \
 onvalue = 1, offvalue = 0, height=5, \
 width = 20)
C1.pack()
C2.pack()
top.mainloop()
Python 3
427
When the above code is executed, it produces the following result –
Tkinter Entry
The Entry widget is used to accept single-line text strings from a user.
 If you want to display multiple lines of text that can be edited, then you should use
the Text widget.
 If you want to display one or more lines of text that cannot be modified by the
user, then you should use the Label widget.
Syntax
Here is the simple syntax to create this widgetw = Entry( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Option Description
bg The normal background color displayed behind the label and
indicator.
bd The size of the border around the indicator. Default is 2 pixels.
Python 3
428
command A procedure to be called every time the user changes the state of
this checkbutton.
cursor If you set this option to a cursor name (arrow, dot etc.), the mouse
cursor will change to that pattern when it is over the checkbutton.
font The font used for the text.
exportselection By default, if you select text within an Entry widget, it is
automatically exported to the clipboard. To avoid this exportation,
use exportselection=0.
fg The color used to render the text.
highlightcolor The color of the focus highlight when the checkbutton has the
focus.
justify If the text contains multiple lines, this option controls how the text
is justified: CENTER, LEFT, or RIGHT.
relief With the default value, relief=FLAT, the checkbutton does not
stand out from its background. You may set this option to any of
the other styles
selectbackground The background color to use displaying selected text.
selectborderwidth The width of the border to use around selected text. The default is
one pixel.
selectforeground The foreground (text) color of selected text.
show Normally, the characters that the user types appear in the entry.
To make a .password. entry that echoes each character as an
asterisk, set show="*".
state The default is state=NORMAL, but you can use state=DISABLED to
gray out the control and make it unresponsive. If the cursor is
currently over the checkbutton, the state is ACTIVE.
textvariable In order to be able to retrieve the current text from your entry
widget, you must set this option to an instance of the StringVar
class.
Python 3
429
width The default width of a checkbutton is determined by the size of the
displayed image or text. You can set this option to a number of
characters and the checkbutton will always have room for that
many characters.
xscrollcommand If you expect that users will often enter more text than the
onscreen size of the widget, you can link your entry widget to a
scrollbar.
Methods
Following are commonly used methods for this widgetMethod Description
delete ( first, last=None ) Deletes characters from the widget, starting with
the one at index first, up to but not including the
character at position last. If the second argument
is omitted, only the single character at position
first is deleted.
get() Returns the entry's current text as a string.
icursor ( index ) Set the insertion cursor just before the character
at the given index.
index ( index ) Shift the contents of the entry so that the
character at the given index is the leftmost visible
character. Has no effect if the text fits entirely
within the entry.
insert ( index, s ) Inserts string s before the character at the given
index.
select_adjust ( index ) This method is used to make sure that the
selection includes the character at the specified
index.
select_clear() Clears the selection. If there isn't currently a
selection, has no effect.
Python 3
430
select_from ( index ) Sets the ANCHOR index position to the character
selected by index, and selects that character.
select_present() If there is a selection, returns true, else returns
false.
select_range ( start, end ) Sets the selection under program control. Selects
the text starting at the start index, up to but not
including the character at the end index. The start
position must be before the end position.
select_to ( index ) Selects all the text from the ANCHOR position up
to but not including the character at the given
index.
xview ( index ) This method is useful in linking the Entry widget to
a horizontal scrollbar.
xview_scroll ( number, what ) Used to scroll the entry horizontally. The what
argument must be either UNITS, to scroll by
character widths, or PAGES, to scroll by chunks
the size of the entry widget. The number is
positive to scroll left to right, negative to scroll
right to left.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
top = Tk()
L1 = Label(top, text="User Name")
L1.pack( side = LEFT)
E1 = Entry(top, bd =5)
E1.pack(side = RIGHT)
top.mainloop()
Python 3
431
When the above code is executed, it produces the following resultTkinter Frame
The Frame widget is very important for the process of grouping and organizing other
widgets in a somehow friendly way. It works like a container, which is responsible for
arranging the position of other widgets.
It uses rectangular areas in the screen to organize the layout and to provide padding of
these widgets. A frame can also be used as a foundation class to implement complex
widgets.
Syntax
Here is the simple syntax to create this widgetw = Frame ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
bg The normal background color displayed behind the label and
indicator.
bd The size of the border around the indicator. Default is 2 pixels.
cursor If you set this option to a cursor name (arrow, dot etc.), the
mouse cursor will change to that pattern when it is over the
checkbutton.
height The vertical dimension of the new frame.
highlightbackground Color of the focus highlight when the frame does not have focus.
highlightcolor Color shown in the focus highlight when the frame has the focus.
Python 3
432
highlightthickness Thickness of the focus highlight.
relief With the default value, relief=FLAT, the checkbutton does not
stand out from its background. You may set this option to any
of the other styles
width The default width of a checkbutton is determined by the size of
the displayed image or text. You can set this option to a number
of characters and the checkbutton will always have room for
that many characters.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
root = Tk()
frame = Frame(root)
frame.pack()
bottomframe = Frame(root)
bottomframe.pack( side = BOTTOM )
redbutton = Button(frame, text="Red", fg="red")
redbutton.pack( side = LEFT)
greenbutton = Button(frame, text="Brown", fg="brown")
greenbutton.pack( side = LEFT )
bluebutton = Button(frame, text="Blue", fg="blue")
bluebutton.pack( side = LEFT )
blackbutton = Button(bottomframe, text="Black", fg="black")
blackbutton.pack( side = BOTTOM)
root.mainloop()
Python 3
433
When the above code is executed, it produces the following resultTkinter Label
This widget implements a display box where you can place text or images. The text
displayed by this widget can be updated at any time you want.
It is also possible to underline part of the text (like to identify a keyboard shortcut) and
span the text across multiple lines.
Syntax
Here is the simple syntax to create this widgetw = Label ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
anchor This options controls where the text is positioned if the widget has
more space than the text needs. The default is anchor=CENTER, which
centers the text in the available space.
bg The normal background color displayed behind the label and indicator.
bitmap Set this option equal to a bitmap or image object and the label will
display that graphic.
bd The size of the border around the indicator. Default is 2 pixels.
cursor If you set this option to a cursor name (arrow, dot etc.), the mouse
cursor will change to that pattern when it is over the checkbutton.
font If you are displaying text in this label (with the text or textvariable
option, the font option specifies in what font that text will be displayed.
Python 3
434
fg If you are displaying text or a bitmap in this label, this option specifies
the color of the text. If you are displaying a bitmap, this is the color
that will appear at the position of the 1-bits in the bitmap.
height The vertical dimension of the new frame.
image To display a static image in the label widget, set this option to an
image object.
justify Specifies how multiple lines of text will be aligned with respect to each
other: LEFT for flush left, CENTER for centered (the default), or RIGHT
for right-justified.
padx Extra space added to the left and right of the text within the widget.
Default is 1.
pady Extra space added above and below the text within the widget. Default
is 1.
relief Specifies the appearance of a decorative border around the label. The
default is FLAT; for other values.
text To display one or more lines of text in a label widget, set this option
to a string containing the text. Internal newlines ("\n") will force a line
break.
textvariable To slave the text displayed in a label widget to a control variable of
class StringVar, set this option to that variable.
underline You can display an underline (_) below the nth letter of the text,
counting from 0, by setting this option to n. The default is underline=-
1, which means no underlining.
width Width of the label in characters (not pixels!). If this option is not set,
the label will be sized to fit its contents.
wraplength You can limit the number of characters in each line by setting this
option to the desired number. The default value, 0, means that lines
will be broken only at newlines.
Python 3
435
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
root = Tk()
var = StringVar()
label = Label( root, textvariable=var, relief=RAISED )
var.set("Hey!? How are you doing?")
label.pack()
root.mainloop()
When the above code is executed, it produces the following resultTkinter Listbox
The Listbox widget is used to display a list of items from which a user can select a number
of items
Syntax
Here is the simple syntax to create this widgetw = Listbox ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
bg The normal background color displayed behind the label and
indicator.
Python 3
436
bd The size of the border around the indicator. Default is 2
pixels.
cursor The cursor that appears when the mouse is over the listbox.
font The font used for the text in the listbox.
fg The color used for the text in the listbox.
height Number of lines (not pixels!) shown in the listbox. Default is
10.
highlightcolor Color shown in the focus highlight when the widget has the
focus.
highlightthickness Thickness of the focus highlight.
relief Selects three-dimensional border shading effects. The default
is SUNKEN.
selectbackground The background color to use displaying selected text.
selectmode Determines how many items can be selected, and how mouse
drags affect the selection:
 BROWSE: Normally, you can only select one line out
of a listbox. If you click on an item and then drag to a
different line, the selection will follow the mouse. This
is the default.
 SINGLE: You can only select one line, and you can't
drag the mouse.wherever you click button 1, that line
is selected.
 MULTIPLE: You can select any number of lines at
once. Clicking on any line toggles whether or not it is
selected.
 EXTENDED: You can select any adjacent group of
lines at once by clicking on the first line and dragging
to the last line.
width The width of the widget in characters. The default is 20.
Python 3
437
xscrollcommand If you want to allow the user to scroll the listbox horizontally,
you can link your listbox widget to a horizontal scrollbar.
yscrollcommand If you want to allow the user to scroll the listbox vertically,
you can link your listbox widget to a vertical scrollbar.
Methods
Methods on listbox objects includeOptions Description
activate ( index ) Selects the line specifies by the given index.
curselection() Returns a tuple containing the line numbers of the
selected element or elements, counting from 0. If
nothing is selected, returns an empty tuple.
delete ( first, last=None ) Deletes the lines whose indices are in the range [first,
last]. If the second argument is omitted, the single line
with index first is deleted.
get ( first, last=None ) Returns a tuple containing the text of the lines with
indices from first to last, inclusive. If the second
argument is omitted, returns the text of the line closest
to first.
index ( i ) If possible, positions the visible part of the listbox so
that the line containing index i is at the top of the
widget.
insert ( index, *elements ) Insert one or more new lines into the listbox before the
line specified by index. Use END as the first argument
if you want to add new lines to the end of the listbox.
nearest ( y ) Return the index of the visible line closest to the ycoordinate y relative to the listbox widget.
see ( index ) Adjust the position of the listbox so that the line
referred to by index is visible.
size() Returns the number of lines in the listbox.
Python 3
438
xview() To make the listbox horizontally scrollable, set the
command option of the associated horizontal scrollbar
to this method.
xview_moveto ( fraction ) Scroll the listbox so that the leftmost fraction of the
width of its longest line is outside the left side of the
listbox. Fraction is in the range [0,1].
xview_scroll ( number, what ) Scrolls the listbox horizontally. For the what argument,
use either UNITS to scroll by characters, or PAGES to
scroll by pages, that is, by the width of the listbox. The
number argument tells how many to scroll.
yview() To make the listbox vertically scrollable, set the
command option of the associated vertical scrollbar to
this method.
yview_moveto ( fraction ) Scroll the listbox so that the top fraction of the width of
its longest line is outside the left side of the listbox.
Fraction is in the range [0,1].
yview_scroll ( number, what ) Scrolls the listbox vertically. For the what argument,
use either UNITS to scroll by lines, or PAGES to scroll
by pages, that is, by the height of the listbox. The
number argument tells how many to scroll.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
import tkinter
top = Tk()
Lb1 = Listbox(top)
Lb1.insert(1, "Python")
Lb1.insert(2, "Perl")
Lb1.insert(3, "C")
Lb1.insert(4, "PHP")
Python 3
439
Lb1.insert(5, "JSP")
Lb1.insert(6, "Ruby")
Lb1.pack()
top.mainloop()
When the above code is executed, it produces the following resultTkinter Menubutton
A menubutton is the part of a drop-down menu that stays on the screen all the time. Every
menubutton is associated with a Menu widget that can display the choices for that
menubutton when the user clicks on it.
Syntax
Here is the simple syntax to create this widget-
 w = Menubutton ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
activebackground The background color when the mouse is over the menubutton.
activeforeground The foreground color when the mouse is over the menubutton.
Python 3
440
anchor This options controls where the text is positioned if the widget
has more space than the text needs. The default is
anchor=CENTER, which centers the text.
bg The normal background color displayed behind the label and
indicator.
bitmap To display a bitmap on the menubutton, set this option to a
bitmap name.
bd The size of the border around the indicator. Default is 2 pixels.
cursor The cursor that appears when the mouse is over this menubutton.
direction Set direction=LEFT to display the menu to the left of the button;
use direction=RIGHT to display the menu to the right of the
button; or use direction='above' to place the menu above the
button.
disabledforeground The foreground color shown on this menubutton when it is
disabled.
fg The foreground color when the mouse is not over the
menubutton.
height The height of the menubutton in lines of text (not pixels!). The
default is to fit the menubutton's size to its contents.
highlightcolor Color shown in the focus highlight when the widget has the focus.
image To display an image on this menubutton,
justify This option controls where the text is located when the text
doesn't fill the menubutton: use justify=LEFT to left-justify the
text (this is the default); use justify=CENTER to center it, or
justify=RIGHT to right-justify.
menu To associate the menubutton with a set of choices, set this option
to the Menu object containing those choices. That menu object
must have been created by passing the associated menubutton
to the constructor as its first argument.
Python 3
441
padx How much space to leave to the left and right of the text of the
menubutton. Default is 1.
pady How much space to leave above and below the text of the
menubutton. Default is 1.
relief Selects three-dimensional border shading effects. The default is
RAISED.
state Normally, menubuttons respond to the mouse. Set
state=DISABLED to gray out the menubutton and make it
unresponsive.
text To display text on the menubutton, set this option to the string
containing the desired text. Newlines ("\n") within the string will
cause line breaks.
textvariable You can associate a control variable of class StringVar with this
menubutton. Setting that control variable will change the
displayed text.
underline Normally, no underline appears under the text on the
menubutton. To underline one of the characters, set this option
to the index of that character.
width The width of the widget in characters. The default is 20.
wraplength Normally, lines are not wrapped. You can set this option to a
number of characters and all lines will be broken into pieces no
longer than that number.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
import tkinter
top = Tk()
mb= Menubutton ( top, text="condiments", relief=RAISED )
Python 3
442
mb.grid()
mb.menu = Menu ( mb, tearoff = 0 )
mb["menu"] = mb.menu

mayoVar = IntVar()
ketchVar = IntVar()
mb.menu.add_checkbutton ( label="mayo",
 variable=mayoVar )
mb.menu.add_checkbutton ( label="ketchup",
 variable=ketchVar )
mb.pack()
top.mainloop()
When the above code is executed, it produces the following resultTkinter Menu
The goal of this widget is to allow us to create all kinds of menus that can be used by our
applications. The core functionality provides ways to create three menu types: pop-up,
toplevel and pull-down.
It is also possible to use other extended widgets to implement new types of menus, such
as the OptionMenu widget, which implements a special type that generates a pop-up list
of items within a selection.
Syntax
Here is the simple syntax to create this widgetw = Menu ( master, option, ... )
Parameters
 master: This represents the parent window.
Python 3
443
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
activebackground The background color that will appear on a choice when it is under
the mouse.
activeborderwidth Specifies the width of a border drawn around a choice when it is
under the mouse. Default is 1 pixel.
activeforeground The foreground color that will appear on a choice when it is under
the mouse.
bg The background color for choices not under the mouse.
bd The width of the border around all the choices. Default is 1.
cursor The cursor that appears when the mouse is over the choices, but
only when the menu has been torn off.
disabledforeground The color of the text for items whose state is DISABLED.
font The default font for textual choices.
fg The foreground color used for choices not under the mouse.
postcommand You can set this option to a procedure, and that procedure will be
called every time someone brings up this menu.
relief The default 3-D effect for menus is relief=RAISED.
image To display an image on this menubutton.
selectcolor Specifies the color displayed in checkbuttons and radiobuttons
when they are selected.
tearoff Normally, a menu can be torn off, the first position (position 0) in
the list of choices is occupied by the tear-off element, and the
additional choices are added starting at position 1. If you set 
Python 3
444
Methods
These methods are available on Menu objectsOption Description
add_command (options) Adds a menu item to the menu.
add_radiobutton( options ) Creates a radio button menu item.
add_checkbutton( options ) Creates a check button menu item.
add_cascade(options) Creates a new hierarchical menu by associating a
given menu to a parent menu
add_separator() Adds a separator line to the menu.
add( type, options ) Adds a specific type of menu item to the menu.
delete( startindex [, endindex ]) Deletes the menu items ranging from startindex to
endindex.
entryconfig( index, options ) Allows you to modify a menu item, which is identified
by the index, and change its options.
index(item) Returns the index number of the given menu item
label.
insert_separator ( index ) Insert a new separator at the position specified by
index.
tearoff=0, the menu will not have a tear-off feature, and choices
will be added starting at position 0.
title Normally, the title of a tear-off menu window will be the same as
the text of the menubutton or cascade that lead to this menu. If
you want to change the title of that window, set the title option to
that string.
Python 3
445
invoke ( index ) Calls the command callback associated with the
choice at position index. If a checkbutton, its state is
toggled between set and cleared; if a radiobutton,
that choice is set.
type ( index ) Returns the type of the choice specified by index:
either "cascade", "checkbutton", "command",
"radiobutton", "separator", or "tearoff".
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
def donothing():
 filewin = Toplevel(root)
 button = Button(filewin, text="Do nothing button")
 button.pack()

root = Tk()
menubar = Menu(root)
filemenu = Menu(menubar, tearoff=0)
filemenu.add_command(label="New", command=donothing)
filemenu.add_command(label="Open", command=donothing)
filemenu.add_command(label="Save", command=donothing)
filemenu.add_command(label="Save as...", command=donothing)
filemenu.add_command(label="Close", command=donothing)
filemenu.add_separator()
filemenu.add_command(label="Exit", command=root.quit)
menubar.add_cascade(label="File", menu=filemenu)
editmenu = Menu(menubar, tearoff=0)
editmenu.add_command(label="Undo", command=donothing)
Python 3
446
editmenu.add_separator()
editmenu.add_command(label="Cut", command=donothing)
editmenu.add_command(label="Copy", command=donothing)
editmenu.add_command(label="Paste", command=donothing)
editmenu.add_command(label="Delete", command=donothing)
editmenu.add_command(label="Select All", command=donothing)
menubar.add_cascade(label="Edit", menu=editmenu)
helpmenu = Menu(menubar, tearoff=0)
helpmenu.add_command(label="Help Index", command=donothing)
helpmenu.add_command(label="About...", command=donothing)
menubar.add_cascade(label="Help", menu=helpmenu)
root.config(menu=menubar)
root.mainloop()
When the above code is executed, it produces the following resultTkinter Message
This widget provides a multiline and noneditable object that displays texts, automatically
breaking lines and justifying their contents.
Its functionality is very similar to the one provided by the Label widget, except that it can
also automatically wrap the text, maintaining a given width or aspect ratio.
Syntax
Python 3
447
Here is the simple syntax to create this widgetw = Message ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
anchor This options controls where the text is positioned if the widget has
more space than the text needs. The default is anchor=CENTER, which
centers the text in the available space.
bg The normal background color displayed behind the label and indicator.
bitmap Set this option equal to a bitmap or image object and the label will
display that graphic.
bd The size of the border around the indicator. Default is 2 pixels.
cursor If you set this option to a cursor name (arrow, dot etc.), the mouse
cursor will change to that pattern when it is over the checkbutton.
font If you are displaying text in this label (with the text or textvariable
option, the font option specifies in what font that text will be displayed.
fg If you are displaying text or a bitmap in this label, this option specifies
the color of the text. If you are displaying a bitmap, this is the color
that will appear at the position of the 1-bits in the bitmap.
height The vertical dimension of the new frame.
image To display a static image in the label widget, set this option to an
image object.
justify Specifies how multiple lines of text will be aligned with respect to each
other: LEFT for flush left, CENTER for centered (the default), or RIGHT
for right-justified.
Python 3
448
padx Extra space added to the left and right of the text within the widget.
Default is 1.
pady Extra space added above and below the text within the widget. Default
is 1.
relief Specifies the appearance of a decorative border around the label. The
default is FLAT; for other values.
text To display one or more lines of text in a label widget, set this option
to a string containing the text. Internal newlines ("\n") will force a line
break.
textvariable To slave the text displayed in a label widget to a control variable of
class StringVar, set this option to that variable.
underline You can display an underline (_) below the nth letter of the text,
counting from 0, by setting this option to n. The default is underline=-
1, which means no underlining.
width Width of the label in characters (not pixels!). If this option is not set,
the label will be sized to fit its contents.
wraplength You can limit the number of characters in each line by setting this
option to the desired number. The default value, 0, means that lines
will be broken only at newlines.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
root = Tk()
var = StringVar()
label = Message( root, textvariable=var, relief=RAISED )
var.set("Hey!? How are you doing?")
label.pack()
Python 3
449
root.mainloop()
When the above code is executed, it produces the following resultTkinter Radiobutton
This widget implements a multiple-choice button, which is a way to offer many possible
selections to the user and lets user choose only one of them.
In order to implement this functionality, each group of radiobuttons must be associated to
the same variable and each one of the buttons must symbolize a single value. You can use
the Tab key to switch from one radionbutton to another.
Syntax
Here is the simple syntax to create this widgetw = Radiobutton ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
activebackground The background color when the mouse is over the radiobutton.
activeforeground The foreground color when the mouse is over the radiobutton.
anchor If the widget inhabits a space larger than it needs, this option
specifies where the radiobutton will sit in that space. The default
is anchor=CENTER.
bg The normal background color behind the indicator and label.
Python 3
450
bitmap To display a monochrome image on a radiobutton, set this
option to a bitmap.
borderwidth The size of the border around the indicator part itself. Default is
2 pixels.
command A procedure to be called every time the user changes the state
of this radiobutton.
cursor If you set this option to a cursor name (arrow, dot etc.), the
mouse cursor will change to that pattern when it is over the
radiobutton.
font The font used for the text.
fg The color used to render the text.
height The number of lines (not pixels) of text on the radiobutton.
Default is 1.
highlightbackground The color of the focus highlight when the radiobutton does not
have focus.
highlightcolor The color of the focus highlight when the radiobutton has the
focus.
image To display a graphic image instead of text for this radiobutton,
set this option to an image object.
justify If the text contains multiple lines, this option controls how the
text is justified: CENTER (the default), LEFT, or RIGHT.
padx How much space to leave to the left and right of the radiobutton
and text. Default is 1.
pady How much space to leave above and below the radiobutton and
text. Default is 1.
relief Specifies the appearance of a decorative border around the
label. The default is FLAT; for other values.
selectcolor The color of the radiobutton when it is set. Default is red.
Python 3
451
selectimage If you are using the image option to display a graphic instead of
text when the radiobutton is cleared, you can set the
selectimage option to a different image that will be displayed
when the radiobutton is set.
state The default is state=NORMAL, but you can set state=DISABLED
to gray out the control and make it unresponsive. If the cursor
is currently over the radiobutton, the state is ACTIVE.
text The label displayed next to the radiobutton. Use newlines ("\n")
to display multiple lines of text.
textvariable To slave the text displayed in a label widget to a control variable
of class StringVar, set this option to that variable.
underline You can display an underline (_) below the nth letter of the text,
counting from 0, by setting this option to n. The default is
underline=-1, which means no underlining.
value When a radiobutton is turned on by the user, its control variable
is set to its current value option. If the control variable is
an IntVar, give each radiobutton in the group a different integer
value option. If the control variable is aStringVar, give each
radiobutton a different string value option.
variable The control variable that this radiobutton shares with the other
radiobuttons in the group. This can be either an IntVar or a
StringVar.
width Width of the label in characters (not pixels!). If this option is not
set, the label will be sized to fit its contents.
wraplength You can limit the number of characters in each line by setting
this option to the desired number. The default value, 0, means
that lines will be broken only at newlines.
Methods
These methods are available.
Methods Description
deselect() Clears (turns off) the radiobutton.
Python 3
452
flash() Flashes the radiobutton a few times between its active and normal
colors, but leaves it the way it started.
invoke() You can call this method to get the same actions that would occur if
the user clicked on the radiobutton to change its state.
select() Sets (turns on) the radiobutton.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
def sel():
 selection = "You selected the option " + str(var.get())
 label.config(text = selection)
root = Tk()
var = IntVar()
R1 = Radiobutton(root, text="Option 1", variable=var, value=1,
 command=sel)
R1.pack( anchor = W )
R2 = Radiobutton(root, text="Option 2", variable=var, value=2,
 command=sel)
R2.pack( anchor = W )
R3 = Radiobutton(root, text="Option 3", variable=var, value=3,
 command=sel)
R3.pack( anchor = W)
label = Label(root)
label.pack()
root.mainloop()
Python 3
453
When the above code is executed, it produces the following resultTkinter Scale
The Scale widget provides a graphical slider object that allows you to select values from a
specific scale.
Syntax
Here is the simple syntax to create this widgetw = Scale ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
activebackground The background color when the mouse is over the scale.
bg The background color of the parts of the widget that are outside
the trough.
bd Width of the 3-d border around the trough and slider. Default is
2 pixels.
command A procedure to be called every time the slider is moved. This
procedure will be passed one argument, the new scale value. If
the slider is moved rapidly, you may not get a callback for every
possible position, but you'll certainly get a callback when it
settles.
Python 3
454
cursor If you set this option to a cursor name (arrow, dot etc.), the
mouse cursor will change to that pattern when it is over the
scale.
digits The way your program reads the current value shown in a scale
widget is through a control variable. The control variable for a
scale can be an IntVar, a DoubleVar (float), or a StringVar. If it
is a string variable, the digits option controls how many digits
to use when the numeric scale value is converted to a string.
font The font used for the label and annotations.
fg The color of the text used for the label and annotations.
from_ A float or integer value that defines one end of the scale's range.
highlightbackground The color of the focus highlight when the scale does not have
focus.
highlightcolor The color of the focus highlight when the scale has the focus.
label You can display a label within the scale widget by setting this
option to the label's text. The label appears in the top left corner
if the scale is horizontal, or the top right corner if vertical. The
default is no label.
length The length of the scale widget. This is the x dimension if the
scale is horizontal, or the y dimension if vertical. The default is
100 pixels.
orient Set orient=HORIZONTAL if you want the scale to run along the
x dimension, or orient=VERTICAL to run parallel to the y-axis.
Default is horizontal.
relief Specifies the appearance of a decorative border around the
label. The default is FLAT; for other values.
repeatdelay This option controls how long button 1 has to be held down in
the trough before the slider starts moving in that direction
repeatedly. Default is repeatdelay=300, and the units are
milliseconds.
resolution Normally, the user will only be able to change the scale in whole
units. Set this option to some other value to change the smallest 
Python 3
455
increment of the scale's value. For example, if from_=-1.0 and
to=1.0, and you set resolution=0.5, the scale will have 5
possible values: -1.0, -0.5, 0.0, +0.5, and +1.0.
showvalue Normally, the current value of the scale is displayed in text form
by the slider (above it for horizontal scales, to the left for vertical
scales). Set this option to 0 to suppress that label.
sliderlength Normally the slider is 30 pixels along the length of the scale.
You can change that length by setting the sliderlength option to
your desired length.
state Normally, scale widgets respond to mouse events, and when
they have the focus, also keyboard events. Set state=DISABLED
to make the widget unresponsive.
takefocus Normally, the focus will cycle through scale widgets. Set this
option to 0 if you don't want this behavior.
tickinterval To display periodic scale values, set this option to a number,
and ticks will be displayed on multiples of that value. For
example, if from_=0.0, to=1.0, and tickinterval=0.25, labels
will be displayed along the scale at values 0.0, 0.25, 0.50, 0.75,
and 1.00. These labels appear below the scale if horizontal, to
its left if vertical. Default is 0, which suppresses display of ticks.
to A float or integer value that defines one end of the scale's range;
the other end is defined by the from_ option, discussed above.
The to value can be either greater than or less than the from_
value. For vertical scales, the to value defines the bottom of the
scale; for horizontal scales, the right end.
troughcolor The color of the trough.
variable The control variable for this scale, if any. Control variables may
be from class IntVar, DoubleVar (float), or StringVar. In the
latter case, the numerical value will be converted to a string.
width The width of the trough part of the widget. This is the x
dimension for vertical scales and the y dimension if the scale
has orient=HORIZONTAL. Default is 15 pixels.
Methods
Scale objects have these methods-
Python 3
456
Methods Description
get() This method returns the current value of the scale.
set ( value ) Sets the scale's value.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
def sel():
 selection = "Value = " + str(var.get())
 label.config(text = selection)
root = Tk()
var = DoubleVar()
scale = Scale( root, variable = var )
scale.pack(anchor=CENTER)
button = Button(root, text="Get Scale Value", command=sel)
button.pack(anchor=CENTER)
label = Label(root)
label.pack()
root.mainloop()
When the above code is executed, it produces the following result-
Python 3
457
Tkinter Scrollbar
This widget provides a slide controller that is used to implement vertical scrolled widgets,
such as Listbox, Text and Canvas. Note that you can also create horizontal scrollbars on
Entry widgets.
Syntax
Here is the simple syntax to create this widgetw = Scrollbar ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
activebackground The color of the slider and arrowheads when the mouse is over
them.
bg The color of the slider and arrowheads when the mouse is not
over them.
bd The width of the 3-d borders around the entire perimeter of the
trough, and also the width of the 3-d effects on the arrowheads
and slider. Default is no border around the trough, and a 2-pixel
border around the arrowheads and slider.
command A procedure to be called whenever the scrollbar is moved.
Python 3
458
cursor The cursor that appears when the mouse is over the scrollbar.
elementborderwidth The width of the borders around the arrowheads and slider. The
default is elementborderwidth=-1, which means to use the
value of the borderwidth option.
highlightbackground The color of the focus highlight when the scrollbar does not have
focus.
highlightcolor The color of the focus highlight when the scrollbar has the focus.
highlightthickness The thickness of the focus highlight. Default is 1. Set to 0 to
suppress display of the focus highlight.
jump This option controls what happens when a user drags the slider.
Normally (jump=0), every small drag of the slider causes the
command callback to be called. If you set this option to 1, the
callback isn't called until the user releases the mouse button.
orient Set orient=HORIZONTAL for a horizontal scrollbar,
orient=VERTICAL for a vertical one.
repeatdelay This option controls how long button 1 has to be held down in
the trough before the slider starts moving in that direction
repeatedly. Default is repeatdelay=300, and the units are
milliseconds.
repeatinterval repeatinterval
takefocus Normally, you can tab the focus through a scrollbar widget. Set
takefocus=0 if you don't want this behavior.
troughcolor The color of the trough.
width Width of the scrollbar (its y dimension if horizontal, and its x
dimension if vertical). Default is 16.
Methods
Scrollbar objects have these methodsMethods Description
Python 3
459
get() Returns two numbers (a, b) describing the current position of the
slider. The a value gives the position of the left or top edge of the
slider, for horizontal and vertical scrollbars respectively; the b value
gives the position of the right or bottom edge.
set ( first, last ) To connect a scrollbar to another widget w, set w's xscrollcommand
or yscrollcommand to the scrollbar's set() method. The arguments
have the same meaning as the values returned by the get() method.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
root = Tk()
scrollbar = Scrollbar(root)
scrollbar.pack( side = RIGHT, fill=Y )
mylist = Listbox(root, yscrollcommand = scrollbar.set )
for line in range(100):
 mylist.insert(END, "This is line number " + str(line))
mylist.pack( side = LEFT, fill = BOTH )
scrollbar.config( command = mylist.yview )
mainloop()
When the above code is executed, it produces the following result-
Python 3
460
Tkinter Text
Text widgets provide advanced capabilities that allow you to edit a multiline text and
format the way it has to be displayed, such as changing its color and font.
You can also use elegant structures like tabs and marks to locate specific sections of the
text, and apply changes to those areas. Moreover, you can embed windows and images in
the text because this widget was designed to handle both plain and formatted text.
Syntax
Here is the simple syntax to create this widgetw = Text ( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
bg The default background color of the text widget.
bd The width of the border around the text widget. Default is 2
pixels.
cursor The cursor that will appear when the mouse is over the text
widget.
exportselection Normally, text selected within a text widget is exported to be
the selection in the window manager. Set exportselection=0 if
you don't want that behavior.
font The default font for text inserted into the widget.
fg The color used for text (and bitmaps) within the widget. You can
change the color for tagged regions; this option is just the
default.
height The height of the widget in lines (not pixels!), measured
according to the current font size.
Python 3
461
highlightbackground The color of the focus highlight when the text widget does not
have focus.
highlightcolor The color of the focus highlight when the text widget has the
focus.
highlightthickness The thickness of the focus highlight. Default is 1. Set
highlightthickness=0 to suppress display of the focus highlight.
insertbackground The color of the insertion cursor. Default is black.
insertborderwidth Size of the 3-D border around the insertion cursor. Default is 0.
insertofftime The number of milliseconds the insertion cursor is off during its
blink cycle. Set this option to zero to suppress blinking. Default
is 300.
insertontime The number of milliseconds the insertion cursor is on during its
blink cycle. Default is 600.
insertwidth Width of the insertion cursor (its height is determined by the
tallest item in its line). Default is 2 pixels.
padx The size of the internal padding added to the left and right of
the text area. Default is one pixel.
pady The size of the internal padding added above and below the text
area. Default is one pixel.
relief The 3-D appearance of the text widget. Default is
relief=SUNKEN.
selectbackground The background color to use displaying selected text.
selectborderwidth The width of the border to use around selected text.
spacing1 This option specifies how much extra vertical space is put above
each line of text. If a line wraps, this space is added only before
the first line it occupies on the display. Default is 0.
Python 3
462
spacing2 This option specifies how much extra vertical space to add
between displayed lines of text when a logical line wraps.
Default is 0.
spacing3 This option specifies how much extra vertical space is added
below each line of text. If a line wraps, this space is added only
after the last line it occupies on the display. Default is 0.
state Normally, text widgets respond to keyboard and mouse events;
set state=NORMAL to get this behavior. If you set
state=DISABLED, the text widget will not respond, and you
won't be able to modify its contents programmatically either.
tabs This option controls how tab characters position text.
width The width of the widget in characters (not pixels!), measured
according to the current font size.
wrap This option controls the display of lines that are too wide. Set
wrap=WORD and it will break the line after the last word that
will fit. With the default behavior, wrap=CHAR, any line that
gets too long will be broken at any character.
xscrollcommand To make the text widget horizontally scrollable, set this option
to the set() method of the horizontal scrollbar.
yscrollcommand To make the text widget vertically scrollable, set this option to
the set() method of the vertical scrollbar.
Methods
Text objects have these methodsMethods & Description
delete(startindex [,endindex])
This method deletes a specific character or a range of text.
get(startindex [,endindex])
This method returns a specific character or a range of text.
index(index)
Returns the absolute value of an index based on the given index.
Python 3
463
insert(index [,string]...)
This method inserts strings at the specified index location.
see(index)
This method returns true if the text located at the index position is visible.
Text widgets support three distinct helper structures: Marks, Tabs, and IndexesMarks are used to bookmark positions between two characters within a given text. We
have the following methods available when handling marks:
Methods & Description
index(mark)
Returns the line and column location of a specific mark.
mark_gravity(mark [,gravity])
Returns the gravity of the given mark. If the second argument is provided, the
gravity is set for the given mark.
mark_names()
Returns all marks from the Text widget.
mark_set(mark, index)
Informs a new position to the given mark.
mark_unset(mark)
Removes the given mark from the Text widget.
Tags are used to associate names to regions of text which makes easy the task of
modifying the display settings of specific text areas. Tags are also used to bind event
callbacks to specific ranges of text.
Following are the available methods for handling tabsMethods & Description
tag_add(tagname, startindex[,endindex] ...)
This method tags either the position defined by startindex, or a range delimited by the
positions startindex and endindex.
tag_config
You can use this method to configure the tag properties, which include, justify(center,
left, or right), tabs(this property has the same functionality of the Text widget tabs's
property), and underline(used to underline the tagged text).
Python 3
464
tag_delete(tagname)
This method is used to delete and remove a given tag.
tag_remove(tagname [,startindex[.endindex]] ...)
After applying this method, the given tag is removed from the provided area without
deleting the actual tag definition.
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
root = Tk()
text = Text(root)
text.insert(INSERT, "Hello.....")
text.insert(END, "Bye Bye.....")
text.pack()
text.tag_add("here", "1.0", "1.4")
text.tag_add("start", "1.8", "1.13")
text.tag_config("here", background="yellow", foreground="blue")
text.tag_config("start", background="black", foreground="green")
root.mainloop()
When the above code is executed, it produces the following resultTkinter Toplevel
Toplevel widgets work as windows that are directly managed by the window manager.
They do not necessarily have a parent widget on top of them.
Your application can use any number of top-level windows.
Python 3
465
Syntax
Here is the simple syntax to create this widgetw = Toplevel ( option, ... )
Parameters
options: Here is the list of most commonly used options for this widget. These options
can be used as key-value pairs separated by commas.
Options Description
bg The background color of the window.
bd Border width in pixels; default is 0.
cursor The cursor that appears when the mouse is in this window.
class_ Normally, text selected within a text widget is exported to be the
selection in the window manager. Set exportselection=0 if you don't
want that behavior.
font The default font for text inserted into the widget.
fg The color used for text (and bitmaps) within the widget. You can
change the color for tagged regions; this option is just the default.
height Window height.
relief Normally, a top-level window will have no 3-d borders around it. To
get a shaded border, set the bd option larger that its default value of
zero, and set the relief option to one of the constants.
width The desired width of the window.
Methods
Toplevel objects have these methodsMethods and Description
deiconify()
Python 3
466
Displays the window, after using either the iconify or the withdraw methods.
frame()
Returns a system-specific window identifier.
group(window)
Adds the window to the window group administered by the given window.
iconify()
Turns the window into an icon, without destroying it.
protocol(name, function)
Registers a function as a callback which will be called for the given protocol.
iconify()
Turns the window into an icon, without destroying it.
state()
Returns the current state of the window. Possible values are normal, iconic, withdrawn
and icon.
transient([master])
Turns the window into a temporary(transient) window for the given master or to the
window's parent, when no argument is given.
withdraw()
Removes the window from the screen, without destroying it.
maxsize(width, height)
Defines the maximum size for this window.
minsize(width, height)
Defines the minimum size for this window.
positionfrom(who)
Defines the position controller.
Python 3
467
resizable(width, height)
Defines the resize flags, which control whether the window can be resized.
sizefrom(who)
Defines the size controller.
title(string)
Defines the window title.
Example
Try following example yourself-
# !/usr/bin/python3
from tkinter import *
root = Tk()
root.title("hello")
top = Toplevel()
top.title("Python")
top.mainloop()
When the above code is executed, it produces the following resultTkinter Spinbox
The Spinbox widget is a variant of the standard Tkinter Entry widget, which can be used
to select from a fixed number of values.
Python 3
468
Syntax
Here is the simple syntax to create this widgetw = Spinbox( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Options Description
activebackground The color of the slider and arrowheads when the mouse is over
them.
bg The color of the slider and arrowheads when the mouse is not
over them.
bd The width of the 3-d borders around the entire perimeter of the
trough, and also the width of the 3-d effects on the arrowheads
and slider. Default is no border around the trough, and a 2-pixel
border around the arrowheads and slider.
command A procedure to be called whenever the scrollbar is moved.
cursor The cursor that appears when the mouse is over the scrollbar.
disabledbackground The background color to use when the widget is disabled.
disabledforeground The text color to use when the widget is disabled.
fg Text color.
font The font to use in this widget.
format Format string. No default value.
from_ The minimum value. Used together with to to limit the spinbox
range.
Python 3
469
justify Default is LEFT
relief Default is SUNKEN.
repeatdelay Together with repeatinterval, this option controls button autorepeat. Both values are given in milliseconds.
repeatinterval See repeatdelay.
state One of NORMAL, DISABLED, or "readonly". Default is NORMAL.
textvariable No default value.
to See from.
validate Validation mode. Default is NONE.
validatecommand Validation callback. No default value.
values A tuple containing valid values for this widget. Overrides
from/to/increment.
vcmd Same as validatecommand.
width Widget width, in character units. Default is 20.
wrap If true, the up and down buttons will wrap around.
xscrollcommand Used to connect a spinbox field to a horizontal scrollbar. This
option should be set to the set method of the corresponding
scrollbar.
Methods
Spinbox objects have these methodsMethods and Description
delete(startindex [,endindex])
This method deletes a specific character or a range of text.
Python 3
470
get(startindex [,endindex])
This method returns a specific character or a range of text.
identify(x, y)
Identifies the widget element at the given location.
index(index)
Returns the absolute value of an index based on the given index.
insert(index [,string]...)
This method inserts strings at the specified index location.
invoke(element)
Invokes a spinbox button.
Example
Try the following example yourselffrom Tkinter import *
master = Tk()
w = Spinbox(master, from_=0, to=10)
w.pack()
mainloop()
When the above code is execduted, it produces the following result-
Python 3
471
Tkinter PanedWindow
A PanedWindow is a container widget that may contain any number of panes, arranged
horizontally or vertically.
Each pane contains one widget and each pair of panes is separated by a moveable (via
mouse movements) sash. Moving a sash causes the widgets on either side of the sash to
be resized.
Syntax
Here is the simple syntax to create this widgetw = PanedWindow( master, option, ... )
Parameters
 master: This represents the parent window.
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Option Description
bg The color of the slider and arrowheads when the mouse is not over
them.
bd The width of the 3-d borders around the entire perimeter of the trough,
and also the width of the 3-d effects on the arrowheads and slider.
Default is no border around the trough, and a 2-pixel border around
the arrowheads and slider.
borderwidth Default is 2.
cursor The cursor that appears when the mouse is over the window.
handlepad Default is 8.
handlesize Default is 8.
height No default value.
orient Default is HORIZONTAL.
Python 3
472
relief Default is FLAT.
sashcursor No default value.
sashrelief Default is RAISED.
sashwidth Default is 2.
showhandle No default value
width No default value.
Methods
PanedWindow objects have these methodsMethods & Description
add(child, options)
Adds a child window to the paned window.
get(startindex [,endindex])
This method returns a specific character or a range of text.
config(options)
Modifies one or more widget options. If no options are given, the method returns a
dictionary containing all current option values.
Example
Try the following example yourself. Here is how to create a 3-pane widget-
# !/usr/bin/python3
from tkinter import *
Python 3
473
m1 = PanedWindow()
m1.pack(fill=BOTH, expand=1)
left = Entry(m1, bd=5)
m1.add(left)
m2 = PanedWindow(m1, orient=VERTICAL)
m1.add(m2)
top = Scale( m2, orient=HORIZONTAL)
m2.add(top)
bottom = Button(m2, text="OK")
m2.add(bottom)
mainloop()
When the above code is executed, it produces the following resultTkinter LabelFrame
A labelframe is a simple container widget. Its primary purpose is to act as a spacer or
container for complex window layouts.
This widget has the features of a frame plus the ability to display a label.
Syntax
Here is the simple syntax to create this widgetw = LabelFrame( master, option, ... )
Parameters
 master: This represents the parent window.
Python 3
474
 options: Here is the list of most commonly used options for this widget. These
options can be used as key-value pairs separated by commas.
Option Description
bg The normal background color displayed behind the label and
indicator.
bd The size of the border around the indicator. Default is 2 pixels.
cursor If you set this option to a cursor name (arrow, dot etc.), the
mouse cursor will change to that pattern when it is over the
checkbutton.
font The vertical dimension of the new frame.
height The vertical dimension of the new frame.
labelAnchor Specifies where to place the label.
highlightbackground Color of the focus highlight when the frame does not have focus.
highlightcolor Color shown in the focus highlight when the frame has the focus.
highlightthickness Thickness of the focus highlight.
relief With the default value, relief=FLAT, the checkbutton does not
stand out from its background. You may set this option to any
of the other styles
text Specifies a string to be displayed inside the widget.
width Specifies the desired width for the window.
Example
Try the following example yourself. Here is how to create a labelframe widget-
# !/usr/bin/python3
from tkinter import *
Python 3
475
root = Tk()
labelframe = LabelFrame(root, text="This is a LabelFrame")
labelframe.pack(fill="both", expand="yes")
left = Label(labelframe, text="Inside the LabelFrame")
left.pack()
root.mainloop()
When the above code is executed, it produces the following resultTkinter tkMessageBox
The tkMessageBox module is used to display message boxes in your applications. This
module provides a number of functions that you can use to display an appropriate
message.
Some of these functions are showinfo, showwarning, showerror, askquestion, askokcancel,
askyesno, and askretryignore.
Syntax
Here is the simple syntax to create this widgettkMessageBox.FunctionName(title, message [, options])
Parameters
 FunctionName: This is the name of the appropriate message box function.
 title: This is the text to be displayed in the title bar of a message box.
 message: This is the text to be displayed as a message.
 options: options are alternative choices that you may use to tailor a standard
message box. Some of the options that you can use are default and parent. The 
Python 3
476
default option is used to specify the default button, such as ABORT, RETRY, or
IGNORE in the message box. The parent option is used to specify the window on
top of which the message box is to be displayed.
You could use one of the following functions with dialogue box-
 showinfo()
 showwarning()
 showerror ()
 askquestion()
 askokcancel()
 askyesno ()
 askretrycancel ()
Example
Try the following example yourself-
# !/usr/bin/python3
from tkinter import *
from tkinter import messagebox
top = Tk()
top.geometry("100x100")
def hello():
 messagebox.showinfo("Say Hello", "Hello World")
B1 = Button(top, text = "Say Hello", command = hello)
B1.place(x=35,y=50)
top.mainloop()
When the above code is executed, it produces the following result-
Python 3
477
Standard Attributes
Let us look at how some of the common attributes, such as sizes, colors and fonts are
specified.
 Dimensions
 Colors
 Fonts
 Anchors
 Relief styles
 Bitmaps
 Cursors
Let us study them brieflyTkinter Dimensions
Various lengths, widths, and other dimensions of widgets can be described in many
different units.
 If you set a dimension to an integer, it is assumed to be in pixels.
 You can specify units by setting a dimension to a string containing a number
followed by.
Character Description
Python 3
478
c Centimeters
i Inches
m Millimeters
p Printer's points (about 1/72")
Length options
Tkinter expresses a length as an integer number of pixels. Here is the list of common
length options-
 borderwidth: Width of the border which gives a three-dimensional look to the
widget.
 highlightthickness: Width of the highlight rectangle when the widget has focus .
 padX padY: Extra space the widget requests from its layout manager beyond the
minimum the widget needs to display its contents in the x and y directions.
 selectborderwidth: Width of the three-dimentional border around selected items
of the widget.
 wraplength: Maximum line length for widgets that perform word wrapping.
 height: Desired height of the widget; must be greater than or equal to 1.
 underline: Index of the character to underline in the widget's text (0 is the first
character, 1 the second one, and so on).
 width: Desired width of the widget.
Tkinter Colors
Tkinter represents colors with strings. There are two general ways to specify colors in
Tkinter-
 You can use a string specifying the proportion of red, green and blue in hexadecimal
digits. For example, "#fff" is white, "#000000" is black, "#000fff000" is pure green,
and "#00ffff" is pure cyan (green plus blue).
 You can also use any locally defined standard color name. The colors "white",
"black", "red", "green", "blue", "cyan", "yellow", and "magenta" will always be
available.
Python 3
479
Color options
The common color options are-
 activebackground: Background color for the widget when the widget is active.
 activeforeground: Foreground color for the widget when the widget is active.
 background: Background color for the widget. This can also be represented as bg.
 disabledforeground: Foreground color for the widget when the widget is
disabled.
 foreground: Foreground color for the widget. This can also be represented as fg.
 highlightbackground: Background color of the highlight region when the widget
has focus.
 highlightcolor: Foreground color of the highlight region when the widget has
focus.
 selectbackground: Background color for the selected items of the widget.
 selectforeground: Foreground color for the selected items of the widget.
Tkinter Fonts
There may be up to three ways to specify type style.
Simple Tuple Fonts
As a tuple whose first element is the font family, followed by a size in points, optionally
followed by a string containing one or more of the style modifiers bold, italic, underline
and overstrike.
Example
 ("Helvetica", "16") for a 16-point Helvetica regular.
 ("Times", "24", "bold italic") for a 24-point Times bold italic.
Font object Fonts
You can create a "font object" by importing the tkFont module and using its Font class
constructor −
import tkFont
font = tkFont.Font ( option, ... )
Here is the list of options-
Python 3
480
 family: The font family name as a string.
 size: The font height as an integer in points. To get a font n pixels high, use -n.
 weight: "bold" for boldface, "normal" for regular weight.
 slant: "italic" for italic, "roman" for unslanted.
 underline: 1 for underlined text, 0 for normal.
 overstrike: 1 for overstruck text, 0 for normal.
Example
helv36 = tkFont.Font(family="Helvetica",size=36,weight="bold")
X Window Fonts
If you are running under the X Window System, you can use any of the X font names.
For example, the font named "-*-lucidatypewriter-medium-r-*-*-*-140-*-*-*-*-*-*" is
the author's favorite fixed-width font for onscreen use. Use thexfontsel program to help
you select pleasing fonts.
Tkinter Anchors
Anchors are used to define where text is positioned relative to a reference point.
Here is list of possible constants, which can be used for Anchor attribute.
 NW
 N
 NE
 W
 CENTER
 E
 SW
 S
 SE
For example, if you use CENTER as a text anchor, the text will be centered horizontally
and vertically around the reference point.
Anchor NW will position the text so that the reference point coincides with the northwest
(top left) corner of the box containing the text.
Anchor W will center the text vertically around the reference point, with the left edge of
the text box passing through that point, and so on.
If you create a small widget inside a large frame and use the anchor=SE option, the widget
will be placed in the bottom right corner of the frame. If you used anchor=N instead, the
widget would be centered along the top edge.
Python 3
481
Example
The anchor constants are shown in this diagramTkinter Relief styles
The relief style of a widget refers to certain simulated 3-D effects around the outside of
the widget. Here is a screenshot of a row of buttons exhibiting all the possible relief stylesHere is list of possible constants which can be used for relief attribute-
 FLAT
 RAISED
 SUNKEN
 GROOVE
 RIDGE
Example
# !/usr/bin/python3
from tkinter import *
import tkinter
top = Tk()
B1 = Button(top, text ="FLAT", relief=FLAT )
Python 3
482
B2 = Button(top, text ="RAISED", relief=RAISED )
B3 = Button(top, text ="SUNKEN", relief=SUNKEN )
B4 = Button(top, text ="GROOVE", relief=GROOVE )
B5 = Button(top, text ="RIDGE", relief=RIDGE )
B1.pack()
B2.pack()
B3.pack()
B4.pack()
B5.pack()
top.mainloop()
When the above code is executed, it produces the following resultTkinter Bitmaps
This attribute to displays a bitmap. There are following type of bitmaps available-
 "error"
 "gray75"
 "gray50"
 "gray25"
 "gray12"
 "hourglass"
 "info"
Python 3
483
 "questhead"
 "question"
 "warning"
Example
# !/usr/bin/python3
from tkinter import *
import tkinter
top = Tk()
B1 = Button(top, text ="error", relief=RAISED,\
 bitmap="error")
B2 = Button(top, text ="hourglass", relief=RAISED,\
 bitmap="hourglass")
B3 = Button(top, text ="info", relief=RAISED,\
 bitmap="info")
B4 = Button(top, text ="question", relief=RAISED,\
 bitmap="question")
B5 = Button(top, text ="warning", relief=RAISED,\
 bitmap="warning")
B1.pack()
B2.pack()
B3.pack()
B4.pack()
B5.pack()
top.mainloop()
When the above code is executed, it produces the following result-
Python 3
484
Tkinter Cursors
Python Tkinter supports quite a number of different mouse cursors available. The exact
graphic may vary according to your operating system.
Here is the list of interesting ones-
 "arrow"
 "circle"
 "clock"
 "cross"
 "dotbox"
 "exchange"
 "fleur"
 "heart"
 "heart"
 "man"
 "mouse"
 "pirate"
 "plus"
 "shuttle"
 "sizing"
 "spider"
 "spraycan"
 "star"
 "target"
 "tcross"
 "trek"
 "watch"
Python 3
485
Example
Try the following example by moving cursor on different buttons-
# !/usr/bin/python3
from tkinter import *
import tkinter
top = Tk()
B1 = Button(top, text ="circle", relief=RAISED,\
 cursor="circle")
B2 = Button(top, text ="plus", relief=RAISED,\
 cursor="plus")
B1.pack()
B2.pack()
top.mainloop()
Geometry Management
All Tkinter widgets have access to the specific geometry management methods, which
have the purpose of organizing widgets throughout the parent widget area. Tkinter
exposes the following geometry manager classes: pack, grid, and place.
 The pack() Method - This geometry manager organizes widgets in blocks before
placing them in the parent widget.
 The grid() Method - This geometry manager organizes widgets in a table-like
structure in the parent widget.
 The place() Method -This geometry manager organizes widgets by placing them in
a specific position in the parent widget.
Let us study the geometry management methods briefly –
Python 3
486
Tkinter pack() Method
This geometry manager organizes widgets in blocks before placing them in the parent
widget.
Syntax
widget.pack( pack_options )
Here is the list of possible options-
 expand: When set to true, widget expands to fill any space not otherwise used in
widget's parent.
 fill: Determines whether widget fills any extra space allocated to it by the packer,
or keeps its own minimal dimensions: NONE (default), X (fill only horizontally), Y
(fill only vertically), or BOTH (fill both horizontally and vertically).
 side: Determines which side of the parent widget packs against: TOP (default),
BOTTOM, LEFT, or RIGHT.
Example
Try the following example by moving cursor on different buttons-
# !/usr/bin/python3
from tkinter import *
root = Tk()
frame = Frame(root)
frame.pack()
bottomframe = Frame(root)
bottomframe.pack( side = BOTTOM )
redbutton = Button(frame, text="Red", fg="red")
redbutton.pack( side = LEFT)
greenbutton = Button(frame, text="Brown", fg="brown")
greenbutton.pack( side = LEFT )
bluebutton = Button(frame, text="Blue", fg="blue")
bluebutton.pack( side = LEFT )
Python 3
487
blackbutton = Button(bottomframe, text="Black", fg="black")
blackbutton.pack( side = BOTTOM)
root.mainloop()
When the above code is executed, it produces the following resultTkinter grid() Method
This geometry manager organizes widgets in a table-like structure in the parent widget.
Syntax
widget.grid( grid_options )
Here is the list of possible options-
 column : The column to put widget in; default 0 (leftmost column).
 columnspan: How many columns widgetoccupies; default 1.
 ipadx, ipady :How many pixels to pad widget, horizontally and vertically, inside
widget's borders.
 padx, pady : How many pixels to pad widget, horizontally and vertically, outside
v's borders.
 row: The row to put widget in; default the first row that is still empty.
 rowspan : How many rowswidget occupies; default 1.
 sticky : What to do if the cell is larger than widget. By default, with sticky='',
widget is centered in its cell. sticky may be the string concatenation of zero or more
of N, E, S, W, NE, NW, SE, and SW, compass directions indicating the sides and
corners of the cell to which widget sticks.
Example
Try the following example by moving cursor on different buttons-
# !/usr/bin/python3
from tkinter import *
root = Tk( )
Python 3
488
b=0
for r in range(6):
 for c in range(6):
 b=b+1
 Button(root, text=str(b),
 borderwidth=1 ).grid(row=r,column=c)
root.mainloop()
This would produce the following result displaying 12 labels arrayed in a 3 x 4 gridTkinter place() Method
This geometry manager organizes widgets by placing them in a specific position in the
parent widget.
Syntax
widget.place( place_options )
Here is the list of possible options-
 anchor : The exact spot of widget other options refer to: may be N, E, S, W, NE,
NW, SE, or SW, compass directions indicating the corners and sides of widget;
default is NW (the upper left corner of widget)
 bordermode : INSIDE (the default) to indicate that other options refer to the
parent's inside (ignoring the parent's border); OUTSIDE otherwise.
 height, width : Height and width in pixels.
 relheight, relwidth : Height and width as a float between 0.0 and 1.0, as a
fraction of the height and width of the parent widget.
 relx, rely : Horizontal and vertical offset as a float between 0.0 and 1.0, as a
fraction of the height and width of the parent widget.
 x, y : Horizontal and vertical offset in pixels.
Python 3
489
Example
Try the following example by moving cursor on different buttons-
# !/usr/bin/python3
ffrom tkinter import *
top = Tk()
L1 = Label(top, text="Physics")
L1.place(x=10,y=10)
E1 = Entry(top, bd =5)
E1.place(x=60,y=10)
L2=Label(top,text="Maths")
L2.place(x=10,y=50)
E2=Entry(top,bd=5)
E2.place(x=60,y=50)
L3=Label(top,text="Total")
L3.place(x=10,y=150)
E3=Entry(top,bd=5)
E3.place(x=60,y=150)
B = Button(top, text ="Add")
B.place(x=100, y=100)
top.geometry("250x250+10+10")
top.mainloop()
When the above code is executed, it produces the following result-
Python 3
490
Any code that you write using any compiled language like C, C++, or Java can be
integrated or imported into another Python script. This code is considered as an
"extension."
A Python extension module is nothing more than a normal C library. On Unix machines,
these libraries usually end in .so (for shared object). On Windows machines, you typically
see .dll (for dynamically linked library).
Pre-Requisites for Writing Extensions
To start writing your extension, you are going to need the Python header files.
 On Unix machines, this usually requires installing a developer-specific package such
as python2.5-dev.
 Windows users get these headers as part of the package when they use the binary
Python installer.
Additionally, it is assumed that you have a good knowledge of C or C++ to write any
Python Extension using C programming.
First look at a Python Extension
For your first look at a Python extension module, you need to group your code into four
parts-
 The header file Python.h.
 The C functions you want to expose as the interface from your module.
 A table mapping the names of your functions as Python developers see them as C
functions inside the extension module.
 An initialization function.
The Header FilePython.h
You need to include Python.h header file in your C source file, which gives you the access
to the internal Python API used to hook your module into the interpreter.
Make sure to include Python.h before any other headers you might need. You need to
follow the includes with the functions you want to call from Python.
28.Python 3 – Extension Programming with C 
Python 3
491
The C Functions
The signatures of the C implementation of your functions always takes one of the following
three formsstatic PyObject *MyFunction( PyObject *self, PyObject *args );
static PyObject *MyFunctionWithKeywords(PyObject *self,
 PyObject *args,
 PyObject *kw);
static PyObject *MyFunctionWithNoArgs( PyObject *self );
Each one of the preceding declarations returns a Python object. There is no such thing as
a void function in Python as there is in C. If you do not want your functions to return a
value, return the C equivalent of Python's None value. The Python headers define a macro,
Py_RETURN_NONE, that does this for us.
The names of your C functions can be whatever you like as they are never seen outside of
the extension module. They are defined as static function.
Your C functions usually are named by combining the Python module and function names
together, as shown here −
static PyObject *module_func(PyObject *self, PyObject *args) {
 /* Do your stuff here. */
 Py_RETURN_NONE;
}
This is a Python function called func inside the module module. You will be putting pointers
to your C functions into the method table for the module that usually comes next in your
source code.
The Method Mapping Table
This method table is a simple array of PyMethodDef structures. That structure looks
something like thisstruct PyMethodDef {
 char *ml_name;
 PyCFunction ml_meth;
 int ml_flags;
 char *ml_doc;
};
Python 3
492
Here is the description of the members of this structure-
 ml_name: This is the name of the function as the Python interpreter presents
when it is used in Python programs.
 ml_meth: This is the address of a function that has any one of the signatures,
described in the previous section.
 ml_flags: This tells the interpreter which of the three signatures ml_meth is using.
o This flag usually has a value of METH_VARARGS.
o This flag can be bitwise OR'ed with METH_KEYWORDS if you want to allow
keyword arguments into your function.
o This can also have a value of METH_NOARGS that indicates you do not want
to accept any arguments.
 ml_doc: This is the docstring for the function, which could be NULL if you do not
feel like writing one.
This table needs to be terminated with a sentinel that consists of NULL and 0 values for
the appropriate members.
Example
For the above-defined function, we have the following method mapping tablestatic PyMethodDef module_methods[] = {
 { "func", (PyCFunction)module_func, METH_NOARGS, NULL },
 { NULL, NULL, 0, NULL }
};
The Initialization Function
The last part of your extension module is the initialization function. This function is called
by the Python interpreter when the module is loaded. It is required that the function be
named initModule, where Module is the name of the module.
The initialization function needs to be exported from the library you will be building. The
Python headers define PyMODINIT_FUNC to include the appropriate incantations for that
to happen for the particular environment in which we are compiling. All you have to do is
use it when defining the function.
Your C initialization function generally has the following overall structurePyMODINIT_FUNC initModule() {
 Py_InitModule3(func, module_methods, "docstring...");
}
Python 3
493
Here is the description of Py_InitModule3 function-
 func: This is the function to be exported.
 module_methods: This is the mapping table name defined above.
 docstring: This is the comment you want to give in your extension.
Putting all this together, it looks like the following-
#include <Python.h>
static PyObject *module_func(PyObject *self, PyObject *args) {
 /* Do your stuff here. */
 Py_RETURN_NONE;
}
static PyMethodDef module_methods[] = {
 { "func", (PyCFunction)module_func, METH_NOARGS, NULL },
 { NULL, NULL, 0, NULL }
};
PyMODINIT_FUNC initModule() {
 Py_InitModule3(func, module_methods, "docstring...");
}
Example
A simple example that makes use of all the above concepts-
#include <Python.h>
static PyObject* helloworld(PyObject* self)
{
 return Py_BuildValue("s", "Hello, Python extensions!!");
}
static char helloworld_docs[] =
 "helloworld( ): Any message you want to put here!!\n";
static PyMethodDef helloworld_funcs[] = {
 {"helloworld", (PyCFunction)helloworld,
 METH_NOARGS, helloworld_docs},
Python 3
494
 {NULL}
};
void inithelloworld(void)
{
 Py_InitModule3("helloworld", helloworld_funcs,
 "Extension module example!");
}
Here the Py_BuildValue function is used to build a Python value. Save above code in hello.c
file. We would see how to compile and install this module to be called from Python script.
Building and Installing Extensions
The distutils package makes it very easy to distribute Python modules, both pure Python
and extension modules, in a standard way. Modules are distributed in the source form,
built and installed via a setup script usually called setup.pyas.
For the above module, you need to prepare the following setup.py script −
from distutils.core import setup, Extension
setup(name='helloworld', version='1.0', \
 ext_modules=[Extension('helloworld', ['hello.c'])])
Now, use the following command, which would perform all needed compilation and linking
steps, with the right compiler and linker commands and flags, and copies the resulting
dynamic library into an appropriate directory-
$ python setup.py install
On Unix-based systems, you will most likely need to run this command as root in order to
have permissions to write to the site-packages directory. This usually is not a problem on
Windows.
Importing Extensions
Once you install your extensions, you would be able to import and call that extension in
your Python script as follows-
#!/usr/bin/python3
import helloworld
print helloworld.helloworld()
This would produce the following resultHello, Python extensions!!
Python 3
495
Passing Function Parameters
As you will most likely want to define functions that accept arguments, you can use one
of the other signatures for your C functions. For example, the following function, that
accepts some number of parameters, would be defined like thisstatic PyObject *module_func(PyObject *self, PyObject *args) {
 /* Parse args and do something interesting here. */
 Py_RETURN_NONE;
}
The method table containing an entry for the new function would look like thisstatic PyMethodDef module_methods[] = {
 { "func", (PyCFunction)module_func, METH_NOARGS, NULL },
 { "func", module_func, METH_VARARGS, NULL },
 { NULL, NULL, 0, NULL }
};
You can use the API PyArg_ParseTuple function to extract the arguments from the one
PyObject pointer passed into your C function.
The first argument to PyArg_ParseTuple is the args argument. This is the object you will
be parsing. The second argument is a format string describing the arguments as you
expect them to appear. Each argument is represented by one or more characters in the
format string as follows.
static PyObject *module_func(PyObject *self, PyObject *args) {
 int i;
 double d;
 char *s;
 if (!PyArg_ParseTuple(args, "ids", &i, &d, &s)) {
 return NULL;
 }

 /* Do something interesting here. */
 Py_RETURN_NONE;
}
Compiling the new version of your module and importing it enables you to invoke the new
function with any number of arguments of any typemodule.func(1, s="three", d=2.0)
module.func(i=1, d=2.0, s="three")
Python 3
496
module.func(s="three", d=2.0, i=1)
You can probably come up with even more variations.
ThePyArg_ParseTuple Function
Here is the standard signature for the PyArg_ParseTuple function=
int PyArg_ParseTuple(PyObject* tuple,char* format,...)
This function returns 0 for errors, and a value not equal to 0 for success. Tuple is the
PyObject* that was the C function's second argument. Here format is a C string that
describes mandatory and optional arguments.
Here is a list of format codes for the PyArg_ParseTuple functionCode C type Meaning
c char A Python string of length 1 becomes a C char.
d double A Python float becomes a C double.
f float A Python float becomes a C float.
i int A Python int becomes a C int.
l long A Python int becomes a C long.
L long long A Python int becomes a C long long
O PyObject* Gets non-NULL borrowed reference to Python argument.
s char* Python string without embedded nulls to C char*.
s# char*+int Any Python string to C address and length.
t# char*+int Read-only single-segment buffer to C address and
length.
u Py_UNICODE* Python Unicode without embedded nulls to C.
u# Py_UNICODE*+int Any Python Unicode C address and length.
Python 3
497
w# char*+int Read/write single-segment buffer to C address and
length.
z char* Like s, also accepts None (sets C char* to NULL).
z# char*+int Like s#, also accepts None (sets C char* to NULL).
(...) as per ... A Python sequence is treated as one argument per item.
| The following arguments are optional.
: Format end, followed by function name for error
messages.
; Format end, followed by entire error message text.
Returning Values
Py_BuildValue takes in a format string much like PyArg_ParseTuple does. Instead of
passing in the addresses of the values you are building, you pass in the actual values.
Here is an example showing how to implement an add functionstatic PyObject *foo_add(PyObject *self, PyObject *args) {
 int a;
 int b;
 if (!PyArg_ParseTuple(args, "ii", &a, &b)) {
 return NULL;
 }
 return Py_BuildValue("i", a + b);
}
This is what it would look like if implemented in Pythondef add(a, b):
 return (a + b)
You can return two values from your function as follows. This would be captured using a
list in Python.
static PyObject *foo_add_subtract(PyObject *self, PyObject *args) {
 int a;
 int b;
Python 3
498
 if (!PyArg_ParseTuple(args, "ii", &a, &b)) {
 return NULL;
 }
 return Py_BuildValue("ii", a + b, a - b);
}
This is what it would look like if implemented in Pythondef add_subtract(a, b):
 return (a + b, a - b)
ThePy_BuildValueFunction
Here is the standard signature for Py_BuildValue functionPyObject* Py_BuildValue(char* format,...)
Here format is a C string that describes the Python object to build. The following arguments
of Py_BuildValue are C values from which the result is built. ThePyObject* result is a new
reference.
The following table lists the commonly used code strings, of which zero or more are joined
into a string format.
Code C type Meaning
c char A C char becomes a Python string of length 1.
d double A C double becomes a Python float.
f float A C float becomes a Python float.
i int A C int becomes a Python int.
l long A C long becomes a Python int.
N PyObject* Passes a Python object and steals a reference.
O PyObject* Passes a Python object and INCREFs it as normal.
O& convert+void* Arbitrary conversion
Python 3
499
s char* C 0-terminated char* to Python string, or NULL to None.
s# char*+int C char* and length to Python string, or NULL to None.
u Py_UNICODE* C-wide, null-terminated string to Python Unicode, or
NULL to None.
u# Py_UNICODE*+int C-wide string and length to Python Unicode, or NULL to
None.
w# char*+int Read/write single-segment buffer to C address and
length.
z char* Like s, also accepts None (sets C char* to NULL).
z# char*+int Like s#, also accepts None (sets C char* to NULL).
(...) as per ... Builds Python tuple from C values.
[...] as per ... Builds Python list from C values.
{...} as per ... Builds Python dictionary from C values, alternating keys
and values.
Code {...} builds dictionaries from an even number of C values, alternately keys and
values. For example, Py_BuildValue("{issi}",23,"zig","zag",42) returns a dictionary like
Python's {23:'zig','zag':42}.

Python Basics: A Practical Introduction
to Python 3
Real Python
Python Basics: A Practical Introduction to Python 3
Revised and Updated 4th Edition
David Amos, Dan Bader, Joanna Jablonski, Fletcher Heisler
Copyright © Real Python (realpython.com), 2012–2020
For online information and ordering of this and other books by Real
Python, please visit realpython.com. For more information, please
contact us at info@realpython.com.
ISBN: 9781775093329 (paperback)
ISBN: 9781775093336 (electronic)
Cover design by Aldren Santos
Additional editing and proofreading by Jacob Schmitt
“Python” and the Python logos are trademarks or registered trademarks of the Python Software Foundation, used by Real Python with
permission from the Foundation.
Thank you for downloading this ebook. This ebook is licensed for your
personal enjoyment only. This ebook may not be resold or given away
to other people. If you would like to share this book with another person, please purchase an additional copy for each recipient. If you’re
reading this book and did not purchase it, or if it was not purchased for
your use only, then please return to realpython.com/pybasics-book
and purchase your own copy. Thank you for respecting the hard work
behind this book.
This is a sample from “Python Basics: A Practical
Introduction to Python 3”
With the full version of the book you get a complete Python curriculum
to go all the way from beginner to intermediate-level. Every step along
the way is explained and illustrated with short & clear code samples.
Coding exercises within each chapter and our interactive quizzes help
fast-track your progress and ensure you always know what to focus on
next.
Become a fluent Pythonista and gain programming knowledge you
can apply in the real-world, today:
If you enjoyed the sample chapters you can purchase a full
version of the book at realpython.com/pybasics-book
What Pythonistas Say About Python Basics: A Practical Introduction to Python 3
“I love [the book]! The wording is casual, easy to understand, and
makes the information рow well. I never feel lost in the material, and
it’s not too dense so it’s easy for me to review older chapters over and
over.
I’ve looked at over 10 diоerent Python tutorials/books/online courses,
and I’ve probably learned the most from Real Python!”
— Thomas Wong
“Three years later and I still return to my Real Python books when I
need a quick refresher on usage of vital Python commands.”
— Rob Fowler
“I рoundered for a long time trying to teach myself. I slogged through
dozens of incomplete online tutorials. I snoozed through hours of boring screencasts. I gave up on countless crufty books from big-time
publishers. And then I found Real Python.
The easy-to-follow, step-by-step instructions break the big concepts
down into bite-sized chunks written in plain English. The authors
never forget their audience and are consistently thorough and detailed
in their explanations. I’m up and running now, but I constantly refer
to the material for guidance.”
— Jared Nielsen
“I love the book because at the end of each particular lesson there are
real world and interesting challenges. I just built a savings estimator
that actually reрects my savings account – neat!”
— Drew Prescott
“As a practice of what you taught I started building simple scripts for
people on my team to help them in their everyday duties. When my
managers noticed that, I was oоered a new position as a developer.
I know there is heaps of things to learn and there will be huge challenges, but I пnally started doing what I really came to like.
Once again: MANY THANKS!”
— Kamil
“What I found great about the Real Python courses compared to others
is how they explain things in the simplest way possible.
A lot of courses, in any discipline really, require the learning of a lot of
jargon when in fact what is being taught could be taught quickly and
succinctly without too much of it. The courses do a very good job of
keeping the examples interesting.”
— Stephen Grady
“After reading the пrst Real Python course I wrote a script to automate
a mundane task at work. What used to take me three to пve hours now
takes less than ten minutes!”
— Brandon Youngdale
“Honestly, throughout this whole process what I found was just me
looking really hard for things that could maybe be added or improved,
but this tutorial is amazing! You do a wonderful job of explaining and
teaching Python in a way that people like me, a complete novice, could
really grasp.
The рow of the lessons works perfectly throughout. The exercises truly
helped along the way and you feel very accomplished when you пnish
up the book. I think you have a gift for making Python seem more
attainable to people outside the programming world.
This is something I never thought I would be doing or learning and
with a little push from you I am learning it and I can see that it will be
nothing but beneпcial to me in the future!”
— Shea Klusewicz
“The authors of the courses have NOT forgotten what it is like to be
a beginner – something that many authors do – and assume nothing about their readers, which makes the courses fantastic reads. The
courses are also accompanied by some great videos as well as plenty
of references for extra learning, homework assignments and example
code that you can experiment with and extend.
I really liked that there was always full code examples and each line
of code had good comments so you can see what is doing what.
I now have a number of books on Python and the Real Python ones
are the only ones I have actually пnished cover to cover, and they
are hands down the best on the market. If like me, you’re not a programmer (I work in online marketing) you’ll пnd these courses to be
like a mentor due to the clear, рuо-free explanations! Highly recommended!”
— Craig Addyman
About the Authors
At Real Python you’ll learn real-world programming skills from a community of professional Pythonistas from all around the world.
The realpython.com website launched in 2012 and currently helps
more than three million Python developers each month with free
programming tutorials and in-depth learning resources.
Everyone who worked on this book is a practitioner with several years
of professional experience in the software industry. Here are the members of the Real Python tutorial team who worked on Python Basics:
David Amos is the content technical lead for Real Python. After leaving academia in 2015, David worked in various technical positions as
a programmer and data scientist. In 2019, David joined Real Python
full time to pursue his passion for education. He lead the charge on
rewriting and updating the Python Basics curriculum to Python 3.
Dan Bader is the owner and editor in chief of Real Python and the
main developer of the realpython.com learning platform. Dan has
been writing code for more than twenty years and holds a master’s
degree in computer science. He’s the author of Python Tricks, a bestselling programming book for intermediate Python developers.
Joanna Jablonski is the executive editor of Real Python. She likes
natural languages just as much as she likes programming languages.
Her love for puzzles, patterns, and pesky little details led her to follow
a career in translation. It was only a matter of time before she would
fall in love with a new language: Python! She joined Real Python in
2018 and has been helping Pythonistas level up ever since.
Fletcher Heisler is the founder of Hunter2, where he teaches developers how to hack and secure modern web apps. As one of the
founding members of Real Python, Fletcher wrote the first version of
the Python curriculum this book is based on in 2012.
Contents
Contents 8
Foreword 13
1 Introduction 20
1.1 Why This Book? . . . . . . . . . . . . . . . . . . . . 21
1.2 About Real Python . . . . . . . . . . . . . . . . . . 23
1.3 How to Use This Book . . . . . . . . . . . . . . . . . 24
1.4 Bonus Material and Learning Resources . . . . . . . 25
2 Setting Up Python 29
2.1 A Note on Python Versions . . . . . . . . . . . . . . 30
2.2 Windows . . . . . . . . . . . . . . . . . . . . . . . 31
2.3 macOS . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.4 Ubuntu Linux . . . . . . . . . . . . . . . . . . . . . 37
3 Your First Python Program 42
3.1 Write a Python Program . . . . . . . . . . . . . . . 43
3.2 Mess Things Up . . . . . . . . . . . . . . . . . . . . 47
3.3 Create a Variable . . . . . . . . . . . . . . . . . . . 50
3.4 Inspect Values in the Interactive Window . . . . . . 55
3.5 Leave Yourself Helpful Notes . . . . . . . . . . . . . 58
3.6 Summary and Additional Resources . . . . . . . . . 60
4 Strings and String Methods 62
4.1 What Is a String? . . . . . . . . . . . . . . . . . . . 63
4.2 Concatenation, Indexing, and Slicing . . . . . . . . . 69
8
Contents
4.3 Manipulate Strings With Methods . . . . . . . . . . 79
4.4 Interact With User Input . . . . . . . . . . . . . . . 85
4.5 Challenge: Pick Apart Your User’s Input . . . . . . . 88
4.6 Working With Strings and Numbers . . . . . . . . . 88
4.7 Streamline Your Print Statements . . . . . . . . . . 94
4.8 Find a String in a String . . . . . . . . . . . . . . . . 96
4.9 Challenge: Turn Your User Into a L33t H4x0r . . . . 99
4.10 Summary and Additional Resources . . . . . . . . . 100
5 Numbers and Math 102
5.1 Integers and Floating-Point Numbers . . . . . . . . 103
5.2 Arithmetic Operators and Expressions . . . . . . . . 107
5.3 Challenge: Perform Calculations on User Input . . . 115
5.4 Make Python Lie to You . . . . . . . . . . . . . . . . 116
5.5 Math Functions and Number Methods . . . . . . . . 118
5.6 Print Numbers in Style . . . . . . . . . . . . . . . . 123
5.7 Complex Numbers . . . . . . . . . . . . . . . . . . 126
5.8 Summary and Additional Resources . . . . . . . . . 130
6 Functions and Loops 132
6.1 What Is a Function, Really? . . . . . . . . . . . . . . 133
6.2 Write Your Own Functions . . . . . . . . . . . . . . 137
6.3 Challenge: Convert Temperatures . . . . . . . . . . 146
6.4 Run in Circles . . . . . . . . . . . . . . . . . . . . . 147
6.5 Challenge: Track Your Investments . . . . . . . . . . 156
6.6 Understand Scope in Python . . . . . . . . . . . . . 157
6.7 Summary and Additional Resources . . . . . . . . . 162
7 Finding and Fixing Code Bugs 164
7.1 Use the Debug Control Window . . . . . . . . . . . 165
7.2 Squash Some Bugs . . . . . . . . . . . . . . . . . . 171
7.3 Summary and Additional Resources . . . . . . . . . 179
8 Conditional Logic and Control Flow 181
8.1 Compare Values . . . . . . . . . . . . . . . . . . . . 182
8.2 Add Some Logic . . . . . . . . . . . . . . . . . . . . 186
8.3 Control the Flow of Your Program . . . . . . . . . . 194
9
Contents
8.4 Challenge: Find the Factors of a Number . . . . . . . 206
8.5 Break Out of the Pattern . . . . . . . . . . . . . . . 207
8.6 Recover From Errors . . . . . . . . . . . . . . . . . 211
8.7 Simulate Events and Calculate Probabilities . . . . . 217
8.8 Challenge: Simulate a Coin Toss Experiment . . . . . 223
8.9 Challenge: Simulate an Election . . . . . . . . . . . 223
8.10 Summary and Additional Resources . . . . . . . . . 224
9 Tuples, Lists, and Dictionaries 226
9.1 Tuples Are Immutable Sequences . . . . . . . . . . . 227
9.2 Lists Are Mutable Sequences . . . . . . . . . . . . . 237
9.3 Nesting, Copying, and Sorting Tuples and Lists . . . 251
9.4 Challenge: List of lists . . . . . . . . . . . . . . . . . 257
9.5 Challenge: Wax Poetic . . . . . . . . . . . . . . . . 258
9.6 Store Relationships in Dictionaries . . . . . . . . . . 260
9.7 Challenge: Capital City Loop . . . . . . . . . . . . . 270
9.8 How to Pick a Data Structure . . . . . . . . . . . . . 272
9.9 Challenge: Cats With Hats . . . . . . . . . . . . . . 273
9.10 Summary and Additional Resources . . . . . . . . . 274
10 Object-Oriented Programming (OOP) 276
10.1 Define a Class . . . . . . . . . . . . . . . . . . . . . 277
10.2 Instantiate an Object . . . . . . . . . . . . . . . . . 281
10.3 Inherit From Other Classes . . . . . . . . . . . . . . 287
10.4 Challenge: Model a Farm . . . . . . . . . . . . . . . 296
10.5 Summary and Additional Resources . . . . . . . . . 297
11 Modules and Packages 298
11.1 Working With Modules . . . . . . . . . . . . . . . . 299
11.2 Working With Packages . . . . . . . . . . . . . . . . 310
11.3 Summary and Additional Resources . . . . . . . . . 318
12 File Input and Output 320
12.1 Files and the File System . . . . . . . . . . . . . . . 321
12.2 Working With File Paths in Python . . . . . . . . . . 324
12.3 Common File System Operations . . . . . . . . . . . 333
12.4 Challenge: Move All Image Files to a New Directory . 350
10
Contents
12.5 Reading and Writing Files . . . . . . . . . . . . . . 351
12.6 Read and Write CSV Data . . . . . . . . . . . . . . . 366
12.7 Challenge: Create a High Scores List . . . . . . . . . 377
12.8 Summary and Additional Resources . . . . . . . . . 378
13 Installing Packages With pip 379
13.1 Installing Third-Party Packages With pip . . . . . . . 380
13.2 The Pitfalls of Third-Party Packages . . . . . . . . . 390
13.3 Summary and Additional Resources . . . . . . . . . 392
14 Creating and Modifying PDF Files 394
14.1 Extracting Text From a PDF . . . . . . . . . . . . . 395
14.2 Extracting Pages From a PDF . . . . . . . . . . . . . 402
14.3 Challenge: PdfFileSplitter Class . . . . . . . . . . . 409
14.4 Concatenating and Merging PDFs . . . . . . . . . . 410
14.5 Rotating and Cropping PDF Pages . . . . . . . . . . 417
14.6 Encrypting and Decrypting PDFs . . . . . . . . . . . 428
14.7 Challenge: Unscramble a PDF . . . . . . . . . . . . 433
14.8 Creating a PDF File From Scratch . . . . . . . . . . 433
14.9 Summary and Additional Resources . . . . . . . . . 440
15 Working With Databases 442
15.1 An Introduction to SQLite . . . . . . . . . . . . . . 443
15.2 Libraries for Working With Other SQL Databases . . 455
15.3 Summary and Additional Resources . . . . . . . . . 456
16 Interacting With the Web 458
16.1 Scrape and Parse Text From Websites . . . . . . . . 459
16.2 Use an HTML Parser to Scrape Websites . . . . . . . 469
16.3 Interact With HTML Forms . . . . . . . . . . . . . . 475
16.4 Interact With Websites in Real Time . . . . . . . . . 481
16.5 Summary and Additional Resources . . . . . . . . . 485
17 Scientiрc Computing and Graphing 487
17.1 Use NumPy for Matrix Manipulation . . . . . . . . . 488
17.2 Use Matplotlib for Plotting Graphs . . . . . . . . . . 499
17.3 Summary and Additional Resources . . . . . . . . . 522
11
Contents
18 Graphical User Interfaces 523
18.1 Add GUI Elements With EasyGUI . . . . . . . . . . 524
18.2 Example App: PDF Page Rotator . . . . . . . . . . . 536
18.3 Challenge: PDF Page Extraction Application . . . . . 543
18.4 Introduction to Tkinter . . . . . . . . . . . . . . . . 544
18.5 Working With Widgets . . . . . . . . . . . . . . . . 548
18.6 Controlling Layout With Geometry Managers . . . . 573
18.7 Making Your Applications Interactive . . . . . . . . 592
18.8 Example App: Temperature Converter . . . . . . . . 602
18.9 Example App: Text Editor . . . . . . . . . . . . . . 607
18.10 Challenge: Return of the Poet . . . . . . . . . . . . . 616
18.11 Summary and Additional Resources . . . . . . . . . 618
19 Final Thoughts and Next Steps 620
19.1 Free Weekly Tips for Python Developers . . . . . . . 622
19.2 Python Tricks: The Book . . . . . . . . . . . . . . . 622
19.3 Real Python Video Course Library . . . . . . . . . . 623
19.4 Acknowledgements . . . . . . . . . . . . . . . . . . 624
12
Foreword
Hello, and welcome to Python Basics: A Practical Introduction to
Python 3. I hope you’re ready to learn why so many professional and
hobbyist developers are drawn to Python and how you can begin
using it on your own projects, small and large, right away.
This book is targeted at beginners who either know a little programming but not the Python language and ecosystem or are starting fresh
with no programming experience whatsoever.
If you don’t have a computer science degree, don’t worry. David, Dan,
Joanna, and Fletcher will guide you through the important computing concepts while teaching you the Python basics and, just as importantly, skipping the unnecessary details at first.
Python Is a Full-Spectrum Language
When learning a new programming language, you don’t yet have the
experience to judge how well it will serve you in the long run. If you’re
considering learning Python, let me assure you that this is a good
choice. One key reason is that Python is a full-spectrum language.
What do I mean by this? Some languages are very good for beginners.
They hold your hand and make programming super easy. We can go
to the extreme and look at visual languages such as Scratch.
In Scratch, you get blocks that represent programming concepts like
variables, loops, method calls, and so on, and you drag and drop them
on a visual surface. Scratch may be easy to get started with for sim13
Contents
ple programs, but you cannot build professional applications with it.
Name one Fortune 500 company that powers its core business logic
with Scratch.
Come up empty? Me too, because that would be insanity.
Other languages are incredibly powerful for expert developers. The
most popular one in this category is likely C++ and its close relative,
C. Whichever web browser you used today was likely written in C or
C++. Your operating system running that browser was very likely also
built with C/C++. Your favorite first-person shooter or strategy video
game? You nailed it: C/C++.
You can do amazing things with these languages, but they are wholly
unwelcoming to newcomers looking for a gentle introduction.
You might not have read a lot of C++ code. It can almost make your
eyes burn. Here’s an example, a real albeit complex one:
template <typename T>
_Defer<void(*(PID<T>, void (T::*)(void)))
(const PID<T>&, void (T::*)(void))>
defer(const PID<T>& pid, void (T::*method)(void))
{
void (*dispatch)(const PID<T>&, void (T::*)(void)) =
&process::template dispatch<T>;
return std::tr1::bind(dispatch, pid, method);
}
Please, just no.
Both Scratch and C++ are decidedly not what I would call fullspectrum languages. With Scratch, it’s easy to start, but you have to
switch to a “real” language to build real applications. Conversely, you
can build real apps with C++, but there’s no gentle on-ramp. You
dive headfirst into all the complexity of the language, which exists to
support these rich applications.
14
Contents
Python, on the other hand, is special. It is a full-spectrum language.
We often judge the simplicity of a language based on the Hello, World
test. That is, what syntax and actions are necessary to get the language
to output Hello, World to the user? In Python, it couldn’t be simpler:
print("Hello, World")
That’s it! However, I find this an unsatisfying test.
The Hello, World test is useful but really not enough to show the power
or complexity of a language. Let’s try another example. Not everything here needs to make total sense—just follow along to get the Zen
of it. The book covers these concepts and more as you go through. The
next example is certainly something you could write as you get near
the end of the book.
Here’s the new test: What would it take to write a program that accesses an external website, downloads the content to your app in memory, then displays a subsection of that content to the user? Let’s try
that experiment using Python 3 with the help of the requests package
(which needs to be installed—more on that in chapter 12):
import requests
resp = requests.get("http://olympus.realpython.org")
html = resp.text
print(html[86:132])
Incredibly, that’s it! When run, the program outputs something like
this:
<h2>Please log in to access Mount Olympus:</h2>
This is the easy, getting-started side of the Python spectrum. A few
trivial lines can unleash incredible power. Because Python has access
to so many powerful but well-packaged libraries, such as requests, it’s
often described as having batteries included.
15
Contents
So there you have a simple yet powerful starter example. On the realworld side of things, many incredible applications have been written
in Python as well.
YouTube, the world’s most popular video streaming site, is written in
Python and processes more than a million requests per second. Instagram is another example of a Python application. Closer to home, we
even have realpython.com and my sites, such as talkpython.fm.
This full-spectrum aspect of Python means that you can start with
the basics and adopt more advanced features as your application demands grow.
Python Is Popular
You might have heard that Python is popular. It may seem that it
doesn’t really matter how popular a language is so long as you can
build the app you want to build with it.
But, for better or worse, the popularity of a programming language
is a strong indicator of the quality of libraries you’ll have available as
well the number of job openings you’ll find. In short, you should tend
to gravitate toward more popular technologies as there will be more
choices and integrations available.
So, is Python actually that popular? Yes it is. You’ll find a lot of
hype and hyperbole, but there are plenty of stats backing this claim.
Let’s look at some analytics presented by stackoverflow.com, a popular question-and-answer site for programmers.
Stack Overflow runs a site called Stack Overflow Trends where you can
look at the trends for various technologies by tag. When you compare
16
Contents
Python to the other likely candidates you could pick to learn programming, you’ll see one is unlike the others:
You can explore this chart and create similar charts to this one over at
insights.stackoverflow.com/trends.
Notice the incredible growth of Python compared to the flat or even
downward trend of the other usual candidates! If you’re betting your
future on the success of a given technology, which one would you
choose from this list?
That’s just one chart—what does it really tell us? Well, let’s look at
another. Stack Overflow does a yearly survey of developers. It’s comprehensive and very well done. You can find the full 2020 results at
insights.stackoverflow.com/survey/2020.
From that writeup, I’d like to call your attention to a section titled
“Most Loved, Dreaded, and Wanted Languages.” In the “Most
Wanted” section, you’ll find data on the share of “developers who are
not developing with the language or technology but have expressed
interest in developing with it.”
17
Contents
Again, in the graph below, you’ll see that Python is topping the charts
and is well above even second place:
If you agree with me that the relative popularity of a programming
language matters, then Python is clearly a good choice.
We Don’t Need You to Be a Computer Scientist
One other point that I want to emphasize as you start your Python
learning journey is that we don’t need you to be a computer scientist.
If that’s your goal, then great. Learning Python is a powerful step
in that direction. But the invitation to learn programming is often
framed as “We have all these developer jobs going unfilled! We need
software developers!”
That may or may not be true. But, more importantly, programming
(even a little programming) can be a personal superpower for you.
To illustrate this idea, suppose you are a biologist. Should you drop
out of biology and get a job as a front-end web developer? Probably
not. But skills such as the one I opened this foreword with, using requests to get data from the Web, can be incredibly powerful for you as
a biologist.
Rather than manually exporting and scraping data from the Web or
from spreadsheets, you can use Python to scrape thousands of data
sources or spreadsheets in the time it takes you to do just one man18
Contents
ually. Python skills can take your biology power and amplify it well
beyond your colleagues’ to make it your superpower.
Dan and Real Python
Finally, let me leave you with a comment on your authors. Dan Bader
and the other Real Python authors work day in and day out to bring
clear and powerful explanations of Python concepts to all of us via
realpython.com.
They have a unique view into the Python ecosystem and are keyed into
what beginners need to know.
I’m confident leaving you in their hands on this Python journey. Go
forth and learn this amazing language using this great book. Most
importantly, remember to have fun!
— Michael Kennedy, Founder of Talk Python (@mkennedy)
19
Chapter 1
Introduction
Welcome to Real Python’s Python Basics book, fully updated for
Python 3.9! In this book, you’ll learn real-world Python programming techniques, illustrated with useful and interesting examples.
Whether you’re a new programmer or a professional software developer looking to dive into a new language, this book will teach you all
the practical Python that you need to get started on projects of your
own.
No matter what your ultimate goals may be, if you work with a computer at all, then you’ll soon be finding endless ways to improve your
life by automating tasks and solving problems through Python programs that you create.
But what’s so great about Python as a programming language? For
one, Python is open source freeware, meaning you can download it
for free and use it for any purpose, commercial or not.
Python also has an amazing community that has built a number of
useful tools that you can use in your own programs. Need to work
with PDF documents? There’s a comprehensive tool for that. Want to
collect data from web pages? No need to start from scratch!
20
1.1. Why This Book?
Python was built to be easier to use than other programming languages. It’s usually much easier to read Python code and much faster
to write code in Python than in other languages.
For instance, here’s some basic code written in C, another commonly
used programming language:
#include <stdio.h>
int main(void)
{
printf("Hello, World\n");
}
All the program does is show the text Hello, World on the screen. That
was a lot of work to output one phrase! Here’s the same program written in Python:
print("Hello, World")
That’s pretty simple, right? The Python code is faster to write and
easier to read. We find that it looks friendlier and more approachable,
too!
At the same time, Python has all the functionality of other languages
and more. You might be surprised by how many professional products
are built on Python code: Instagram, YouTube, Reddit, Spotify, to
name just a few.
Python is not only a friendly and fun language to learn, but it also powers the technology behind multiple world-class companies and offers
fantastic career opportunities for any programmer who masters it.
1.1 Why This Book?
Let’s face it: there’s an overwhelming amount of information about
Python on the Internet. But many beginners studying on their own
have trouble figuring out what to learn and in what order to learn it.
21
1.1. Why This Book?
You may be asking yourself, What should I learn about Python in the
beginning to get a strong foundation? If so, then this book is for you,
no matter if you’re a complete beginner or if you’ve already dabbled
in Python or other languages.
Python Basics is written in plain English and breaks down the core
concepts that you really need to know into bite-sized chunks. This
means you’ll learn enough to be dangerous with Python, fast.
Instead of just going through a boring list of language features, you’ll
see exactly how the different building blocks fit together and what’s
involved in building real applications and scripts with Python.
Step by step, you’ll master fundamental Python concepts that will help
you get started on your journey toward learning Python.
Many programming books try to cover every last possible variation
of every command, which makes it easy for readers to get lost in the
details. This approach is great if you’re looking for a reference manual,
but it’s a horrible way to learn a programming language. Not only do
you spend most of your time cramming things into your head that
you’ll never use, but you also don’t have any fun!
This book is built on the 80/20 principle, which suggests that you can
learn most of what you need to know by focusing on a few crucial concepts. We’ll cover the commands and techniques used in the vast majority of cases and focus on how to program real-world solutions to
everyday problems.
This way, we guarantee that you will:
• Learn useful programming techniques quickly
• Spend less time struggling with unimportant complications
• Find more practical uses for Python in your own life
• Have more fun in the process
22
1.2. About Real Python
Once you’ve mastered the material in this book, you will have gained
a strong enough foundation that venturing out on your own into more
advanced territory will be a breeze.
What you’ll learn here is based on the first part of the original Real
Python Course initially released in 2012. Over the years, this Python
curriculum has been battle-tested by thousands of Pythonistas, data
scientists, and developers working for companies big and small, including Amazon, Red Hat, and Microsoft.
For Python Basics, we’ve thoroughly expanded, refined, and updated
the material so you can build your Python skills quickly and efficiently.
1.2 About Real Python
At Real Python, you’ll learn real-world programming skills from a
community of professional Pythonistas from all around the world.
The realpython.com website launched in 2012 and currently helps
more than three million Python developers each month with books,
programming tutorials, and other in-depth learning resources.
Everyone who worked on this book is a Python practitioner recruited
from the Real Python team with several years of professional experience in the software industry.
Here’s where you can find Real Python on the Web:
• realpython.com
• @realpython on Twitter
• The Real Python Newsletter
• The Real Python Podcast
23
1.3. How to Use This Book
1.3 How to Use This Book
The first half of this book is a quick but thorough overview of all the
Python fundamentals. You don’t need any prior experience with programming to get started. The second half is focused on finding practical solutions to interesting, real-world coding problems.
If you’re a beginner, then we recommend that you go through the first
half of this book from beginning to end. The second half covers topics
that don’t overlap as much, so you can jump around more easily, but
the chapters do increase in difficulty as you go along.
If you’re a more experienced programmer, then you may find yourself
heading toward the second part of the book right away. But don’t neglect getting a strong foundation in the basics first, and be sure to fill
in any knowledge gaps along the way.
Most sections within a chapter are followed by review exercises to
help you make sure that you’ve mastered all the topics covered. There
are also a number of code challenges, which are more involved and
usually require you to tie together several different concepts from previous chapters.
The practice files that accompany this book also include full solutions
to the challenges as well as some of the trickier exercises. But to get
the most out of the material, you should try your best to solve the challenge problems on your own before looking at the example solutions.
If you’re completely new to programming, then you may want to supplement the first few chapters with additional practice. We recommend working through the entry-level tutorials available for free at
realpython.com to make sure you’re on solid footing.
If you have any questions or feedback about the book, you’re always
welcome to contact us directly.
24
1.4. Bonus Material and Learning Resources
Learning by Doing
This book is all about learning by doing, so be sure to actually type
in the code snippets you encounter in the book. For best results, we
recommend that you avoid copying and pasting the code examples.
You’ll learn the concepts better and pick up the syntax faster if you
type out each line of code yourself. Plus, if you screw up—which is totally normal and happens to all developers on a daily basis—the simple
act of correcting typos will help you learn how to debug your code.
Try to complete the review exercises and code challenges on your own
before getting help from outside resources. With enough practice,
you’ll master this material—and have fun along the way!
How Long Will It Take to Finish This Book?
If you’re already familiar with a programming language, then you
could finish this book in as little as thirty-five to forty hours. If you’re
new to programming, then you may need to spend up to one hundred
hours or more.
Take your time and don’t feel like you have to rush. Programming is a
super-rewarding but complex skill to learn. Good luck on your Python
journey. We’re rooting for you!
1.4 Bonus Material and Learning
Resources
This book comes with a number of free bonus resources and downloads that you can access online at the link below. We’re also maintaining an errata list with corrections there:
realpython.com/python-basics/resources
25
1.4. Bonus Material and Learning Resources
Interactive Quizzes
Most chapters in this book come with a free online quiz to check your
learning progress. You can access the quizzes using the links provided
at the end of the chapter. The quizzes are hosted on the Real Python
website and can be viewed on your phone or computer.
Each quiz takes you through a series of questions related to a particular chapter in the book. Some of them are multiple choice, some will
ask you to type in an answer, and some will require you to write actual Python code. As you make your way through each quiz, it will
keep score of which questions you answered correctly.
At the end of the quiz, you’ll receive a grade based on your result. If
you don’t score 100 percent on your first try, don’t fret! These quizzes
are meant to challenge you. It’s expected that you’ll go through them
several times, improving your score with each run.
Exercises Code Repository
This book has an accompanying code repository on the Web containing example source code as well as the answers to exercises and code
challenges. The repository is broken up by chapter, so you can check
your code against the solutions provided by us after you finish each
chapter. Here’s the link:
realpython.com/python-basics/exercises
Note
The code found in this book has been tested with Python 3.9 on
Windows, macOS, and Linux.
26
1.4. Bonus Material and Learning Resources
Example Code License
The example Python scripts associated with this book are licensed under a Creative Commons Public Domain (CC0) License. This means
that you’re welcome to use any portion of the code for any purpose in
your own programs.
Formatting Conventions
Code blocks will be used to present example code:
# This is Python code:
print("Hello, World")
Terminal commands follow the Unix format:
$ # This is a terminal command:
$ python hello-world.py
(The dollar signs are not part of the command.)
Monospace text will be used to denote a filename: hello-world.py.
Bold text will be used to denote a new or important term.
Keyboard shortcuts will be formatted as follows: Ctrl + S
Menu shortcuts will be formatted as follows: File New File
Notes and important information will be highlighted as follows:
Note
This is a note filled in with placeholder text. The quick brown
fox jumps over the lazy dog. The quick brown Python slithers
over the lazy hog.
27
1.4. Bonus Material and Learning Resources
Feedback and Errata
We welcome ideas, suggestions, feedback, and the occasional rant.
Did you find a topic confusing? Did you find an error in the text or
code? Did we leave out a topic that you’d love to know more about?
We’re always looking to improve our teaching materials. Whatever
the reason, please send in your feedback at the link below:
realpython.com/python-basics/feedback
28
Chapter 2
Setting Up Python
This book is about programming computers with Python. You could
read this book from cover to cover without ever touching a keyboard,
but you’d miss out on the fun part—coding!
To get the most out of this book, you need a computer with Python
installed on it and a way to create, edit, and save Python code files.
In this chapter, you’ll learn how to:
• Install the latest version of Python 3 on your computer
• Open IDLE, Python’s built-in Integrated Development and
Learning Environment
Let’s get started!
29
2.1. A Note on Python Versions
2.1 A Note on Python Versions
Many operating systems, including macOS and Linux, come with
Python preinstalled. The version of Python that comes with your
operating system is called the system Python.
The system Python is used by your operating system and is usually out
of date. It’s essential that you have the most recent version of Python
so that you can successfully follow along with the examples in this
book.
Important
Do not attempt to uninstall the system Python!
You can have multiple versions of Python installed on your computer.
In this chapter, you’ll install the latest version of Python 3 alongside
any system Python that may already exist on your machine.
Note
Even if you already have Python 3.9 installed, it’s still a good
idea to skim this chapter to double-check that your environment is set up for following along with this book.
This chapter is split into three sections: Windows, macOS, and
Ubuntu Linux. Find the section for your operating system and follow
the steps to get set up, then skip ahead to the next chapter.
If you have a different operating system, then check out Real Python’s
“Python 3 Installation & Setup Guide” to see if your OS is covered.
Readers on tablets and mobile devices can refer to the “Online Python
Interpreters” section for some browser-based options.
30
2.2. Windows
2.2 Windows
Follow these steps to install Python 3 and open IDLE on Windows.
Important
The code in this book is tested only against Python installed as
described in this section.
Be aware that if you have installed Python through some other
means, such as Anaconda Python, you may encounter problems
when running some of the code examples.
Install Python
Windows doesn’t typically come with a system Python. Fortunately,
installation involves little more than downloading and running the
Python installer from the Python.org website.
Step 1: Download the Python 3 Installer
Open a web browser and navigate to the following URL:
https://www.python.org/downloads/windows/
Click Latest Python 3 Release - Python 3.x.x located beneath the
“Python Releases for Windows” heading near the top of the page. As
of this writing, the latest version was Python 3.9.
Then scroll to the bottom and click Windows x86-64 executable installer to start the download.
Note
If your system has a 32-bit processor, then you should choose
the 32-bit installer. If you aren’t sure if your computer is 32-bit
or 64-bit, stick with the 64-bit installer mentioned above.
31
2.2. Windows
Step 2: Run the Installer
Open your Downloads folder in Windows Explorer and double-click
the file to run the installer. A dialog that looks like the following one
will appear:
It’s okay if the Python version you see is greater than 3.9.0 as long as
the version is not less than 3.
Important
Make sure you select the box that says Add Python 3.x to PATH.
If you install Python without selecting this box, then you can
run the installer again and select it.
Click Install Now to install Python 3. Wait for the installation to finish,
then continue to open IDLE.
32
2.2. Windows
Open IDLE
You can open IDLE in two steps:
1. Click the Start menu and locate the Python 3.9 folder.
2. Open the folder and select IDLE (Python 3.9).
IDLE opens a Python shell in a new window. The Python shell is an
interactive environment that allows you to type in Python code and
execute it immediately. It’s a great way to get started with Python!
Note
While you’re free to use a code editor other than IDLE if you
prefer, note that some chapters, especially chapter 7, “Finding
and Fixing Code Bugs,” do contain material specific to IDLE.
The Python shell window looks like this:
At the top of the window, you can see the version of Python that is
running and some information about the operating system. If you see
a version less than 3.9, then you may need to revisit the installation
instructions in the previous section.
33
2.3. macOS
The >>> symbol that you see is called a prompt. Whenever you see
this, it means that Python is waiting for you to give it some instructions.
Interactive Quiz
This chapter comes with a free online quiz to check your learning progress. You can access the quiz using your phone or computer at the following web address:
realpython.com/quizzes/pybasics-setup
Now that you have Python installed, let’s get straight into writing your
first Python program! Go ahead and move on to chapter 3.
2.3 macOS
Follow these steps to install Python 3 and open IDLE on macOS.
Important
The code in this book is tested only against Python installed as
described in this section.
Be aware that if you have installed Python through some other
means, such as Anaconda Python, you may encounter problems
when running some of the code examples.
Install Python
To install the latest version of Python 3 on macOS, download and run
the official installer from the Python.org website.
Step 1: Download the Python 3 Installer
Open a web browser and navigate to the following URL:
https://www.python.org/downloads/mac-osx/
34
2.3. macOS
Click Latest Python 3 Release - Python 3.x.x located beneath the
“Python Releases for Mac OS X” heading near the top of the page. As
of this writing, the latest version was Python 3.9.
Then scroll to the bottom of the page and click macOS 64-bit installer
to start the download.
Step 2: Run the Installer
Open Finder and double-click the downloaded file to run the installer.
A dialog box that looks like the following will appear:
Press Continue a few times until you are asked to agree to the software
license agreement. Then click Agree .
You’ll be shown a window that tells you where Python will be installed
and how much space it will take. You most likely don’t want to change
the default location, so go ahead and click Install to start the installation.
35
2.3. macOS
When the installer is finished copying files, click Close to close the
installer window.
Open IDLE
You can open IDLE in three steps:
1. Open Finder and click Applications.
2. Double-click the Python 3.9 folder.
3. Double-click the IDLE icon.
IDLE opens a Python shell in a new window. The Python shell is an
interactive environment that allows you to type in Python code and
execute it immediately. It’s a great way to get started with Python!
Note
While you’re free to use a code editor other than IDLE if you
prefer, note that some chapters, especially chapter 7, “Finding
and Fixing Code Bugs,” do contain material specific to IDLE.
The Python shell window looks like this:
36
2.4. Ubuntu Linux
At the top of the window, you can see the version of Python that is
running and some information about the operating system. If you see
a version less than 3.9, then you may need to revisit the installation
instructions in the previous section.
The >>> symbol that you see is called a prompt. Whenever you see
this, it means that Python is waiting for you to give it some instructions.
Interactive Quiz
This chapter comes with a free online quiz to check your learning progress. You can access the quiz using your phone or computer at the following web address:
realpython.com/quizzes/pybasics-setup
Now that you have Python installed, let’s get straight into writing your
first Python program! Go ahead and move on to chapter 3.
2.4 Ubuntu Linux
Follow these steps to install Python 3 and open IDLE on Ubuntu
Linux.
Important
The code in this book is tested only against Python installed as
described in this section.
Be aware that if you have installed Python through some other
means, such as Anaconda Python, you may encounter problems
when running some of the code examples.
37
2.4. Ubuntu Linux
Install Python
There’s a good chance that your Ubuntu distribution already has
Python installed, but it probably won’t be the latest version, and it
may be Python 2 instead of Python 3.
To find out what version(s) you have, open a terminal window and try
the following commands:
$ python --version
$ python3 --version
One or more of these commands should respond with a version, as
below:
$ python3 --version
Python 3.9.0
Your version number may vary. If the version shown is Python 2.x
or a version of Python 3 that is less than 3.9, then you want to install the latest version. How you install Python on Ubuntu depends
on which version of Ubuntu you’re running. You can determine your
local Ubuntu version by running the following command:
$ lsb_release -a
No LSB modules are available.
Distributor ID: Ubuntu
Description: Ubuntu 18.04.1 LTS
Release: 18.04
Codename: bionic
Look at the version number next to Release in the console output, and
follow the corresponding instructions below.
38
2.4. Ubuntu Linux
Ubuntu 18.04 or Greater
Ubuntu version 18.04 does not come with Python 3.9 by default, but
it is in the Universe repository. You can install it with the following
commands in the Terminal application:
$ sudo apt-get update
$ sudo apt-get install python3.9 idle-python3.9 python3-pip
Note that because the Universe repository is usually behind the
Python release schedule, you may not get the latest version of Python
3.9. However, any version of Python 3.9 will work for this book.
Ubuntu 17 and Lower
For Ubuntu versions 17 and lower, Python 3.9 is not in the Universe
repository. You need to get it from a Personal Package Archive (PPA).
To install Python from the deadsnakes PPA, run the following commands in the Terminal application:
$ sudo add-apt-repository ppa:deadsnakes/ppa
$ sudo apt-get update
$ sudo apt-get install python3.9 idle-python3.9 python3-pip
You can check that the correct version of Python was installed by running python3 --version. If you see a version number less than 3.9, then
you may need to type python3.9 --version. Now you can open IDLE
and get ready to write your first Python program.
Open IDLE
You can open IDLE from the command line by typing the following:
$ idle-python3.9
39
2.4. Ubuntu Linux
On some Linux installations, you can open IDLE with the following
shortened command:
$ idle3
IDLE opens a Python shell in a new window. The Python shell is an
interactive environment that allows you to type in Python code and
execute it immediately. It’s a great way to get started with Python!
Note
While you’re free to use a code editor other than IDLE if you
prefer, note that some chapters, especially chapter 7, “Finding
and Fixing Code Bugs,” do contain material specific to IDLE.
The Python shell window looks like this:
At the top of the window, you can see the version of Python that is
running and some information about the operating system. If you see
a version less than 3.9, then you may need to revisit the installation
instructions in the previous section.
40
2.4. Ubuntu Linux
Important
If you open IDLE with the idle3 command and see a version less
than 3.9 displayed in the Python shell window, then you’ll need
to open IDLE with the idle-python3.9 command.
The >>> symbol that you see in the IDLE window is called a prompt.
Whenever you see this, it means that Python is waiting for you to give
it some instructions.
Interactive Quiz
This chapter comes with a free online quiz to check your learning progress. You can access the quiz using your phone or computer at the following web address:
realpython.com/quizzes/pybasics-setup
Now that you have Python installed, let’s get straight into writing your
first Python program! Go ahead and move on to chapter 3.
41
Chapter 3
Your First Python Program
Now that you have the latest version of Python installed on your computer, it’s time to start coding!
In this chapter, you will:
• Write your first Python program
• Learn what happens when you run a program with an error
• Learn how to declare a variable and inspect its value
• Learn how to write comments
Ready to begin your Python journey? Let’s go!
42
3.1. Write a Python Program
3.1 Write a Python Program
If you don’t already have IDLE open, then go ahead and open it. There
are two main windows that you’ll work with in IDLE: the interactive
window, which is the one that opens when you start IDLE, and the
editor window.
You can type code into both the interactive window and the editor window. The difference between the two windows is in how they execute
code. In this section, you’ll learn how to execute Python code in both
windows.
The Interactive Window
IDLE’s interactive window contains a Python shell, which is a textual user interface used to interact with the Python language. You can
type a bit of Python code into the interactive window and press Enter
to immediately see the results. Hence the name interactive window.
The interactive window opens automatically when you start IDLE.
You’ll see the following text, with some minor differences depending
on your setup, displayed at the top of the window:
Python 3.9.0 (tags/v3.9.0:1b293b6)
[MSC v.1916 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
This text shows the version of Python that IDLE is running. You
can also see information about your operating system and some
commands you can use to get help and view information about
Python.
The >>> symbol in the last line is called the prompt. This is where
you’ll type in your code.
43
3.1. Write a Python Program
Go ahead and type 1 + 1 at the prompt and press Enter :
>>> 1 + 1
2
>>>
Python evaluates the expression, displays the result (2), then displays
another prompt. Every time you run some code in the interactive window, a new prompt appears directly below the result.
Executing Python in the interactive window can be described as a loop
with three steps:
1. Python reads the code entered at the prompt.
2. Python evaluates the code.
3. Python prints the result and waits for more input.
This loop is commonly referred to as a read-evaluate-print loop and
is abbreviated as REPL. Python programmers sometimes refer to the
Python shell as the Python REPL, or just “the REPL” for short.
Let’s try something a little more interesting than adding numbers. A
rite of passage for every programmer is writing a program that prints
the phrase “Hello, World” on the screen.
At the prompt in the interactive window, type the word print followed
by a set of parentheses with the text "Hello, World" inside:
>>> print("Hello, World")
Hello, World
44
3.1. Write a Python Program
A function is code that performs some task and can be invoked by a
name. The above code invokes, or calls, the print() function with the
text "Hello, World" as input.
The parentheses tell Python to call the print() function. They also enclose everything that gets sent to the function as input. The quotation
marks indicate that "Hello, World" really is text and not something
else.
Note
IDLE highlights parts of your code in different colors as you
type to make it easier for you to identify the different parts.
By default, functions are highlighted in purple and text is highlighted in green.
The interactive window executes a single line of code at a time. This
is useful for trying out small code examples and exploring the Python
language, but it has a major limitation: you have to enter your code
one line at a time!
Alternatively, you can save Python code in a text file and execute all of
the code in the file to run an entire program.
The Editor Window
You’ll write your Python files using IDLE’s editor window. You can
open the editor window by selecting File New File from the menu at
the top of the interactive window.
The interactive window stays open when you open the editor window.
It displays the output generated by code in the editor window, so you’ll
want to arrange the two windows so that you can see them both at the
same time.
45
3.1. Write a Python Program
In the editor window, type in the same code you used to print "Hello,
World" in the interactive window:
print("Hello, World")
IDLE highlights code typed into the editor window just like in the interactive window.
Important
When you write code in a Python file, you don’t need to include
the >>> prompt.
Before you run your program, you need to save it. Select File Save
from the menu and save the file as hello_world.py.
Note
On some systems, the default directory for saving files in IDLE
is the Python installation directory. Do not save your files to
this directory. Instead, save them to your desktop or to a folder
in your user’s home directory.
The .py extension indicates that a file contains Python code. In fact,
saving your file with any other extension removes the code highlighting. IDLE only highlights Python code when it’s stored in a .py file.
Running Python Programs in the Editor Window
To run your program, select Run Run Module from the menu in the
editor window.
Note
Pressing F5 also runs a program from the editor window.
Program output always appears in the interactive window.
46
3.2. Mess Things Up
Every time you run code from a file, you’ll see something like the following output in the interactive window:
>>> =================== RESTART ===================
IDLE restarts the Python interpreter, which is the computer program
that actually executes your code, every time you run a file. This makes
sure that programs are executed the same way each time.
Opening Python Files in the Editor Window
To open an existing file in IDLE, select File Open from the menu,
then select the file you want to open. IDLE opens every file in a new
editor window, so you can have several files open at the same time.
You can also open a file from a file manager, such as Windows
Explorer or macOS Finder. Right-click the file icon and select
Edit with IDLE to open the file in IDLE’s editor window.
Double-clicking on a .py file from a file manager executes the program. However, this usually runs the file with the system Python,
and the program window disappears immediately after the program
terminates—often before you can even see any output.
For now, the best way to run your Python programs is to open them
in IDLE’s editor window and run them from there.
3.2 Mess Things Up
Everybody makes mistakes—especially while programming! In case
you haven’t made any mistakes yet, let’s get a head start and mess
something up on purpose to see what happens.
Mistakes in programs are called errors. You’ll experience two main
types of errors: syntax errors and runtime errors.
47
3.2. Mess Things Up
Syntax Errors
A syntax error occurs when you write code that isn’t allowed in the
Python language.
Let’s create a syntax error by removing the last quotation mark from
the code in the hello_world.py file that you created in the last section:
print("Hello, World)
Save the file and press F5 to run it. The code won’t run! IDLE displays an alert box with the following message:
EOL while scanning string literal.
There are two terms in this message that may be unfamiliar:
1. A string literal is text enclosed in quotation marks. "Hello,
World" is a string literal.
2. EOL stands for end of line.
So, the message tells you that Python got to the end of a line while
reading a string literal. String literals must be terminated with a quotation mark before the end of a line.
IDLE highlights the line containing print("Hello, World) in red to help
you quickly find the line of code with the syntax error. Without the
second quotation mark, everything after the first quotation mark—
including the closing parenthesis—is part of a string literal.
Runtime Errors
IDLE catches syntax errors before a program starts running. In contrast, runtime errors only occur while a program is running.
To generate a runtime error, remove both quotation marks in the
hello_world.py file:
48
3.2. Mess Things Up
print(Hello, World)
Did you notice how the text color changed to black when you removed
the quotation marks? IDLE no longer recognizes Hello, World as text.
What do you think will happen when you run the program? Press F5
to find out!
The following text displays in red in the interactive window:
Traceback (most recent call last):
File "/home/hello_world.py", line 1, in <module>
print(Hello, World)
NameError: name 'Hello' is not defined
Whenever an error occurs, Python stops executing the program and
displays several lines of text called a traceback. The traceback shows
useful information about the error.
Tracebacks are best read from the bottom up:
• The last line of the traceback tells you the name of the error and
the error message. In this case, a NameError occurred because the
name Hello is not defined anywhere.
• The second to last line shows you the code that produced the error.
There’s only one line of code in hello_world.py, so it’s not hard to
guess where the problem is. This information is more helpful for
larger files.
• The third to last line tells you the name of the file and the line number so you can go to the exact spot in your code where the error
occurred.
In the next section, you’ll see how to define names for values in your
code. Before you move on, though, you can get some practice with
syntax errors and runtime errors by working on the review exercises.
49
3.3. Create a Variable
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Write a program that IDLE won’t run because it has a syntax error.
2. Write a program that crashes only while it’s running because it has
a runtime error.
3.3 Create a Variable
In Python, variables are names that can be assigned a value and then
used to refer to that value throughout your code.
Variables are fundamental to programming for two reasons:
1. Variables keep values accessible: For example, you can assign the result of some time-consuming operation to a variable so
that your program doesn’t have to perform the operation each time
you need to use the result.
2. Variables give values context: The number 28 could mean lots
of different things, such as the number of students in a class, the
number of times a user has accessed a website, and so on. Giving
the value 28 a name like num_students makes the meaning of the
value clear.
In this section, you’ll learn how to use variables in your code, as well as
some of the conventions Python programmers follow when choosing
names for variables.
The Assignment Operator
An operator is a symbol, such as +, that performs an operation on
one or more values. For example, the + operator takes two numbers,
one to the left of the operator and one to the right, and adds them
together.
50
3.3. Create a Variable
Values are assigned to variable names using a special symbol called
the assignment operator (=) . The = operator takes the value to the
right of the operator and assigns it to the name on the left.
Let’s modify the hello_world.py file from the previous section to assign
some text in a variable before printing it to the screen:
>>> greeting = "Hello, World"
>>> print(greeting)
Hello, world
On the first line, you create a variable named greeting and assign it the
value "Hello, World" using the = operator.
print(greeting) displays the output Hello, World because Python looks
for the name greeting, finds that it’s been assigned the value "Hello,
World", and replaces the variable name with its value before calling
the function.
If you hadn’t executed greeting = "Hello, World" before executing
print(greeting), then you would have seen a NameError like you did
when you tried to execute print(Hello, World) in the previous section.
Note
Although = looks like the equals sign from mathematics, it has a
different meaning in Python. This distinction is important and
can be a source of frustration for beginner programmers.
Just remember, whenever you see the = operator, whatever is to
the right of it is being assigned to a variable on the left.
Variable names are case sensitive, so a variable named greeting is
not the same as a variable named Greeting. For instance, the following
code produces a NameError:
51
3.3. Create a Variable
>>> greeting = "Hello, World"
>>> print(Greeting)
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name 'Greeting' is not defined
If you have trouble with an example in this book, double-check that
every character in your code—including spaces—matches the example
exactly. Computers have no common sense, so being almost correct
isn’t good enough!
Rules for Valid Variable Names
Variable names can be as long or as short as you like, but there are a
few rules that you must follow. Variable names may contain uppercase and lowercase letters (A–Z, a–z), digits (0–9), and underscores
(_), but they cannot begin with a digit.
For example, each of the following is a valid Python variable name:
• string1
• _a1p4a
• list_of_names
The following aren’t valid variable names because they start with a
digit:
• 9lives
• 99_balloons
• 2beOrNot2Be
In addition to English letters and digits, Python variable names may
contain many different valid Unicode characters.
Unicode is a standard for digitally representing characters used in
most of the world’s writing systems. That means variable names can
contain letters from non-English alphabets, such as decorated letters
52
3.3. Create a Variable
like é and ü, and even Chinese, Japanese, and Arabic symbols.
However, not every system can display decorated characters, so it’s a
good idea to avoid them if you’re going to share your code with people
in different regions.
Note
You’ll learn more about Unicode in chapter 12.
You can also read about Python’s support for Unicode in the
official Python documentation.
Just because a variable name is valid doesn’t necessarily mean that
it’s a good name.
Choosing a good name for a variable can be surprisingly difficult. Fortunately, there are some guidelines that you can follow to help you
choose better names.
Descriptive Names Are Better Than Short Names
Descriptive variable names are essential, especially for complex
programs. Writing descriptive names often requires using multiple
words. Don’t be afraid to use long variable names.
In the following example, the value 3600 is assigned to the variable s:
s = 3600
The name s is totally ambiguous. Using a full word makes it a lot easier
to understand what the code means:
seconds = 3600
53
3.3. Create a Variable
seconds is a better name than s because it provides more context. But
it still doesn’t convey the full meaning of the code. Is 3600 the number
of seconds it takes for a process to finish, or is it the length of a movie?
There’s no way to tell.
The following name leaves no doubt about what the code means:
seconds_per_hour = 3600
When you read the above code, there’s no question that 3600 is the
number of seconds in an hour. seconds_per_hour takes longer to type
than both the single letter s and the word seconds, but the payoff in
clarity is massive.
Although naming variables descriptively means using longer variable
names, you should avoid using excessively long names. A good rule
of thumb is to limit variable names to three or four words maximum.
Python Variable Naming Conventions
In many programming languages, it’s common to write variable
names in mixedCase. In this system, you capitalize the first letter
of every word except the first and leave all other letters in lowercase.
For example, numStudents and listOfNames are written in mixedCase.
In Python, however, it’s more common to write variable names in
lower_case_with_underscores. In this system, you leave every
letter in lowercase and separate each word with an underscore. For
instance, both num_students and list_of_names are written using the
lower_case_with_underscores system.
There’s no rule mandating that you write your variable names in
lower_case_with_underscores. The practice is codified, though, in a
document called PEP 8, which is widely regarded as the official style
guide for writing Python.
54
3.4. Inspect Values in the Interactive Window
Note
PEP stands for Python Enhancement Proposal. A PEP is a design document used by the Python community to propose new
features to the language.
Following the standards outlined in PEP 8 ensures that your Python
code is readable by most Python programmers. This makes sharing
code and collaborating with other people easier for everyone involved.
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Using the interactive window, display some text using print().
2. Using the interactive window, assign a string literal to a variable.
Then print the contents of the variable using the print() function.
3. Repeat the first two exercises using the editor window.
3.4 Inspect Values in the Interactive
Window
Type the following into IDLE’s interactive window:
>>> greeting = "Hello, World"
>>> greeting
'Hello, World'
When you press Enter after typing greeting a second time, Python
prints the string literal assigned to greeting even though you didn’t
use the print() function. This is called variable inspection.
55
3.4. Inspect Values in the Interactive Window
Now print the string assigned to greeting using the print() function:
>>> print(greeting)
Hello, World
Can you spot the difference between the output displayed by using
print() and the output displayed by just entering the variable name
and pressing Enter ?
When you type the variable name greeting and press Enter , Python
prints the value assigned to the variable as it appears in your code.
You assigned the string literal "Hello, World" to greeting, which is why
'Hello, World' is displayed with quotation marks.
Note
String literals can be created with single or double quotation
marks in Python. At Real Python, we use double quotes wherever possible, whereas IDLE output appears in single quotes by
default.
Both "Hello, World" and 'Hello, World' mean the same thing in
Python—what’s most important is that you be consistent in your
usage. You’ll learn more about strings in chapter 4.
On the other hand, print() displays a more human-readable representation of the variable’s value which, for string literals, means displaying the text without quotation marks.
Sometimes, both printing and inspecting a variable produce the same
output:
>>> x = 2
>>> x
2
>>> print(x)
2
56
3.4. Inspect Values in the Interactive Window
Here, you assign the number 2 to x. Both using print(x) and inspecting
x display output without quotation marks because 2 is a number and
not text. In most cases, though, variable inspection gives you more
useful information than print().
Suppose you have two variables: x, which is assigned the number 2,
and y, which is assigned the string literal "2". In this case, print(x)
and print(y) both display the same thing:
>>> x = 2
>>> y = "2"
>>> print(x)
2
>>> print(y)
2
However, inspecting x and y shows the difference between each variable’s value:
>>> x
2
>>> y
'2'
The key takeaway here is that print() displays a readable representation of a variable’s value, while variable inspection displays the value
as it appears in the code.
Keep in mind that variable inspection works only in the interactive
window. For example, try running the following program from the
editor window:
greeting = "Hello, World"
greeting
The program executes without any errors, but it doesn’t display any
output!
57
3.5. Leave Yourself Helpful Notes
3.5 Leave Yourself Helpful Notes
Programmers sometimes read code they wrote a while ago and wonder, “What does this do?” When you haven’t looked at code in a while,
it can be difficult to remember why you wrote it the way you did!
To help avoid this problem, you can leave comments in your code.
Comments are lines of text that don’t affect the way a program runs.
They document what code does or why the programmer made certain
decisions.
How to Write a Comment
The most common way to write a comment is to begin a new line in
your code with the # character. When you run your code, Python ignores lines starting with #.
Comments that start on a new line are called block comments. You
can also write inline comments, which are comments that appear
on the same line as the code they reference. Just put a # at the end of
the line of code, followed by the text in your comment.
Here’s an example of a program with both kinds of comments:
# This is a block comment.
greeting = "Hello, World"
print(greeting) # This is an inline comment.
Of course, you can still use the # symbol inside a string. For instance,
Python won’t mistake the following for the start of a comment:
>>> print("#1")
#1
In general, it’s a good idea to keep comments as short as possible, but
sometimes you need to write more than reasonably fits on a single line.
In that case, you can continue your comment on a new line that also
begins with the # symbol:
58
3.5. Leave Yourself Helpful Notes
# This is my first program.
# It prints the phrase "Hello, World"
# The comments are longer than the code!
greeting = "Hello, World"
print(greeting)
You can also use comments to comment out code while you’re testing a program. Putting a # at the beginning of a line of code lets you
run your program as if that line of code didn’t exist, but it doesn’t actually delete the code.
To comment out a section of code in IDLE, highlight one or more lines
to be commented and press:
• Windows: Alt + 3
• macOS: Ctrl + 3
• Ubuntu Linux: Ctrl + D
To remove comments, highlight the commented lines and press:
• Windows: Alt + 4
• macOS: Ctrl + 4
• Ubuntu Linux: Ctrl + Shift + D
Now let’s look at some common conventions for code comments.
Conventions and Pet Peeves
According to PEP 8, comments should always be written in complete
sentences with a single space between the # and the first word of the
comment:
# This comment is formatted to PEP 8.
#this one isn't
For inline comments, PEP 8 recommends at least two spaces between
59
3.6. Summary and Additional Resources
the code and the # symbol:
phrase = "Hello, World" # This comment is PEP 8 compliant.
print(phrase)# This comment isn't.
PEP 8 recommends that comments be used sparingly. A major pet
peeve among programmers is comments that describe what is already
obvious from reading the code.
For example, the comment in the following code is unnecessary:
# Print "Hello, World"
print("Hello, World")
The comment is unnecessary because the code itself explicitly describes what’s happening. Comments are best used to clarify code
that may be difficult to understand or to explain why something is
coded a certain way.
3.6 Summary and Additional Resources
In this chapter, you wrote and executed your first Python program!
You wrote a small program that displays the text "Hello, World" using
the print() function.
Then you learned about syntax errors, which occur before IDLE executes a program that contains invalid Python code, and runtime
errors, which only occur while a program is running.
You saw how to assign values to variables using the assignment
operator (=) and how to inspect variables in the interactive window.
Finally, you learned how to write helpful comments in your code for
when you or someone else looks at it in the future.
60
3.6. Summary and Additional Resources
Interactive Quiz
This chapter comes with a free online quiz to check your learning progress. You can access the quiz using your phone or computer at the following web address:
realpython.com/quizzes/pybasics-first-program
Additional Resources
To learn more, check out the following resources:
• “11 Beginner Tips for Learning Python Programming”
• “Writing Comments in Python (Guide)”
For links and additional resources to further deepen your Python
skills, visit realpython.com/python-basics/resources
61
Chapter 4
Strings and String Methods
Many programmers, regardless of their specialty, deal with text on a
daily basis. For example, web developers work with text input from
web forms. Data scientists process text to extract data and perform
tasks like sentiment analysis, which can help identify and classify
opinions in a body of text.
Collections of text in Python are called strings. Special functions
called string methods are used to manipulate strings. There are
string methods for changing a string from lowercase to uppercase, removing whitespace from the beginning or end of a string, replacing
parts of a string with different text, and much more.
In this chapter, you’ll learn how to:
• Manipulate strings with string methods
• Work with user input
• Deal with strings of numbers
• Format strings for printing
Let’s get started!
62
4.1. What Is a String?
4.1 What Is a String?
In chapter 3, you created the string "Hello, World" and printed it in
IDLE’s interactive window using print(). In this section, you’ll get a
deeper look into exactly what strings are and the various ways you can
create them in Python.
The String Data Type
Strings are one of the fundamental Python data types. The term data
type refers to what kind of data a value represents. Strings are used
to represent text.
Note
There are several other data types built into Python. For example, you’ll learn about numerical data types in chapter 5 and
Boolean data types in chapter 8.
We say that strings are a fundamental data type because they can’t
be broken down into smaller values of a different type. Not all data
types are fundamental. You’ll learn about compound data types, also
known as data structures, in chapter 9.
The string data type has a special abbreviated name in Python: str.
You can see this by using type(), which is a function used to determine
the data type of a given value.
Type the following into IDLE’s interactive window:
>>> type("Hello, World")
<class 'str'>
The output <class 'str'> indicates that the value "Hello, World" is an
instance of the str data type. That is, "Hello, World" is a string.
63
4.1. What Is a String?
Note
For now, you can think of the word class as a synonym for data
type, although it actually refers to something more specific.
You’ll see just what a class is in chapter 10.
type() also works for values that have been assigned to a variable:
>>> phrase = "Hello, World"
>>> type(phrase)
<class 'str'>
Strings have three important properties:
1. Strings contain individual letters or symbols called characters.
2. Strings have a length, defined as the number of characters the
string contains.
3. Characters in a string appear in a sequence, which means that
each character has a numbered position in the string.
Let’s take a closer look at how strings are created.
String Literals
As you’ve already seen, you can create a string by surrounding some
text with quotation marks:
string1 = 'Hello, World'
string2 = "1234"
You can use either single quotes (string1) or double quotes (string2)
to create a string as long as you use the same type at the beginning
and end of the string.
Whenever you create a string by surrounding text with quotation
marks, the string is called a string literal. The name indicates that
the string is literally written out in your code. All the strings you’ve
seen thus far are string literals.
64
4.1. What Is a String?
Note
Not every string is a string literal. Sometimes strings are input
by a user or read from a file. Since they’re not typed out with
quotation marks in your code, they’re not string literals.
The quotes surrounding a string are called delimiters because they
tell Python where a string begins and where it ends. When one type of
quotes is used as the delimiter, the other type can be used inside the
string:
string3 = "We're #1!"
string4 = 'I said, "Put it over by the llama."'
After Python reads the first delimiter, it considers all the characters
after it part of the string until it reaches a second matching delimiter.
This is why you can use a single quote in a string delimited by double
quotes, and vice versa.
If you try to use double quotes inside a string delimited by double
quotes, you’ll get an error:
>>> text = "She said, "What time is it?""
File "<stdin>", line 1
text = "She said, "What time is it?""
^
SyntaxError: invalid syntax
Python throws a SyntaxError because it thinks the string ends after the
second ", and it doesn’t know how to interpret the rest of the line. If
you need to include a quotation mark that matches the delimiter inside a string, then you can escape the character using a backslash:
>>> text = "She said, \"What time is it?\""
>>> print(text)
She said, "What time is it?"
65
4.1. What Is a String?
Note
When you work on a project, it’s a good idea to use only single
quotes or only double quotes to delimit every string.
Keep in mind that there really isn’t a right or wrong choice! The
goal is to be consistent because consistency helps make your
code easier to read and understand.
Strings can contain any valid Unicode character. For example, the
string "We're #1!" contains the pound sign (#) and "1234" contains numbers. "×Pýŧħøŋ×" is also a valid Python string!
Determine the Length of a String
The number of characters contained in a string, including spaces, is
called the length of the string. For example, the string "abc" has a
length of 3, and the string "Don't Panic" has a length of 11.
Python has a built-in len() function that you can use to determine the
length of a string. To see how it works, type the following into IDLE’s
interactive window:
>>> len("abc")
3
You can also use len() to get the length of a string that’s assigned to a
variable:
>>> letters = "abc"
>>> len(letters)
3
First, you assign the string "abc" to the variable letters. Then you use
len() to get the length of letters, which is 3.
66
4.1. What Is a String?
Multiline Strings
The PEP 8 style guide recommends that each line of Python code contain no more than seventy-nine characters—including spaces.
Note
PEP 8’s seventy-nine-character line length is a recommendation, not a rule. Some Python programmers prefer a slightly
longer line length.
In this book, we’ll strictly follow PEP 8’s recommended line
length.
Whether you follow PEP 8 or choose a longer line length, sometimes
you’ll need to create string literals with more characters than your chosen limit.
To deal with long strings, you can break them up across multiple lines
into multiline strings. For example, suppose you need to fit the
following text into a string literal:
This planet has—or rather had—a problem, which was
this: most of the people living on it were unhappy for
pretty much of the time. Many solutions were suggested
for this problem, but most of these were largely concerned with the movements of small green pieces of
paper, which is odd because on the whole it wasn’t the
small green pieces of paper that were unhappy.
— Douglas Adams, The Hitchhiker’s Guide to the Galaxy
This paragraph contains far more than seventy-nine characters, so
any line of code containing the paragraph as a string literal violates
PEP 8. So, what do you do?
There are a couple of ways to tackle this. One way is to break the string
up across multiple lines and put a backslash (\) at the end of all but the
67
4.1. What Is a String?
last line. To be PEP 8 compliant, the total length of the line, including
the backslashes, must be seventy-nine characters or fewer.
Here’s how you could write the paragraph as a multiline string using
the backslash method:
paragraph = "This planet has—or rather had—a problem, which was \
this: most of the people living on it were unhappy for pretty much \
of the time. Many solutions were suggested for this problem, but \
most of these were largely concerned with the movements of small \
green pieces of paper, which is odd because on the whole it wasn't \
the small green pieces of paper that were unhappy."
Notice that you don’t have to close each line with a quotation mark.
Normally, Python would get to the end of the first line and complain
that you didn’t close the string with a matching double quote. With a
backslash at the end, you can keep writing the same string on the next
line.
When you print() a multiline string that’s broken up by backslashes,
the output is displayed on a single line:
>>> long_string = "This multiline string is \
displayed on one line"
>>> print(long_string)
This multiline string is displayed on one line
You can also create multiline strings using triple quotes (""" or ''') as
delimiters. Here’s how to write a long paragraph using this approach:
paragraph = """This planet has—or rather had—a problem, which was
this: most of the people living on it were unhappy for pretty much
of the time. Many solutions were suggested for this problem, but
most of these were largely concerned with the movements of small
green pieces of paper, which is odd because on the whole it wasn't
the small green pieces of paper that were unhappy."""
68
4.2. Concatenation, Indexing, and Slicing
Triple-quoted strings preserve whitespace, including newlines. This
means that running print(paragraph) would display the string on multiple lines, just as it appears in the string literal. This may or may not
be what you want, so you’ll need to think about the desired output
before you choose how to write a multiline string.
To see how whitespace is preserved in a triple-quoted string, type the
following into IDLE’s interactive window:
>>> print("""An example of a
... string that spans across multiple lines
... and also preserves whitespace.""")
An example of a
string that spans across multiple lines
and also preserves whitespace.
Notice how the second and third lines in the output are indented in
exactly the same way as the string literal.
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Print a string that uses double quotation marks inside the string.
2. Print a string that uses an apostrophe inside the string.
3. Print a string that spans multiple lines with whitespace preserved.
4. Print a string that is coded on multiple lines but gets printed on a
single line.
4.2 Concatenation, Indexing, and
Slicing
Now that you know what a string is and how to declare string literals
in your code, let’s explore some of the things you can do with strings.
69
4.2. Concatenation, Indexing, and Slicing
In this section, you’ll learn about three basic string operations:
1. Concatenation, which joins two strings together
2. Indexing, which gets a single character from a string
3. Slicing, which gets several characters from a string at once
Let’s dive in!
String Concatenation
You can combine, or concatenate, two strings using the + operator:
>>> string1 = "abra"
>>> string2 = "cadabra"
>>> magic_string = string1 + string2
>>> magic_string
'abracadabra'
In this example, the string concatenation occurs on the third line. You
concatenate string1 and string2 using +, and then you assign the result to the variable magic_string. Notice that the two strings are joined
without any whitespace between them.
You can use string concatenation to join two related strings, such as
joining a first name and a last name into a full name:
>>> first_name = "Arthur"
>>> last_name = "Dent"
>>> full_name = first_name + " " + last_name
>>> full_name
'Arthur Dent'
Here, you use string concatenation twice on the same line. First, you
concatenate first_name with " " to ensure a space appears after the
first name in the final string. This produces the string "Arthur ", which
you then concatenate with last_name to produce the full name "Arthur
Dent".
70
4.2. Concatenation, Indexing, and Slicing
String Indexing
Each character in a string has a numbered position called an index.
You can access the character at the nth position by putting the number
n between two square brackets ([]) immediately after the string:
>>> flavor = "fig pie"
>>> flavor[1]
'i'
flavor[1] returns the character at position 1 in "fig pie", which is i.
Wait. Isn’t f the first character of "fig pie"?
In Python—and in most other programming languages—counting always starts at zero. To get the character at the beginning of a string,
you need to access the character at position 0:
>>> flavor[0]
'f'
Important
Forgetting that counting starts with zero and trying to access
the first character in a string with the index 1 results in an oпby-one error.
Off-by-one errors are a common source of frustration for beginning and experienced programmers alike!
The following figure shows the index for each character of the string
"fig pie":
| f | i | g | | p | i | e |
0 1 2 3 4 5 6
71
4.2. Concatenation, Indexing, and Slicing
If you try to access an index beyond the end of a string, then Python
raises an IndexError:
>>> flavor[9]
Traceback (most recent call last):
File "<pyshell#4>", line 1, in <module>
flavor[9]
IndexError: string index out of range
The largest index in a string is always one less than the string’s length.
Since "fig pie" has a length of seven, the largest index allowed is 6.
Strings also support negative indices:
>>> flavor[-1]
'e'
The last character in a string has index -1, which for "fig pie" is the
letter e. The second to last character i has index -2, and so on.
The following figure shows the negative index for each character in
the string "fig pie":
| f | i | g | | p | i | e |
-7 -6 -5 -4 -3 -2 -1
Just like with positive indices, Python raises an IndexError if you try to
access a negative index less than the index of the first character in the
string:
>>> flavor[-10]
Traceback (most recent call last):
File "<pyshell#5>", line 1, in <module>
flavor[-10]
IndexError: string index out of range
Negative indices may not seem useful at first, but sometimes they’re
a better choice than a positive index.
72
4.2. Concatenation, Indexing, and Slicing
For example, suppose a string input by a user is assigned to the variable user_input. If you need to get the last character of the string, how
do you know what index to use?
One way to get the last character of a string is to calculate the final
index using len():
final_index = len(user_input) - 1
last_character = user_input[final_index]
Getting the final character with the index -1 takes less typing and
doesn’t require an intermediate step to calculate the final index:
last_character = user_input[-1]
String Slicing
Suppose you need a string containing just the first three letters of the
string "fig pie". You could access each character by index and concatenate them like this:
>>> first_three_letters = flavor[0] + flavor[1] + flavor[2]
>>> first_three_letters
'fig'
If you need more than just the first few letters of a string, then getting each character individually and concatenating them together is
clumsy and long-winded. Fortunately, Python provides a way to do
this with much less typing.
You can extract a portion of a string, called a substring, by inserting
a colon between two index numbers set inside square brackets like
this:
>>> flavor = "fig pie"
>>> flavor[0:3]
'fig'
73
4.2. Concatenation, Indexing, and Slicing
flavor[0:3] returns the first three characters of the string assigned to
flavor, starting with the character at index 0 and going up to but not including the character at index 3. The [0:3] part of flavor[0:3] is called
a slice. In this case, it returns a slice of "fig pie". Yum!
String slices can be confusing because the substring returned by
the slice includes the character whose index is the first number but
doesn’t include the character whose index is the second number.
To remember how slicing works, you can think of a string as a sequence of square slots. The left and right boundaries of each slot are
numbered sequentially from zero up to the length of the string, and
each slot is filled with a character in the string.
Here’s what this looks like for the string "fig pie":
| f | i | g | | p | i | e |
0 1 2 3 4 5 6 7
So, for "fig pie", the slice [0:3] returns the string "fig", and the slice
[3:7] returns the string " pie".
If you omit the first index in a slice, then Python assumes you want to
start at index 0:
>>> flavor[:3]
'fig'
The slice [:3] is equivalent to the slice [0:3], so flavor[:3] returns the
first three characters in the string "fig pie".
Similarly, if you omit the second index in the slice, then Python assumes you want to return the substring that begins with the character
74
4.2. Concatenation, Indexing, and Slicing
whose index is the first number in the slice and ends with the last character in the string:
>>> flavor[3:]
' pie'
For "fig pie", the slice [3:] is equivalent to the slice [3:7]. Since the
character at index 3 is a space, flavor[3:9] returns the substring that
starts with the space and ends with the last letter: " pie".
If you omit both the first and second numbers in a slice, you get a
string that starts with the character at index 0 and ends with the last
character. In other words, omitting both numbers in a slice returns
the entire string:
>>> flavor[:]
'fig pie'
It’s important to note that, unlike with string indexing, Python won’t
raise an IndexError when you try to slice between boundaries that fall
outside the beginning or ending boundaries of a string:
>>> flavor[:14]
'fig pie'
>>> flavor[13:15]
''
In this example, the first line gets the slice from the beginning of the
string up to but not including the fourteenth character. The string
assigned to flavor has a length of seven, so you might expect Python
to throw an error. Instead, it ignores any nonexistent indices and returns the entire string "fig pie".
The third line shows what happens when you try to get a slice in which
the entire range is out of bounds. flavor[13:15] attempts to get the
thirteenth and fourteenth characters, which don’t exist. Instead of
raising an error, Python returns the empty string ("").
75
4.2. Concatenation, Indexing, and Slicing
Note
The empty string is called empty because it doesn’t contain any
characters. You can create it by writing two quotation marks
with nothing between them:
empty_string = ""
A string with anything in it—even a space—is not empty. All the
following strings are non-empty:
non_empty_string1 = " "
non_empty_string2 = " "
non_empty_string3 = " "
Even though these strings don’t contain any visible characters,
they are non-empty because they do contain spaces.
You can use negative numbers in slices. The rules for slices with negative numbers are exactly the same as the rules for slices with positive
numbers. It helps to visualize the string as slots with the boundaries
labeled with negative numbers:
| f | i | g | | p | i | e |
-7 -6 -5 -4 -3 -2 -1
Just like before, the slice [x:y] returns the substring starting at index
x and going up to but not including y. For instance, the slice [-7:-4]
returns the first three letters of the string "fig pie":
>>> flavor[-7:-4]
'fig'
Notice, however, that the rightmost boundary of the string does not
have a negative index. The logical choice for that boundary would
seem to be the number 0, but that doesn’t work.
76
4.2. Concatenation, Indexing, and Slicing
Instead of returning the entire string, [-7:0] returns the empty string:
>>> flavor[-7:0]
''
This happens because the second number in a slice must correspond
to a boundary that is to the right of the boundary corresponding to the
first number, but both -7 and 0 correspond to the leftmost boundary
in the figure.
If you need to include the final character of a string in your slice, then
you can omit the second number:
>>> flavor[-7:]
'fig pie'
Of course, using flavor[-7:] to get the entire string is a bit odd considering that you can use the variable flavor without the slice to get the
same result!
Slices with negative indices are useful, though, for getting the last few
characters in a string. For example, flavor[-3:] is "pie".
Strings Are Immutable
To wrap this section up, let’s discuss an important property of string
objects. Strings are immutable, which means that you can’t change
them once you’ve created them. For instance, see what happens when
you try to assign a new letter to one particular character of a string:
>>> word = "goal"
>>> word[0] = "f"
Traceback (most recent call last):
File "<pyshell#16>", line 1, in <module>
word[0] = "f"
TypeError: 'str' object does not support item assignment
77
4.2. Concatenation, Indexing, and Slicing
Python throws a TypeError and tells you that str objects don’t support
item assignment.
If you want to alter a string, then you must create an entirely new
string. To change the string "goal" to the string "foal", you can use a
string slice to concatenate the letter "f" with everything but the first
letter of the word "goal":
>>> word = "goal"
>>> word = "f" + word[1:]
>>> word
'foal'
First, you assign the string "goal" to the variable word. Then you concatenate the slice word[1:], which is the string "oal", with the letter "f"
to get the string "foal". If you’re getting a different result here, then
make sure you’re including the colon character (:) as part of the string
slice.
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Create a string and print its length using len().
2. Create two strings, concatenate them, and print the resulting
string.
3. Create two strings, use concatenation to add a space between them,
and print the result.
4. Print the string "zing" by using slice notation to specify the correct
range of characters in the string "bazinga".
78
4.3. Manipulate Strings With Methods
4.3 Manipulate Strings With Methods
Strings come bundled with special functions called string methods
that you can use to work with and manipulate strings. There are numerous string methods available, but we’ll focus on some of the most
commonly used ones.
In this section, you’ll learn how to:
• Convert a string to uppercase or lowercase
• Remove whitespace from a string
• Determine if a string begins or ends with certain characters
Let’s go!
Converting String Case
To convert a string to all lowercase letters, you use the string’s .lower()
method. This is done by tacking .lower() onto the end of the string
itself:
>>> "Jean-Luc Picard".lower()
'jean-luc picard'
The dot (.) tells Python that what follows is the name of a method—
the lower() method in this case.
Note
We’ll refer to string methods with a dot (.) at the beginning of
their names. For example, .lower() is written with a leading dot
instead of as lower().
This makes it easier to differentiate functions that are string
methods from built-in functions like print() and type().
79
4.3. Manipulate Strings With Methods
String methods don’t just work on string literals. You can also use
.lower() on a string assigned to a variable:
>>> name = "Jean-Luc Picard"
>>> name.lower()
'jean-luc picard'
The opposite of .lower() is .upper(), which converts every character in
a string to uppercase:
>>> name.upper()
'JEAN-LUC PICARD'
Compare the .upper() and .lower() string methods to the len() function you saw in the last section. Aside from the different results of
these functions, the important distinction here is how they’re used.
len() is a stand-alone function. If you want to determine the length of
the name string, then you call the len() function directly:
>>> len(name)
15
On the other hand, .upper() and .lower() must be used in conjunction
with a string. They do not exist independently.
Removing Whitespace From a String
Whitespace is any character that is printed as blank space. This includes things like spaces and line feeds, which are special characters
that move output to a new line.
Sometimes you need to remove whitespace from the beginning or end
of a string. This is especially useful when working with strings that
come from user input, which may include extra whitespace characters
by accident.
80
4.3. Manipulate Strings With Methods
There are three string methods that you can use to remove whitespace
from a string:
1. .rstrip()
2. .lstrip()
3. .strip()
.rstrip() removes whitespace from the right side of a string:
>>> name = "Jean-Luc Picard "
>>> name
'Jean-Luc Picard '
>>> name.rstrip()
'Jean-Luc Picard'
In this example, the string "Jean-Luc Picard " has five trailing spaces.
You use .rstrip() to remove trailing spaces from the right-hand side
of the string. This returns the new string "Jean-Luc Picard", which no
longer has the spaces at the end.
.lstrip() works just like .rstrip(), except that it removes whitespace
from the left-hand side of the string:
>>> name = " Jean-Luc Picard"
>>> name
' Jean-Luc Picard'
>>> name.lstrip()
'Jean-Luc Picard'
To remove whitespace from both the left and the right sides of the
string at the same time, use .strip():
>>> name = " Jean-Luc Picard "
>>> name
' Jean-Luc Picard '
>>> name.strip()
'Jean-Luc Picard'
81
4.3. Manipulate Strings With Methods
It’s important to note that none of .rstrip(), .lstrip(), or .strip() removes whitespace from the middle of the string. In each of the previous examples, the space between "Jean-Luc" and "Picard" is preserved.
Determine If a String Starts or Ends With a
Particular String
When you work with text, sometimes you need to determine if a given
string starts with or ends with certain characters. You can use two
string methods to solve this problem: .startswith() and .endswith().
Let’s look at an example. Consider the string "Enterprise". Here’s how
you use .startswith() to determine if the string starts with the letters
e and n:
>>> starship = "Enterprise"
>>> starship.startswith("en")
False
You tell .startswith() which characters to search for by providing a
string containing those characters. So, to determine if "Enterprise"
starts with the letters e and n, you call .startswith("en"). This returns
False. Why do you think that is?
If you guessed that .startswith("en") returns False because "Enterprise" starts with a capital E, then you’re absolutely right! The
.startswith() method is case sensitive. To get .startswith() to
return True, you need to provide it with the string "En":
>>> starship.startswith("En")
True
You can use .endswith() to determine if a string ends with certain characters:
>>> starship.endswith("rise")
True
82
4.3. Manipulate Strings With Methods
Just like .startswith(), the .endswith() method is case sensitive:
>>> starship.endswith("risE")
False
Note
The True and False values are not strings. They are a special kind
of data type called a Boolean value. You’ll learn more about
Boolean values in chapter 8.
String Methods and Immutability
Recall from the previous section that strings are immutable—they
can’t be changed once they’ve been created. Most string methods
that alter a string, like .upper() and .lower(), actually return copies of
the original string with the appropriate modifications.
If you aren’t careful, this can introduce subtle bugs into your program.
Try this out in IDLE’s interactive window:
>>> name = "Picard"
>>> name.upper()
'PICARD'
>>> name
'Picard'
When you call name.upper(), nothing about name actually changes. If
you need to keep the result, then you need to assign it to a variable:
>>> name = "Picard"
>>> name = name.upper()
>>> name
'PICARD'
name.upper() returns a new string "PICARD", which is reassigned to the
name variable. This overrides the original string "Picard" that you first
assigned to name.
83
4.3. Manipulate Strings With Methods
Use IDLE to Discover Additional String Methods
Strings have lots of methods associated with them, and the methods
introduced in this section barely scratch the surface. IDLE can help
you find new string methods. To see how, first assign a string literal
to a variable in the interactive window:
>>> starship = "Enterprise"
Next, type starship followed by a period, but do not hit Enter . You
should see the following in the interactive window:
>>> starship.
Now wait for a couple of seconds. IDLE displays a list of every string
method, which you can scroll through using the arrow keys.
A related shortcut in IDLE is the ability to use Tab to automatically
fill in text without having to type long names. For instance, if you
type only starship.u and hit Tab , then IDLE automatically fills in starship.upper because only one method that begins with a u belongs to
starship.
This even works with variable names. Try typing just the first few letters of starship and pressing Tab . If you haven’t defined any other
names that share those first letters, then IDLE completes the name
starship for you.
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Write a program that converts the following strings to lowercase:
"Animals", "Badger", "Honey Bee", "Honey Badger". Print each lowercase string on a separate line.
2. Repeat exercise 1, but convert each string to uppercase instead of
lowercase.
84
4.4. Interact With User Input
3. Write a program that removes whitespace from the following
strings, then print out the strings with the whitespace removed:
string1 = " Filet Mignon"
string2 = "Brisket "
string3 = " Cheeseburger "
4. Write a program that prints out the result of .startswith("be") on
each of the following strings:
string1 = "Becomes"
string2 = "becomes"
string3 = "BEAR"
string4 = " bEautiful"
5. Using the same four strings from exercise 4, write a program that
uses string methods to alter each string so that .startswith("be")
returns True for all of them.
4.4 Interact With User Input
Now that you’ve seen how to work with string methods, let’s make
things interactive!
In this section, you’ll learn how to get some input from a user with
input(). You’ll write a program that asks a user to input some text and
then displays that text back to them in uppercase.
Enter the following into IDLE’s interactive window:
>>> input()
When you press Enter , it looks like nothing happens. The cursor
moves to a new line, but a new >>> doesn’t appear. Python is waiting
for you to enter something!
85
4.4. Interact With User Input
Go ahead and type some text and press Enter :
>>> input()
Hello there!
'Hello there!'
>>>
The text you entered is repeated on a new line with single quotes.
That’s because input() returns as a string any text entered by the user.
To make input() a bit more user-friendly, you can give it a prompt to
display to the user. The prompt is just a string that you put between
the parentheses of input(). It can be anything you want: a word, a
symbol, a phrase—anything that is a valid Python string.
input() displays the prompt and waits for the user to type something.
When the user hits Enter , input() returns their input as a string that
can be assigned to a variable and used to do something in your program.
To see how input() works, type the following code into IDLE’s editor
window:
prompt = "Hey, what's up? "
user_input = input(prompt)
print("You said: " + user_input)
Press F5 to run the program. The text Hey, what's up? displays in the
interactive window with a blinking cursor.
The single space at the end of the string "Hey, what's up? " makes sure
that when the user starts to type, the text is separated from the prompt
with a space. When the user types a response and presses Enter , their
response is assigned to the user_input variable.
86
4.4. Interact With User Input
Here’s a sample run of the program:
Hey, what's up? Mind your own business.
You said: Mind your own business.
Once you have input from a user, you can do something with it. For
example, the following program takes user input, converts it to uppercase with .upper(), and prints the result:
response = input("What should I shout? ")
shouted_response = response.upper()
print("Well, if you insist..." + shouted_response)
Try typing this program into IDLE’s editor window and running it.
What else can you think of to do with the input?
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Write a program that takes input from the user and displays that
input back.
2. Write a program that takes input from the user and displays the
input in lowercase.
3. Write a program that takes input from the user and displays the
number of characters in the input.
87
4.5. Challenge: Pick Apart Your User’s Input
4.5 Challenge: Pick Apart Your User’s
Input
Write a program named first_letter.py that prompts the user for input with the string "Tell me your password:". The program should then
determine the first letter of the user’s input, convert that letter to uppercase, and display it back.
For example, if the user input is "no", then the program should display
the following output:
The first letter you entered was: N
For now, it’s okay if your program crashes when the user enters nothing as input—that is, when they just hit Enter instead of typing something. You’ll learn a couple of ways to deal with this situation in an
upcoming chapter.
You can пnd the solutions to this code challenge and many other bonus
resources online at realpython.com/python-basics/resources
4.6 Working With Strings and Numbers
When you get user input using input(), the result is always a string.
There are many other situations in which input is given to a program
as a string. Sometimes those strings contain numbers that need to be
fed into calculations.
In this section, you’ll learn how to deal with strings of numbers. You’ll
see how arithmetic operations work on strings and how they often lead
to surprising results. You’ll also learn how to convert between strings
and number types.
Using Strings With Arithmetic Operators
You’ve seen that string objects can hold many types of characters, including numbers. However, don’t confuse numerals in a string with
88
4.6. Working With Strings and Numbers
actual numbers. For instance, try this bit of code out in IDLE’s interactive window:
>>> num = "2"
>>> num + num
'22'
The + operator concatenates two strings together, which is why the
result of "2" + "2" is "22" and not "4".
You can multiply strings by a number as long as that number is an
integer or whole number. Type the following into the interactive window:
>>> num = "12"
>>> num * 3
'121212'
num * 3 concatenates three instances of the string "12" and returns the
string "121212".
Compare this operation to arithmetic with numbers. When you multiply the number 12 by the number 3, the result is the same as adding
three 12s together. The same is true for a string. That is, "12" * 3 can
be interpreted as "12" + "12" + "12". In general, multiplying a string
by an integer n concatenates n copies of that string.
You can move the number on the right-hand side of the expression num
* 3 to the left, and the result is unchanged:
>>> 3 * num
'121212'
What do you think happens if you use the * operator between two
strings?
89
4.6. Working With Strings and Numbers
Type "12" * "3" in the interactive window and press Enter :
>>> "12" * "3"
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'str'
Python raises a TypeError and tells you that you can’t multiply a sequence by a non-integer.
Note
A sequence is any Python object that supports accessing elements by index. Strings are sequences. You’ll learn about other
sequence types in chapter 9.
When you use the * operator with a string, Python always expects an
integer on the other side of the operator.
What do you think happens when you try to add a string and a number?
>>> "3" + 3
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: can only concatenate str (not "int") to str
Python throws a TypeError because it expects the objects on both sides
of the + operator to be of the same type.
If an object on either side of + is a string, then Python tries to perform
string concatenation. It will only perform addition if both objects are
numbers. So, to add "3" + 3 and get 6, you must first convert the string
"3" to a number.
90
4.6. Working With Strings and Numbers
Converting Strings to Numbers
The TypeError examples in the previous section highlight a common
problem when applying user input to an operation that requires a
number and not a string: type mismatches.
Let’s look at an example. Save and run the following program:
num = input("Enter a number to be doubled: ")
doubled_num = num * 2
print(doubled_num)
If you entered the number 2 at the prompt, then you would expect the
output to be 4. But in this case, you would get 22. Remember, input()
always returns a string, so if you input 2, then num is assigned the string
"2", not the integer 2. Therefore, the expression num * 2 returns the
string "2" concatenated with itself, which is "22".
To perform arithmetic on numbers contained in a string, you must
first convert them from a string type to a number type. There are two
functions that you can use to do this: int() and float().
int() stands for integer and converts objects into whole numbers,
whereas float() stands for сoating-point number and converts objects into numbers with decimal points. Here’s what using each one
looks like in the interactive window:
>>> int("12")
12
>>> float("12")
12.0
Notice how float() adds a decimal point to the number. Floatingpoint numbers always have at least one decimal place of precision. For
this reason, you can’t change a string that looks like a floating-point
number into an integer because you would lose everything after the
decimal point.
91
4.6. Working With Strings and Numbers
Try converting the string "12.0" to an integer:
>>> int("12.0")
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '12.0'
Even though the extra 0 after the decimal place doesn’t add any value
to the number, Python won’t change 12.0 into 12 because it would result in a loss of precision.
Let’s revisit the program from the beginning of this section and see
how to fix it. Here’s the code again:
num = input("Enter a number to be doubled: ")
doubled_num = num * 2
print(doubled_num)
The issue is on the line doubled_num = num * 2 because num is a string
and 2 is an integer.
You can fix the problem by passing num to either int() or float(). Since
the prompts asks the user to input a number, and not specifically an
integer, let’s convert num to a floating-point number:
num = input("Enter a number to be doubled: ")
doubled_num = float(num) * 2
print(doubled_num)
Now when you run this program and input 2, you get 4.0 as expected.
Try it out!
Converting Numbers to Strings
Sometimes you need to convert a number to a string. You might do
this, for example, if you need to build a string from some preexisting
variables that are assigned to numeric values.
92
4.6. Working With Strings and Numbers
As you’ve already seen, concatenating a number with a string produces a TypeError:
>>> num_pancakes = 10
>>> "I am going to eat " + num_pancakes + " pancakes."
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
TypeError: can only concatenate str (not "int") to str
Since num_pancakes is a number, Python can’t concatenate it with the
string "I'm going to eat". To build the string, you need to convert
num_pancakes to a string using str():
>>> num_pancakes = 10
>>> "I am going to eat " + str(num_pancakes) + " pancakes."
'I am going to eat 10 pancakes.'
You can also call str() on a number literal:
>>> "I am going to eat " + str(10) + " pancakes."
'I am going to eat 10 pancakes.'
str() can even handle arithmetic expressions:
>>> total_pancakes = 10
>>> pancakes_eaten = 5
>>> "Only " + str(total_pancakes - pancakes_eaten) + " pancakes left."
'Only 5 pancakes left.'
In the next section, you’ll learn how to format strings neatly to display
values in a nice, readable manner. Before you move on, though, check
your understanding with the following review exercises.
93
4.7. Streamline Your Print Statements
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Create a string containing an integer, then convert that string into
an actual integer object using int(). Test that your new object is
a number by multiplying it by another number and displaying the
result.
2. Repeat the previous exercise, but use a floating-point number and
float().
3. Create a string object and an integer object, then display them side
by side with a single print statement using str().
4. Write a program that uses input() twice to get two numbers from
the user, multiplies the numbers together, and displays the result.
If the user enters 2 and 4, then your program should print the
following text:
The product of 2 and 4 is 8.0.
4.7 Streamline Your Print Statements
Suppose you have a string, name = "Zaphod", and two integers, heads
= 2 and arms = 3. You want to display them in the string "Zaphod has
2 heads and 3 arms". This is called string interpolation, which is
just a fancy way of saying that you want to insert some variables into
specific locations in a string.
One way to do this is with string concatenation:
>>> name + " has " + str(heads) + " heads and " + str(arms) + " arms"
'Zaphod has 2 heads and 3 arms'
This code isn’t the prettiest, and keeping track of what goes inside or
outside the quotes can be tough. Fortunately, there’s another way of
interpolating strings: formatted string literals, more commonly
94
4.7. Streamline Your Print Statements
known as f-strings.
The easiest way to understand f-strings is to see them in action. Here’s
what the above string looks like when written as an f-string:
>>> f"{name} has {heads} heads and {arms} arms"
'Zaphod has 2 heads and 3 arms'
There are two important things to notice about the above example:
1. The string literal starts with the letter f before the opening quotation mark.
2. Variable names surrounded by curly braces ({}) are replaced by
their corresponding values without using str().
You can also insert Python expressions between the curly braces. The
expressions are replaced with their result in the string:
>>> n = 3
>>> m = 4
>>> f"{n} times {m} is {n*m}"
'3 times 4 is 12'
It’s a good idea to keep any expressions used in an f-string as simple
as possible. Packing a bunch of complicated expressions into a string
literal can result in code that is difficult to read and difficult to maintain.
f-strings are available only in Python version 3.6 and above. In earlier versions of Python, you can use .format() to get the same results.
Returning to the Zaphod example, you can use .format() to format the
string like this:
>>> "{} has {} heads and {} arms".format(name, heads, arms)
'Zaphod has 2 heads and 3 arms'
f-strings are shorter and sometimes more readable than using .format(). You’ll see f-strings used throughout this book.
95
4.8. Find a String in a String
For an in-depth guide to f-strings and comparisons to other string formatting techniques, check out Real Python’s “Python 3’s f-Strings: An
Improved String Formatting Syntax (Guide).”
Review Exercises
You can пnd the solutions to these exercises and many other bonus
resources online at realpython.com/python-basics/resources
1. Create a float object named weight with the value 0.2, and create
a string object named animal with the value "newt". Then use these
objects to print the following string using only string concatenation:
0.2 kg is the weight of the newt.
2. Display the same string by using .format() and empty {} placeholders.
3. Display the same string using an f-string.
4.8 Find a String in a String
One of the most useful string methods is .find(). As its name implies,
this method allows you to find the location of one string in another
string—commonly referred to as a substring.
To use .find(), tack it to the end of a variable or a string literal with
the string you want to find typed between the parentheses:
>>> phrase = "the surprise is in here somewhere"
>>> phrase.find("surprise")
4
The value that .find() returns is the index of the first occurrence of the
string you pass to it. In this case, "surprise" starts at the fifth character
of the string "the surprise is in here somewhere", which has index 4
because counting starts at zero.
96
This is a sample from “Python Basics: A Practical
Introduction to Python 3”
With the full version of the book you get a complete Python curriculum
to go all the way from beginner to intermediate-level. Every step along
the way is explained and illustrated with short & clear code samples.
Coding exercises within each chapter and our interactive quizzes help
fast-track your progress and ensure you always know what to focus on
next.
Become a fluent Pythonista and gain programming knowledge you
can apply in the real-world, today:
If you enjoyed the sample chapters you can purchase a full
version of the book at realpython.com/pybasics-book